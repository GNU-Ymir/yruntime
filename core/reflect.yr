/**
 * This module implements the management of reflection for symbol
 * retreiving using their string name. Symbols are stored in a HashMap
 * once loaded (from ELF on Linux for example), so that accessing them
 * is not that costly. The creation of the index is relatively
 * expensive on the other hand, but is done only one time for every
 * loaded segments (executable, so libs on linux, etc.).
 * 
 * @Authors: Emile Cadorel
 * @License: GPLv3
 */

mod core::reflect;

import std::collection::map;
import std::conv;
import std::io;

pub enum
| FUNCTION = 0
| VTABLE   = 1
| NONE	   = 2
 -> ReflectSymbolType;

pub struct
| type : ReflectSymbolType
| ptr : usize
| name : &c8
| locFile : &c8
| line : i32
 -> ReflectSymbol;

static dmut __REFLECT_SYMBOL_TABLE__ = HashMap!{[c8], ReflectSymbol}::new ();
static dmut __INV_REFLECT_SYMBOL_TABLE__ = HashMap!{usize, ReflectSymbol}::new ();

__version WINDOWS {
    struct
    | entries : [ReflectSymbolTableEntry]
     -> ReflectSymbolTable;

    struct
    | moduleName : &c8
    | symbols : [ReflectSymbol]
     -> ReflectSymbolTableEntry;
    
    extern (C) def _yrt_reflect_construct_index_table (symbol_table : ReflectSymbolTable) {
        for entry in symbol_table.entries {
            for sym in entry.symbols {
                let name = sym.name.fromStringZ ()?;
                match name {
                    Ok (s : _) => 
                        __REFLECT_SYMBOL_TABLE__:.insert (s, sym);
                }
                
                __INV_REFLECT_SYMBOL_TABLE__:.insert (sym.ptr, sym);
            }
        }
    }
}

__version LINUX {

    import etc::elf;
    
    static dmut __ELF_LOADER__ = ELFLoader::new ();

    extern (C) def _yrt_reflect_update_index_table () {
        __ELF_LOADER__:.update ();
    }
    
    pub extern (C) def _yrt_reflect_register_symbol (sym : ReflectSymbol) {
        let name = sym.name.fromStringZ ()?;
        match name {
            Ok (s : _) => {
                __REFLECT_SYMBOL_TABLE__:.insert (s, sym);
            }
        }
        
        __INV_REFLECT_SYMBOL_TABLE__:.insert (sym.ptr, sym);        
    }
    
}

extern (C) def _yrt_reflect_find_symbol_in_indexed_table (name : [c8])-> ReflectSymbol {
    match __REFLECT_SYMBOL_TABLE__.find (name) {
        Ok (sym : _) => {
            return sym
        }
        _ => {
            return ReflectSymbol (ReflectSymbolType::NONE, 0us, null, null, 0);
        }
    }
}

extern (C) def _yrt_reflect_find_symbol_in_indexed_table_from_addr (addr : usize)-> ReflectSymbol {
    let mut min = usize::max;
    let mut symbol = ReflectSymbol (ReflectSymbolType::NONE, 0us, null, null, 0);
    for _, sym in __REFLECT_SYMBOL_TABLE__ {
        if (sym.ptr < addr && (addr - sym.ptr) < min) {
            symbol = sym;
            min = (addr - sym.ptr);
        } else if (sym.ptr == addr) {
            return sym;
        }
    }

    return symbol
}
