mod std::concurrency::process;

import std::collection::vec;
import std::io;

import core::dispose;
import core::typeinfo;
import core::exception;
import std::stream;
import std::concurrency::pipe;
import etc::c::stdio;
import std::fs::path;
import std::conv;
import std::concurrency::thread;

__version LINUX {
    
    import etc::runtime::gc;

    extern (C) def getpgid ()-> i32;
    extern (C) def dup2 (stream : i32, type : u32)-> i32;
    extern (C) def _yrt_print_error (format : &(c8), ...);
    extern (C) def fork ()-> u32;
    extern (C) def execvp (cmd : &c8, args : &(&c8))-> i32;
    extern (C) def _yrt_exit (i : i32);
    extern (C) def waitpid (pid : u32, dmut status : &i32, ig : i32);
    extern (C) def kill (pid : u32, sig : i32)-> i32;
    extern (C) def chdir (path : &c8)-> i32;
    extern (C) def printf (c : &c8, ...);

    mod allocMod {T} {
        pub extern (C) def malloc (size : u32)-> dmut T;
    }


    extern (C) def memcpy (_ : &c8, _ : &c8, size : usize)-> void;
    extern (C) def free (a : &void);
    extern (C) def GC_is_disabled()-> i32;

    pub class @final SubProcess {

        let cmd : [c8];
        
        let args : [[c8]];

        let cwd : [c8];
        
        let mut pid : u32 = 0u32;

        let dmut _stdin = IOPipe::new ();
        let dmut _stdout = IOPipe::new ();
        let dmut _stderr = IOPipe::new ();

        /**
         * Run a process in parallel of this process execution
         * 
         */
        pub self run (cmd : [c8], args : [[c8]], cwd : &Path = Path::new (".")) with cmd = cmd, args = args, cwd = cwd.toStr () {
            self:.run ();
        }

        pub self run (path : &Path, args : [[c8]], cwd : &Path = Path::new (".")) with self (path.toStr (), args, cwd-> cwd) {}
        
        prv def run (mut self) {
            _yrt_disable_GC ();
            self.pid = fork (); // if nothing is written in the fork process the pages are not copied
            // Thus fork is lightweight
            
            if (self.pid == 0u32) {
                self:.child ()
            } else {
                _yrt_enable_GC ();
            }
            
            self._stdin:.ipipe ():.dispose ();
            self._stdout:.opipe ():.dispose ();
            self._stderr:.opipe ():.dispose ();

            self._stdin:.opipe ().setNonBlocking ();
            self._stdout:.ipipe ().setNonBlocking ();
            self._stderr:.ipipe ().setNonBlocking ();

        }

        prv def child (mut self) {
            self._stderr:.opipe ().setNonBlocking ();
            self._stdout:.opipe ().setNonBlocking ();    
            
            dup2 (self._stdin:.ipipe ().getHandle (), STDIN_FILENO);
            dup2 (self._stdout:.opipe ().getHandle (), STDOUT_FILENO);
            dup2 (self._stderr:.opipe ().getHandle (), STDERR_FILENO);

            self._stdin:.dispose ();
            self._stdout:.dispose ();
            self._stderr:.dispose ();
            
            __pragma!trusted ({
                let dmut res = allocMod!{&(&c8)}::malloc (cast!u32 (sizeof (&c8) * (self.args.len + 2us)));
                *res = allocMod!{&c8}::malloc (cast!u32 (sizeof (c8) * self.cmd.len + 1us));
                memcpy (*res, self.cmd.ptr, self.cmd.len);
                *((*res) + self.cmd.len) = '\u{0}'c8;
                
                for i in 0us .. self.args.len {
                    *(res + (i + 1us) * sizeof (&c8)) = allocMod!{&c8}::malloc (cast!u32 (sizeof (c8) * self.args [i].len + 1us));
                    memcpy (*(res + (i + 1us) * sizeof (&c8)), self.args [i].ptr, self.args [i].len);
                    *(*(res + (i + 1us) * sizeof (&c8)) + self.args [i].len) = '\u{0}'c8;
                };

                *(res + (self.args.len + 1us) * sizeof (&c8)) = null;

                let dmut cwd = allocMod!{&c8}::malloc (cast!u32 (sizeof (c8) * (self.cwd.len + 1us)));
                memcpy (cwd, self.cwd.ptr, self.cwd.len + 1us);
                *(cwd + self.cwd.len) = '\u{0}'c8;
                
                chdir (cwd);

                printf ("Calling execvp:"s8.ptr);
                let out = execvp (*res, res);
                printf ("Res execvp%d\n"s8.ptr, out);
                if (out == -1) {
                    _yrt_print_error (("execvp () failed"s8).ptr);            
                }
            });        

            
            _yrt_exit (0);
        }

        pub def stdin (mut self) -> dmut &OPipe {
            alias self._stdin:.opipe ()
        }
        
        pub def stdout (mut self)-> dmut &IPipe {
            alias (self._stdout:.ipipe ())
        }

        pub def stderr (mut self)-> dmut &IPipe  {
            alias (self._stderr:.ipipe ())
        }

        pub def isFinished (self)-> bool {
            waitpid (self.pid, null, 1);
            if (kill (self.pid, 0) == -1) return true;

            return false;                
        }
        
        pub def wait (mut self)-> i32 {
            let mut status = 0i32;
            self._stdin:.dispose ();
            waitpid (self.pid, alias &status, 0);
            return status;
        }

        impl Disposable {

            pub over dispose (mut self) {
                self._stdin:.opipe ():.dispose ();
                self._stdout:.ipipe ():.dispose ();
                self._stderr:.ipipe ():.dispose ();
            }
            
        }
        
    }
}

__version WINDOWS {
    
    import etc::c::files;

    extern (C) def CreateProcessA (appName : &c8, cmdLine : &c8, processAttr : &void, threadAttr : &void, inheritHandle : i32, creationFlags : i32, env : &void, currentDir : &c8, startupInfo : &STARTUPINFO, processInfo : &PROCESS_INFORMATION)-> i32;

    extern (C) def SetHandleInformation (handle : &void, flag : i32, value : i32)-> i32;
    
    extern (C) def WaitForSingleObject (handle : &void, timeout : i32)-> i32;

    extern (C) def GetExitCodeProcess (handle : &void, status : &i32)-> i32;


    struct
    | hProcess : &void = null
    | hThread : &void = null
    | dwProcessId : u32 = 0u32
    | dwThreadId : u32 = 0u32
     -> PROCESS_INFORMATION;

    struct
    | cb : i32 = cast!i32 (sizeof (STARTUPINFO))
    | lpReserved : &void = null
    | lpDesktop : &void = null
    | lpTitle : &void = null
    | dwX : i32 = 0
    | dwY : i32 = 0
    | dwXSize : i32 = 0
    | dwYSize : i32 = 0
    | dwXCountChars : i32 = 0
    | dwYCountChars : i32 = 0
    | dwFillAttributes : i32 = 0
    | mut dwFlags : i32 = 0
    | wShowWindow : bool = false
    | cbReserved2 : u8 = 0u8
    | lpReserved2 : &void = null
    | mut hStdInput : &void = null
    | mut hStdOutput : &void = null
    | mut hStdError : &void = null
     -> STARTUPINFO;
    
    pub class @final SubProcess {
        
        let cmd : [c8];
        
        let args : [[c8]];

        let cwd : [c8];
        
        let mut _processHandle : &void = null;
        
        let dmut _stdin = IOPipe::new ();
        let dmut _stdout = IOPipe::new ();
        let dmut _stderr = IOPipe::new ();

        /**
         * Run a process in parallel of this process execution
         * 
         */
        pub self run (cmd : [c8], args : [[c8]], cwd : &Path = Path::new (".")) with cmd = cmd, args = args, cwd = cwd.toStr () {
            self:.run ();
        }

        pub self run (path : &Path, args : [[c8]], cwd : &Path = Path::new (".")) with self (path.toStr (), args, cwd-> cwd) {}
        
        prv def run (mut self) {
            self:.createChild ();               
        }

        prv def createChild (mut self) {
            let dmut stream = StringStream::new ();
            stream:.write (self.cmd, " ");
            for i, a in self.args {
                if (i != 0us) stream:.write (" ");
                stream:.write (a);
            }

            SetHandleInformation (self._stdin:.opipe ():.getHandle (), 1, 0);
            SetHandleInformation (self._stdout:.ipipe ():.getHandle (), 1, 0);
            SetHandleInformation (self._stderr:.ipipe ():.getHandle (), 1, 0);
            
            let mut startupinfo = STARTUPINFO ();
            startupinfo.hStdError = self._stderr:.opipe ():.getHandle ();
            startupinfo.hStdOutput = self._stdout:.opipe ():.getHandle ();
            startupinfo.hStdInput = self._stdin:.ipipe ():.getHandle ();
            startupinfo.dwFlags = 256;
            
            let mut piProcInfo = PROCESS_INFORMATION ();
            
            CreateProcessA (null, stream[].ptr, null, null, 1, 0, null, self.cwd.ptr, &startupinfo, &piProcInfo);
            self._processHandle = piProcInfo.hProcess;
            
            self._stdin:.ipipe ():.dispose ();
            self._stdout:.opipe ():.dispose ();
            self._stderr:.opipe ():.dispose ();
        }

        pub def stdin (mut self) -> dmut &OPipe {
            alias self._stdin:.opipe ()
        }
        
        pub def stdout (mut self)-> dmut &IPipe {
            alias (self._stdout:.ipipe ())
        }

        pub def stderr (mut self)-> dmut &IPipe  {
            alias (self._stderr:.ipipe ())
        }

        pub def isFinished (self)-> bool {
            let mut status = 0i32;

            
            GetExitCodeProcess (self._processHandle, &status);
            if (status == 259) return false;

            return true;            
        }
        
        pub def wait (mut self)-> i32 {
            let mut status = 0i32;
            self._stdin:.dispose ();
            
            WaitForSingleObject (self._processHandle, -1);
            GetExitCodeProcess (self._processHandle, &status);
            CloseHandle (self._processHandle);
            self._processHandle = null;
            
            return status;
        }

        impl Disposable {

            pub over dispose (mut self) {
                self._stdin:.dispose ();
                self._stdout:.dispose ();
                self._stderr:.dispose ();
            }
            
        }
        
    }
    
}
