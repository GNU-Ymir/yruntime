mod std::concurrency::pipe;

import core::typeinfo, core::array;
import core::dispose;
import etc::runtime::thread;
import etc::c::stdio;
import etc::c::files;

import std::io;
import std::any;

import std::concurrency::sync;
import std::stream;
import std::collection::vec;

mod IOThreadPipe {T} {

    __version LINUX {
        pub extern (C) def _yrt_read_pipe (stream : i32, size : usize)-> T;
        
        pub extern (C) def _yrt_write_pipe (stream : i32, data : T, size : usize);
    }

    __version WINDOWS {
        pub extern (C) def _yrt_read_pipe (stream : &void, size : usize)-> T;
        
        pub extern (C) def _yrt_write_pipe (stream : &void, data : T, size : usize);
    }

    
    
}

/**
 * A pipe is a way to communicate between threads
 * It is assumed that pipes are used in shared memory context, and are only used to send references to class
 * If you want to send other types, of data, such as ints, bool etc. you can encapsulate the data into a Any type, or an Option
 * @example: 
 * =================
 * class Foo {
 *    let x : i32;
 *    pub self (i : i32) with x = i {}
 *    impl Streamable;
 * }
 *
 * // Thread 1 : 
 * pipe.write (Foo::new ());
 *
 * // Thread 2
 * println (pipe.read!(&Foo) ());
 * =================
 * @warning: 
 * ===============
 * ThreadPipes are blocking, meaning that before writing inside the pipe we assure that someone is reading on the other side 
 * If you want to speak between thread without synchronization, use a IOPipe
 * ===============
 */
pub class @final ThreadPipe {
    
    __version LINUX {
        /** The read side of the pipe */
        let mut _read : i32 = 0;
        
        /** The write side of the pipe */
        let mut _write : i32 = 0;
    }

    __version WINDOWS {
        
        let mut _read : &void = null;

        let mut _write : &void = null;
        
    }

    let mut _mutex = Mutex::new ();
    
    let mut _cond = Condition::new ();
    
    let mut _sem = Semaphore::new ();
    
    pub self () with self (true) {}

    pub self (create : bool) {
        if (create) {
            __version WINDOWS {
                let (read, write) = create_pipes ();
                self._read = read;
                self._write = write;
            } else {
                let mut pipes : [mut i32 ; 2u64] = [0 ; 2u64];
                pipe (alias (pipes).ptr);
                self._read = pipes [0];
                self._write = pipes [1];
            }
        }
    }
    
    /**
     * Get the reference of a object, that has been written in the pipe
     * @warning: it is a blocking process, the thread will wait until something is read
     */
    pub def read {class T} (self) -> T {                        
        self._mutex.lock ();
        self._sem.post ();
        self._cond.wait (self._mutex);
        let ret = IOThreadPipe!{T}::_yrt_read_pipe (self._read, sizeof T);                    
        self._mutex.unlock ();
        ret
    }

    /**
     * Write a reference to a object in the pipe to be read by another thread
     * @warning: it is a blocking process, the thread will wait until a thread has read the written data
     */
    pub def write {class T} (self, x : T) {            
        self._sem.wait ();
        self._mutex.lock ();        
        IOThreadPipe!(T)::_yrt_write_pipe (self._write, x, sizeof T);
        self._cond.signal (); 
        self._mutex.unlock ();
    }

    /**
     * Get the reference of an any type in the pipe
     * @warning: it is a blocking process, the thread will wait until someone is reading
     */
    pub def read (self) -> &Any {
        self.read!(&Any) ()
    }

    /**
     * Write the reference of an any type in the pipe
     * @warning: it is a blocking process, the thread will wait until someone is reading
     */
    pub def write {T} (self, x : T) -> void {
        self.write!{&Some!T} (Some!{T}::new (x))
    }    
    

    impl Disposable {
        /**
         * Close the bidirectional pipe
         */
        pub over dispose (mut self) {
            __version LINUX {
                if (self._read != 0) {
                    close (self._read);
                    self._read = 0;
                }
                
                if (self._write != 0) {
                    close (self._write);
                    self._write = 0;
                }
            }

            __version WINDOWS {
                if (self._read !is null) {
                    CloseHandle (self._read);
                    self._read = null;
                }
                
                if (self._write !is null) {
                    CloseHandle (self._write);
                    self._write = null;
                }
            }
        }
    }


    impl Streamable {
        pub over toStream (self, dmut stream : &StringStream) {
            stream:.write ("("s8):.write (self._read):.write (", "s8):.write (self._write):.write (")"s8);
        }
    }

    
    __dtor (mut self) {
        self:.dispose ();
    }
    
}

__version LINUX {

    /**
     * Single way pipe to write data to a IPipe (or another process)
     */
    pub class @final OPipe {


        let mut _pipe : i32;
        
        pub self (pipe : i32) with _pipe = pipe
        {}

        pub def write (mut self, msg : [c8]) {
            write (self._pipe, msg.ptr, msg.len);
        }
        
        pub def getHandle (self)-> i32 {
            self._pipe
        }

        pub def setNonBlocking (mut self) {
            let err_flags = fcntl(self._pipe, FileFlags::F_GETFL, 0u32);
            fcntl(self._pipe, FileFlags::F_SETFL, err_flags | O_NONBLOCK);
        }    

        impl Disposable {

            pub over dispose (mut self) {     
                if (self._pipe != 0) {
                    close (self._pipe);
                    self._pipe = 0;
                }
            }
            
        }
        
        __dtor (mut self) {
            self:.dispose ();
        }
    }


    /**
     * Single way pipe to read from a OPipe, or another process
     */
    pub class @final IPipe {

        let mut _pipe : i32;
        
        pub self (pipe : i32) with _pipe = pipe
        {}
        

        pub def read (mut self) -> [c8] {
            let dmut ret = Vec!(c8)::new ();
            loop {
                let mut c = '\u{0}'c8;
                let n = read (self._pipe, alias &c, sizeof c8);
                if (n != -1 && n != 0) {
                    ret:.push (c);
                } else break {}
            }
            ret:.fit ();
            return ret [];
        }

        pub def readSome (mut self, len : u32 = 1u32)-> [c8] {
            let dmut buf = ['\u{0}'c8 ; new len];
            let n = read (self._pipe, alias buf.ptr, (sizeof c8 * buf.len));
            if (n != 0) {
                return buf[0is .. n];
            }

            return [];
        }
        

        pub def getHandle (self)-> i32 {
            self._pipe
        }
        
        pub def setNonBlocking (mut self) {
            let err_flags = fcntl(self._pipe, FileFlags::F_GETFL, 0u32);
            fcntl(self._pipe, FileFlags::F_SETFL, err_flags | O_NONBLOCK);
        }

        
        impl Disposable {
            pub over dispose (mut self) {
                if (self._pipe != 0) {
                    close (self._pipe);
                    self._pipe = 0;
                }
            }
        }
        
        __dtor (mut self) {
            self:.dispose ();
        }
        
    }
    

    pub class @final IOPipe {
        let dmut _read : &IPipe = IPipe::new (0);
        
        let dmut _write : &OPipe = OPipe::new (0);
        
        pub self () with self (createPipes ()) {}
        
        pub self (pipes : [i32 ; 2u32])
            with _read = IPipe::new (pipes [0]), _write = OPipe::new (pipes [1])
        {}

        pub def opipe (mut self)-> dmut &OPipe {
            alias self._write
        }

        pub def ipipe (mut self)-> dmut &IPipe {
            alias self._read
        }

        impl Disposable {
            pub over dispose (mut self) {
                self._read:.dispose ();
                self._write:.dispose ();
            }
        }        
    }

    prv def createPipes ()-> [i32; 2u32] {
        let dmut ret = [0i32; 2u32];
        etc::c::files::pipe (alias (ret).ptr);
        return ret;
    }

}


__version WINDOWS {

    pub class OPipe {
        let mut _pipe : &void;

        pub self (pipe : &void) with _pipe = pipe
        {}
        
        pub def write (mut self, msg : [c8]) {
            WriteFile (self._pipe, msg.ptr, cast!i32 (msg.len), null, null);
        }

        pub def setNonBlocking (self) {
            if (SetHandleInformation (self._pipe, 1, 0) != 1) {
                __pragma!panic ();
            }
        }

        pub def getHandle (mut self) -> &void {
            self._pipe
        }
        
        impl Disposable {

            pub over dispose (mut self) {
                if (self._pipe !is null) {
                    CloseHandle (self._pipe);
                    self._pipe = null;
                }
            }
            
        }
        
        __dtor (mut self) {
            self:.dispose ();
        }
    }


    pub class IPipe {

        let mut _pipe : &void;

        pub self (pipe : &void) with _pipe = pipe
        {}

        
        pub def setNonBlocking (self) {
            if (SetHandleInformation (self._pipe, 1, 0) != 1) {
                __pragma!panic ();
            }
        }

        pub def getHandle (mut self) -> &void {
            self._pipe
        }
        
        pub def read (mut self)-> [c8] {
            let dmut res = Vec!{c8}::new ();
            loop {
                let mut c = '\u{0}'c8;

                let mut n = 0i32;
                ReadFile (self._pipe, alias &c, cast!i32 (sizeof c8), alias &n, null);
                if (n != -1 && n != 0) {
                    res:.push (c);
                } else break {}
            }

            res:.fit ();
            return res[];
        }

        pub def readSome (mut self, len : u32 = 1u32)-> [c8] {
            let dmut buf = ['\u{0}'c8 ; new len];
            let mut n = 0i32;
            ReadFile (self._pipe, alias buf.ptr, cast!i32 (sizeof c8 * buf.len), alias &n, null);

            if (n != -1 && n != 0) {
                return buf[0 .. n];
            }

            return [];
        }        

        impl Disposable {
            pub over dispose (mut self) {
                if (self._pipe !is null) {
                    CloseHandle (self._pipe);
                    self._pipe = null;
                }
            }
        }

        __dtor (mut self) {
            self:.dispose ();
        }    
    }


    pub class IOPipe {

        let dmut _ipipe : &IPipe;

        let dmut _opipe : &OPipe;

        pub self () with self (createPipes ()) {}

        pub self (pipes : (&void, &void)) with _ipipe = IPipe::new (pipes.0), _opipe = OPipe::new (pipes.1)
        {}


        pub def opipe (mut self)-> dmut &OPipe {
            alias self._opipe
        }

        pub def ipipe (mut self)-> dmut &IPipe {
            alias self._ipipe
        }

        impl Disposable {
            pub over dispose (mut self) {
                self._ipipe:.dispose ();
                self._opipe:.dispose ();
            }
        }
        
    }

    struct
    | nLength : u64 = cast!u64 (sizeof (SECURITY_ATTRIBUTES))
    | lpSecurityDescriptor : &void = null
    | bInheritHandle : i32 = 1
     -> SECURITY_ATTRIBUTES;
    
    extern (C) def CreatePipe (mut readP : &(mut &void), mut writeP : &(mut &void), saAttr : &SECURITY_ATTRIBUTES, ig : i32)-> i32;
    extern (C) def SetHandleInformation (pipe : &void, flag : i32, ig : i32)-> i32;

    def createPipes () -> (&void, &void) {
        let mut writeP : &void = null;
        let mut readP : &void = null;

        let mut saAttr = SECURITY_ATTRIBUTES ();
        
        if (CreatePipe (alias &readP, alias &writeP, &saAttr, 0) != 1) {
            __pragma!panic ();
        }
        
        (readP, writeP)
    }
    
}
