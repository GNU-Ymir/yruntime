mod std::collection::mutable::set;

import core::typeinfo;
import core::duplication;
import core::exception;
import core::array, core::object;

import std::collection::seq;
import std::collection::vec;
import std::io, std::stream;
import std::hash;
import std::conv;

/**
 * The number of allocated node in the table of a HashSet
 */
prv enum : usize
| DEFAULT_ALLOC_SIZE = 10us
 -> SetConst;


/**
 * A hash set implementation that stores a list of uniq values
 * The data in the set are unordered
 * @drawbacks 
 * ============
 * The value contained in the hash set are considered equivalent if their hash is equivalent
 * Depending on the hash function, there may be more or less collisions
 * ============
 * 
 * @example : 
 * =============
 * let dmut x = HashSet!([c32], i32)::new ();
 * x:.insert ("foo");
 * x:.insert ("foo");
 * x:.insert ("bar");
 * assert (x.len () == 2us);
 * =============
 */
pub class @final HashSet {T of dmut Z, class Z} {

    /**
     * Assertion to avoid tones of error printing, if the key is not usable
     */
    cte assert (__pragma!compile ({hash!T;}) || __pragma!compile ({hash (T::init)}), "unusable element type : (" ~ T ~ ") must be hashable");

    let dmut _data : [dmut &SetNode!{dmut T}] = [];

    let mut _loaded : usize = 0us;

    let mut _size : usize = 0us;

    let _load_factor = 75us;

    let _min_load_factor = 50us;

    /// Allocated only once to optimize memory usage
    let dmut _empty : dmut &SetNode!{dmut T} = Empty!{dmut T}::new ();

    /**
     * Create a new empty set, with a default loaded factor of 0.75, and minimum load factor of 0.5
     * Does not allocate memory until first insertion
     */
    pub self () {}
    
    /**
     * Create a new empty hash set, with a default allocated table of size len
     * @params:
     *    - len: the size of the table reserved to avoid growing
     */
    pub self (len : usize) {
        let dmut aux = core::duplication::allocArray!{&SetNode!{dmut T}} (len);

        for i in 0us .. aux.len {
            aux [i] = alias self._empty;
        }
        
        self._data = alias aux;
    }
    
    /**
     * Insert a new element inside the set
     * If the element was already in the set, does nothing
     * @params:
     *    - val: the value to insert
     * @complexity: O (1 + n/k + z) with n the number of possible collision, and k the number of elements in the set, and z the time taken by resizing if the load is higher than the load factor, in average n/k and z are negligeable
     * @example: 
     * ============
     * let dmut x = HashSet!([c32])::new ();
     * x:.insert ("foo");
     * x:.insert ("bar");
     * x:.insert ("foo");
     * assert (x.len () == 2us);
     * ============
     */
    pub def insert (mut self, dmut val : T) -> void {
        if (self._data.len == 0us) { self:.grow (); }
        else if ((self._loaded * 100us) / (self._data.len) > self._load_factor) { self:.grow (); }
        
        let h = cast!usize (hash (val));
        self:.insertFast (h, alias val);
    }

    /**
     * Search the value in the set
     * @returns: true if the value is in the set, false otherwise
     * @example: 
     * ============
     * let dmut x = HashSet!([c32])::new ();
     * x:.insert ("foo");
     * assert ("foo" in x);
     * assert ("bar" !in x);
     * ============
     * @complexity: O (1 + n/k), with n the number of possible collision and k the number of elements in the set, in average n/k are negligeable
     */
    pub def opContains (self, val : T) -> bool {
        if (self._data.len != 0us) {
            let h = cast!usize (hash (val));        
            match (self._data [h % self._data.len]) {
                x : &SetValue!{dmut T} =>
                    return x.opContains (h);
            }
        }
        false                   
    }     


    /**
     * Remove an element from the set
     * If the value was no present, does nothing
     * @params: 
     *    - val: the value to remove
     * @example:
     * ==========
     * let dmut x = HashSet!([c32])::new ();
     * x:.insert ("foo");
     * x:.remove ("foo");
     * x:.remove ("bar");
     * assert (x.len () == 0);
     * ==========
     * @complexity: O (1 + n/k), with n the number of possible collision and k the number of elements in the set, in average n/k are negligeable
     */
    pub def remove (mut self, val : T) -> void {
        if self._data.len != 0us {
            let h = cast!usize (hash (val));
            match ref (self._data [h % self._data.len]) {
                dmut x : &SetValue!{dmut T} => {
                    let mut removed = false;
                    self._data [h % self._data.len] = alias x:.remove (h, ref removed);
                    match self._data [h % self._data.len] {
                        _: &Empty!{dmut T} => {
                            self._loaded -= 1us;
                        }
                    }
                    if (removed) { self._size -= 1us; }
                }                
            }
            if ((self._loaded * 100us) / self._data.len < self._min_load_factor) { self:.shrink (); }
        }
    }

    /**
     * Remove all the elements contained in the set
     * @example: 
     * ===========
     * let dmut x = HashSet!([c32])::new ();
     * x:.insert ("foo");
     * x:.insert ("bar");
     * x:.insert ("baz");
     * assert (x.len () == 3us);
     * x:.clear ();
     * assert (x.len () == 0us);
     * ===========
     * @complexity: O (1)
     */
    pub def clear (mut self) {
        self._data = [];
        self._loaded = 0us;
        self._size = 0us;
    }

    /**
     * Iteration over the set can be done with set iterators
     * This iterators implement the ymir interface for iteration with one or two variable (next, get!0, get!1)
     * @example: 
     * ============
     * let dmut x = HashSet!([c32])::new ();
     * x:.insert ("foo");
     * x:.insert ("bar");
     * for v in x {
     *     println (v);
     * }    
     * ============
     * @return: an iterator on the beginning of the set
     */

    pub def begin (self) -> dmut &SetIterator!{dmut T} {
        if (self._loaded != 0us) {
            for i in 0us .. self._data.len {
                match self._data [i] {
                    _ : &SetValue!{dmut T} =>
                        return SetIterator!{dmut T}::new (i, 0us, self._data, self._data [i]);
                }
            }
        }
        
        SetIterator!{dmut T}::new (0us, 0us, [], self._empty)  
    }

    /**
     * @returns: the iterator on the end of the set
     */
    pub def end (self) -> &SetIterator!{dmut T} {
        SetIterator!{dmut T}::new (0us, 0us, [], self._empty)
    }


    /**
     * @returns: a newly allocated array containing the value of the set
     */
    pub def opIndex (mut self)-> dmut [T] {
        let dmut res : [T] = core::duplication::allocArray!{dmut T} (self._size);
        let mut j = 0us;
        for i in 0us .. self._data.len {
            let dmut inner = alias (alias (alias self._data)[i])[];
            for z in 0us .. inner.len {
                res [j] = alias inner [z];
                j += 1us;
            }
        }

        alias res
    }

    /**
     * @returns: the number of element in the set
     */
    pub def len (self)-> usize {
        self._size
    }
    
    /**
     * @returns: a newly allocated array containing the value of the set
     */
    pub def opIndex (self)-> mut [mut T] {
        let mut res : [mut T] = core::duplication::allocArray!{dmut T} (self._size);
        let mut j = 0us;
        for i in self {
            res [j] = i;
            j += 1us;
        }
        alias res
    }
    
    impl Streamable {


        pub over toStream (self, dmut stream : &StringStream) {
            stream:.write ('{'c8);
            let mut i = 0us;
            for node in self._data {
                match node {
                    _ : &SetValue!{dmut T} => {
                        if (i != 0us) { stream:.write (", "s8); }
                        stream:.write (node);
                        i = 1us;
                    }
                }
            }
            stream:.write ('}'c8);
        }
        
    }

    cte if is!T {U impl Copiable} {
        impl core::duplication::Copiable {

            /**
             * Hash set are copiable
             * Because internal values of hash set are immutable, they are not copied
             * The copy is only applied on the structure of the set
             * @example: 
             * =============
             * let x = hset#{"foo", "bar"};
             * let dmut y = dcopy x;
             * y:.insert ("baz");
             * println (x); // {bar, foo}
             * println (y); // {baz, bar, foo}
             * =============
             */
            pub over deepCopy (self)-> dmut &Object {
                let dmut res = HashSet!{dmut T}::new (self._data.len);
                
                // Add all the values 
                for i in 0us .. self._data.len {
                    let dmut current = self._data [i];
                    loop {
                        match ref current {
                            dmut x : &SetValue!{dmut T} => {
                                res:.insertFast (x.h, dcopy x.val);
                                current = alias x.next;
                            }
                            _ => {
                                break {}
                            }
                        }
                    }
                }
                
                alias cast!{&Object} (res)
            }
            
        }
    }
    

    /**
     * Insert an element in the hash set, without making the table grow 
     * @assume: the table is able to contain the value to insert
     * @params: 
     *    - h: the hash of the value
     *    - val: the value to insert
     */
    prv def insertFast (mut self, h : usize, dmut val : T) {
        let mut inserted = false;
        match ref (self._data [h % self._data.len]) {
            dmut x : &SetValue!{dmut T} => {
                inserted = x:.insert (h, alias val);
            }
            _ => {
                self._data [h % self._data.len] = SetValue!{dmut T}::new (h, alias val, alias self._empty);
                self._loaded += 1us;
                inserted = true;
            }
        }
        if (inserted) {
            self._size += 1us;
        }
    }

    /**
     * Make the table containing the value shrink
     * @complexity: O (n + m), with n the new size, and m the number of element contained in the old table and reinserted
     */
    prv def shrink (mut self) -> void {
        if (self._loaded == 0us) {
            self._data = [];
            return {}
        }

        let n_len = self._data.len / 2us;
        let dmut aux = core::duplication::allocArray!{&SetNode!{dmut T}} (n_len);

        for i in 0us .. aux.len {
            aux [i] = alias self._empty;
        }

        let dmut old = alias self._data;
        self._data = alias aux;
        self._loaded = 0us;
        self._size = 0us;

        for i in 0us .. old.len {
            let dmut current = alias old [i];
            loop {
                match ref current {
                    dmut x : &SetValue!{dmut T} => {
                        self:.insertFast (x.h, alias x.val);
                        current = alias x.next;
                    }
                    _ => {
                        break {}
                    }
                }
            }
        }        
    }

    /**
     * Make the table containing the values grow
     * This function is called when the _load_factor is reached
     * If the table was empty it is allocated with a size of SetConst::DEFAULT_ALLOC_SIZE,
     * otherwise the size is mutliplied by 2
     * @complexity: O (n + m), with n the new size, and m the number of element contained in the old table that are reinserted
     */
    prv def grow (mut self) -> void {
        if (self._data.len == 0us) {
            self._data = core::duplication::allocArray!{&SetNode!{dmut T}} (SetConst::DEFAULT_ALLOC_SIZE);
            for i in 0us .. self._data.len {
                self._data [i] = alias self._empty;
            }
        } else {
            let n_len = self._data.len * 2us;
            let dmut aux = core::duplication::allocArray!{&SetNode!{dmut T}} (n_len);
            // Filling the data with empty elements, to be usable, allocArray is not safe!?
            for i in 0us .. aux.len {
                aux [i] = alias self._empty;
            }
            
            // Clear the set
            let dmut old = alias self._data;
            self._data = alias aux;
            self._loaded = 0us;
            self._size = 0us;

            // Add all the old values 
            for i in 0us .. old.len {
                let dmut current = alias old [i];
                loop {
                    match ref current {
                        dmut x : &SetValue!{dmut T} => {
                            self:.insertFast (x.h, alias x.val);
                            current = alias x.next;
                        }
                        _ => {
                            break {}
                        }
                    }
                }
            }
        }
    }
    
    
}


/**
 * Each index of a table of a hash set is a linked list
 * This list is composed of SetNode(s)
 */
class @abstract SetNode {T of dmut Z, class Z} {
    prot self () {}

    pub def opEquals (self, _ : &SetNode!{dmut T}) -> bool;

    pub def opIndex (mut self)-> dmut [T] {
        return [];
    }
    
    impl Streamable;
}

/**
 * An actual node of the list that contains a value
 * @example: 
 * ===========
 * let list = SetValue!(i32)::new (hash (12), 12, SetValue!(i32)::new (hash(42), 42, Empty!(i32)::new ()));
 * ===========
 */
class @final SetValue {T of dmut Z, class Z} over SetNode!{dmut T} {

    // The reference to the next element of the list
    pub let dmut next : &SetNode!{dmut T};

    // The hash of the value contained in the list
    pub let h : usize;

    // The value contained in the list
    pub let dmut val : T;

    /**
     * @params: 
     *    - h: == hash (val)
     *    - val: the value to store
     *    - next: the reference to the next element of the list
     */
    pub self (h : usize, dmut val : T, dmut next : &SetNode!{dmut T})
        with next = alias next, h = h, val = alias val
    {}

    pub over opIndex (mut self)-> dmut [T] {
        let dmut current : &SetNode!{dmut T} = alias self;
        let dmut res = Vec!{dmut T}::new ();
        
        loop {
            match ref current {
                dmut x : &SetValue!{dmut T} => {
                    res:.push (alias x.val);
                    current = alias x.next;
                }
                _ => { break {} }
            }
        }
        
        return (alias res)[];
    }

    impl Streamable {


        pub over toStream (self, dmut stream : &StringStream) {
            cte if (__pragma!compile ({stream:.write (self.val);})) {
                stream:.write (self.val);
            } else { stream:.write (T::typeid); }
            
            match self.next {
                _ : &Empty!{dmut T} => {}
                _ => { stream:.write (", "s8):.write (self.next); }
            }
        }
    }

    /**
     * Insert a new element in the list if it does not already exists
     * @params: 
     *    - h: == hash (val)
     *    - val: the value to insert
     * @complexity: O (n), with n the length of the list
     * @returns: true if a new node has been allocated, false otherwise
     */
    pub def insert (mut self, h : usize, dmut val : T) -> bool {
        if (self.h != h) {
            match ref self.next {
                dmut x : &SetValue!{dmut T} => {
                    return x:.insert (h, alias val);
                }
                _ => {
                    self.next = SetValue::new (h, alias val, alias self.next);
                    return true;
                }
            }
        }
        false                
    }

    /**
     * Remove the key inside the list, if there is no node containing the value, just return the list as it was
     * @info: the returned list is not a copy, no allocation are made
     * @complexity: O (n), with n the length of the list
     * @returns: 
     *    - rm: true if a node has been removed, false otherwise
     *    - the list, with no node containing the hash h
     */
    pub def remove (mut self, h : usize, ref mut rm : bool) -> dmut &SetNode!{dmut T} {
        if (self.h == h) {
            rm = true;
            return alias self.next;
        } else {
            match ref self.next {
                dmut x : &SetValue!{dmut T} => {
                    self.next = alias x:.remove (h, ref rm);
                }
            }
            return alias self;
        }
    }

    /**
     * Search a node whose hash key is h in the linked list
     * @returns: true if such node exists, false otherwise
     * @complexity: O (n), with n the length of the list
     */
    pub def opContains (self, h : usize) -> bool {
        if (self.h == h) {
            true
        } else {
            match (self.next) {
                x : &SetValue!{dmut T} => {
                    return x.opContains (h);
                }
            }
            false
        }
    }

    /**
     * Compare two nodes
     * @returns: true if o is SetValue and o.h == self.h, false otherwise
     */
    pub over opEquals (self, o : &SetNode!{dmut T}) -> bool {
        match o {
            x : &SetValue!{dmut T} => {
                return x.h == self.h;
            }
        }
        false
    }
    
}


/**
 * An empty node that encode the end of a linked list in a set
 */
class @final Empty {T of dmut Z, class Z} over SetNode!{dmut T} {
    pub self () { }

    impl Streamable {

        /**
         * Does nothing
         */
        pub over toStream (self, dmut _ : &StringStream) {}
    }

    /**
     * Compare two nodes
     * @returns: true if o is Empty!T
     */
    pub over opEquals (self, o : &SetNode!{dmut T}) -> bool {
        match o {
            _ : &Empty!{dmut T} =>
                return true;
        }
        return false;
    }
    
}


/**
 * The set iterator class is used to traverse a set
 * It can be acquired in a hash set with the methods begin () and end ()
 * @example: 
 * ===========
 * let x = hset#{"foo"};
 * let dmut beg_it = x.begin ();
 * assert (beg_it.get!0 == "foo");
 * 
 * beg_it:.next ();
 * assert (beg_it == x.end ());
 * ===========
 */
class @final SetIterator {T of dmut Z, class Z} {

    let mut _data : [&SetNode!{dmut T}];

        /// The current index of the iterator, in the table
    let mut _index : usize;

    /// The current index in the current branch (linked list of SetValues)
    let mut _branch : usize = 0us;

    /// The reference on node containing the value we are pointing at
    let mut _currentNode : &SetNode!{dmut T};

    /**
     * An iterator is always constructed to point somewhere, or must point to (0, 0, [], empty)
     * @params: 
     *    - i: the index in the table of this iterator
     *    - branch: the index in the branch at iterator i
     *    - data: the table of data
     *    - current: the current traversed node in the branch (data [i][branch])
     */
    pub self (i : usize, branch : usize, data : [&SetNode!{dmut T}], current : &SetNode!{dmut T})
        with _data = data,
             _index = i,
             _branch = branch,
             _currentNode = current
    {}        

    /**
     * Two iterators are equals, if the current nodes are equals
     */
    pub def opEquals (self, o : &SetIterator!{dmut T}) -> bool {
        self._currentNode == o._currentNode
    }

    /**
     * @returns: 
     * =======
     * the value of the current node, in an option type
     * None, it the current node is empty
     * =======     
     */
    pub def get {0} (self) -> T {
        match (self._currentNode) {
            x : &SetValue!{dmut T} =>
                return x.val;
        }
        
        __pragma!panic ();
    }

    /**
     * Create a new iterator that point to the next value contained in the set
     * If there is no more value, the returned iterator is equals to set.end ()
     * @example: 
     * ===========
     * let dmut x = HashSet!([c32])::new ();
     * x:.insert ("foo");
     * x:.insert ("bar");
     * let dmut it = alias x.begin ();
     * let end = x.end (); // put in a var to avoid multiple useless calls and allocations
     * while (it != end) {
     *    println (it.get!0);
     *    it:.next ();
     * }
     * ===========
     */
    pub def next (mut self) -> void {
        match (self._currentNode) {
            x : &SetValue!{dmut T} => {
                match (x.next) {
                    _ : &SetValue!{dmut T} => {
                        self._branch += 1us;
                        self._currentNode = x.next;
                        return {}
                    }
                }
            }
        }            

        if (self._index + 1us < self._data.len) {
            for j in (self._index + 1us).. self._data.len {
                match (self._data [j]) {
                    _ : &SetValue!{dmut T} => {
                        self._branch = 0us;
                        self._index = j;
                        self._currentNode = self._data [j];
                        return {};
                    }
                }
            }
        }

        self._data = [];
        self._currentNode = Empty!{dmut T}::new ();
        self._index = 0us;
        self._branch = 0us;
    }

    
}
