/**
 * This modules defines functions with `cte` values that can be used
 * to simplify template specialization. This module has nothing to do
 * with the `trait` semantic, so maybe we should rename it.
 *
 * @Authors: Emile Cadorel
 * @License: GPLv3
 * <hr>
 * @example:
 * ===
 * use std::traits;
 *
 * /*
 *   This function accept every integral type for T (u8 to usize, and i8 to isize)
 * */
 * fn if isIntegral!{T} foo {T} (a : T)-> T {
 *     a + cast!T (12)
 * }
 *
 * let a = foo ();
 *
 * cte if isFloating!{typeof (a)} {
 *     println ("a is either a f32 or a f64");
 * } else {
 *     println ("a is something else");
 * }
 * ===
 */
in traits;

/**
 * @CTE
 * @value: true iif T is floating pointer number
 */
pub def isFloating {T} = cte (is!{T} {U of f32} ||
                              is!{T} {U of f64} ||
                              is!{T}{U of f80} ||
                              is!{T}{U of fsize});

/**
 * @CTE
 * @value: true iif T is an integer (signed or unsigned) false otherwise
 */
pub def isIntegral {T} = cte (isSigned!{T} || isUnsigned!{T});

/**
 * @CTE
 * @value: true iif T is a signed integer
 */
pub def isSigned {T} = cte (is!{T}{U of i8} ||
                           is!{T}{U of i16} ||
                           is!{T}{U of i32} ||
                           is!{T}{U of i64} ||
                           is!{T}{U of isize});

/**
 * @CTE
 * @value: true iif T is a unsigned integer
 */
pub def isUnsigned {T} = cte (is!{T}{U of u8} ||
                              is!{T}{U of u16} ||
                              is!{T}{U of u32} ||
                              is!{T}{U of u64} ||
                              is!{T}{U of usize});

/**
 * @CTE
 * @value: true iif T is a char type
 */
pub def isChar {T} = cte (is!{T}{U of c8} || is!{T}{U of c32} || is!{T}{U of c16});


/**
 * @CTE
 * @value: true iif T is a slice type containig char values
 * */
pub def isString {T of [U], U} = isChar!{U};

/**
 * @CTE
 * @value: false
 * */
pub def isString {T} = false;

/**
 * @CTE
 * @value: true
 */
pub def isTuple{T of (U,), U...} = true;

/**
 * @CTE
 * @value: true
 */
pub def isTuple{T of ()} = true;

/**
 * @CTE
 * @value: false
 */
pub def isTuple {T} = false;

/**
 * @CTE
 * Is a scalar type
 * */
pub def isScalar {T} = cte (isIntegral!{T} || isFloating!{T} || isChar!{T} || is!{T}{U of bool});

/**
 * @CTE
 * @value: true iif the type 'T' has a public field named 'name'
 * @warning: does not work for method marked as fields
 * */
pub def hasField {record T, name : [c8]} = cte __pragma!compile (__pragma!field_type (T, name));

/**
 * @CTE
 * @value: true iif the type 'T' has a public field named 'name'
 * @warning: does not work for method marked as fields
 * */
pub def hasField {entity T, name : [c8]} = cte __pragma!compile (__pragma!field_type (T, name));

/**
 * @CTE
 * @value: true iif the type 'T' has a public field named 'name'
 * @warning: does not work for method marked as fields
 * */
pub def hasField {class T, name : [c8]} = cte __pragma!compile (__pragma!field_type (T, name));
