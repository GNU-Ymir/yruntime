mod std::concurrency::actor;
import std::io, std::concurrency::message;
import std::any;
import core::typeinfo, core::duplication;


/**
 * Lib pthread, create a thread
 */
extern (C) def pthread_create (mut thread : &(mut usize), attr : &void, call : fn (mut Actor)-> void, mut data : Actor);

/**
 * Wait the end of a thread
 */
extern (C) def pthread_join (thread : usize, attr : &void);


/**
 * Class and pointer have the same size, so there is no problem for pthread
 * And the class will be ok to run
 */
def threadFunc (mut actor : Actor) -> void {
    (alias actor).run ();
}

pub class Actor {

    let mut _id = 0us;

    let mut _pipe = Pipe::new ();
    
    self () {}

    /**
     * The things to do in the thread
     */
    def run (mut self)-> void {}

    def send (T) (mut self, x : T) {
        let value = Some!(T)::new (x);       
        (alias self._pipe).write (value);
    }

    def recv (mut self)-> Any {
        (alias self._pipe).read!(Any)()
    }
    
    /**
     * Spawn a new actor, in a thread
     */
    def spawn (mut self) {
        pthread_create (alias (&self._id), null, &threadFunc, alias self);
    }

    def join (self) {
        pthread_join (self._id, null);
    }
    
}
