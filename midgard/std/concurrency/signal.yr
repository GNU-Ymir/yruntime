/**
 * This module implements the Signal class. Signal class is a list of function or closure pointers that are called when the signal is emitted.
 * This is really useful when using event system, with elements triggered by other elements without caring to much about side effects.
 * Connected functions can be called asynchronusely using futures when emitting the signal. All created future can be awaited by the signal emit method.
 * @authors: Emile Cadorel
 * @license: GPLv3
 * <hr>
 * @example:
 * ===
 * import std::io;
 * import std::concurrency::signal;
 *
 * fn foo (x : i32, y : i32) {
 *     println ("Foo called with ", x, " ", y);
 * }
 *
 * let mut sig = Signal!{i32, i32} ();
 *
 * // Connecting the foo function to the signal
 * sig:.connect (&foo);

 * let i = 42;
 * sig:.connect (copy |x, y| => {
 *     println ("Lambda called : ", x, " ", y, " ", i);
 * });
 *
 * // Call all the slots connected to the signal
 * sig.emit (1, 2);
 *
 * // disconnect a connected slot
 * sig:.disconnect (&foo);
 * ===
 */
in signal;

pub record Signal {T...} {

    // List of connected function pointers
    let dmut _foos : [dg (T)-> void] = [];

    /**
     * Create an empty signal connected to nothing
     * */
    pub self () {}

    /**
     * Connect a function to the signal
     * @params:
     *    - f: the function to connect
     * @info: does not reconnect the function if already found
     * @complexity: O (self.len), with self.len the number of already connected function
     */
    pub fn connect (mut self, f : dg (T)-> void) {
        let mut found = false;
        for i in self._foos {
            if (i == f) {
                found = true;
                break;
            }
        }

        if !found {
            self._foos ~= [f];
        }
    }

    /**
     * Disconnect a function from the signal
     * @params:
     *    - f: the function to disconnect
     * @info: does nothing if the function was not connected
     * @complexity: O (self.len), with self.len the number of already connected function
     * * */
    pub fn disconnect (mut self, f : dg (T)-> void) {
        for i in 0us .. self._foos.len {
            if (self._foos [i] == f) {
                self._foos = self._foos [0 .. i] ~ self._foos [i + 1 .. $];
                return;
            }
        }
    }

    /**
     * Emit the signal (calling all the connected functions).
     * @info: run the functions in the current threads with no guarantee on calling order.
     * @params:
     *    - values: the list of parameters to pass to the connected functions.
     * */
    pub fn emit (self, values : T) {
        for i in self._foos {
            i (expand values);
        }
    }

    /**
     * @returns: the number of functions connected to the signal
     * */
    @field
    pub fn len (self)-> usize {
        self._foos.len
    }

}
