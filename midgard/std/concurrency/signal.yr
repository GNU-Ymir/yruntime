/**
 * This module implements the Signal class. Signal class is a list of function or closure pointers that are called when the signal is emitted.
 * This is really useful when using event system, with elements triggered by other elements without caring to much about side effects.
 * Connected functions can be called asynchronusely using futures when emitting the signal. All created future can be awaited by the signal emit method.
 * @authors: Emile Cadorel
 * @license: GPLv3
 * <hr>
 * @example:
 * ===
 * use std::io;
 * use std::concurrency::signal;
 *
 * fn foo (x : i32, y : i32) {
 *     println ("Foo called with ", x, " ", y);
 * }
 *
 * let mut sig = Signal!{i32, i32} ();
 *
 * // Connecting the foo function to the signal
 * sig:.connect (&foo);

 * let i = 42;
 * sig:.connect (copy |x, y| => {
 *     println ("Lambda called : ", x, " ", y, " ", i);
 * });
 *
 * // Call all the slots connected to the signal
 * sig.emit (1, 2);
 *
 * // disconnect a connected slot
 * sig:.disconnect (&foo);
 * ===
 */
in signal;

pub record Signal {T...} {

    // List of connected function pointers
    let dmut _foos : [(dg (T)-> void) => ()] = copy [];

    /**
     * Create an empty signal connected to nothing
     * */
    pub self () {}

    /**
     * Connect a function to the signal
     * @params:
     *    - f: the function to connect
     * @info: does not reconnect the function if already found
     * @complexity: O (1)
     */
    pub fn connect (mut self, f : dg (T)-> void) {
        self._foos [f] = ();
    }

    /**
     * Disconnect a function from the signal
     * @params:
     *    - f: the function to disconnect
     * @info: does nothing if the function was not connected
     * @complexity: O (1)
     * * */
    pub fn disconnect (mut self, f : dg (T)-> void) {
        self._foos:.remove (f);
    }


    /**
     * Emit the signal (calling all the connected functions).
     * @info: run the functions in the current threads with no guarantee on calling order.
     * @params:
     *    - values: the list of parameters to pass to the connected functions.
     * */
    pub fn emit (self, values : T) {
        for f, _ in self._foos {
            f (expand values);
        }
    }

    /**
     * @returns: the number of functions connected to the signal
     * */
    @field
    pub fn len (self)-> usize {
        self._foos.len
    }

}
