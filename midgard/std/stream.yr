in stream;

use std::collection::set;

mod Runtime {F, T} {
    pub extern (C) fn _yrt_unsafe_cast (x : F)-> dmut T;
}

prv enum : usize
| DEFAULT_ALLOC_SIZE = 10us
 -> StreamConst;


lazy dmut __PRINT_SET__ = copy HashSet!{*void} ();

pub trait Streamable {

    /**
     * Print the content of the class on stdout
     * @returns: true if something has been printed, false otherwise
     */
    prot fn __stream__streamContent (self, dmut stream : &StringStream) -> bool {
        stream;
        cte if (__pragma!compile ({self::super.__stream__streamContent (alias stream);})) {
            let printed = self::super.__stream__streamContent (alias stream);
            cte if (typeof (self)::field_infos.len != 0u32 && printed) {
                stream:.write (", "s8);
            }
        }

        cte for i in 0 .. typeof (self)::field_infos.len {
            cte if (i != 0) stream:.write (", ");
            let name = cte {typeof (self)::field_infos [i].name};
            cte if (__pragma!compile ({stream:.write (__pragma!field (self, name));})) {
                stream:.write (".", name, " = ", __pragma!field (self, name));
            } else {
                stream:.write (".", name, " : ", (typeof (__pragma!field (self, name)))::typeid);
            }
        }

        return cte (typeof (self)::field_infos.len != 0);
    }

    /**
     * Print the class name and content into the stream.
     * This default implementation prints the typename followed by the value of the fields between parentheses. If a recursive field is detected only `(...)` is written for the field values.
     * @params:
     *     - stream: the stream in which the class instance will be written
     */
    pub fn toStream (self, dmut stream : &StringStream)-> void {
        let vd = Runtime!{typeof (self), *void}::_yrt_unsafe_cast (self);
        stream:.write (typeof (self)::typeid, "(");
        if vd !in __PRINT_SET__ {
            __PRINT_SET__:.insert (vd);
            self.__stream__streamContent (alias stream);
            __PRINT_SET__:.remove (vd);
        } else {
            stream:.write ("...");
        }

        stream:.write (")");
    }

}


@final
pub class StringStream {

    // The content of the stream
    let dmut _content : [c8] = [];

    // The actual size of the stream
    let mut _len : usize = 0us;

    // The list of string used to entab
    let mut _entabing : [mut [c8]] = [];

    // The actual size of the entabing
    let mut _entabingLen : usize = 0us;

    let mut _willEntab = false;

    /**
     * Create an empty stringstream
     */
    pub self () {}

    /*!
     * ====================================================================
     * ====================================================================
     * ==========================   ENTABING  =============================
     * ====================================================================
     * ====================================================================
     * */

    /**
     * Stores a list of entabing string, and write them at the beginning of each new line.
     * @params:
     *    - txt: the text to write at the beginning of every new line.
     * @example:
     * ==================
     * let dmut str = copy StringStream ();
     *
     * str:.write ("Array {\n");
     * str:.entabing (); // write "\t" at the beginning of new line from now on
     * for i in 0 .. 10 {
     *     str:.write (i, "\n"); // writes \t i \n
     * }
     *
     * str:.detabing ();
     * str:.write ("}");
     * ==================
     */
    pub fn entabing (mut self, txt : [c8] = "\t"s8) {
        if (self._entabing.len == self._entabingLen) {
            self:.growEntabing ();
        }

        self._entabing [self._entabingLen] = txt;
        self._entabingLen += 1us;
    }

    /**
     * Stop the current entabing (if there is any, does nothing otherwise).
     */
    pub fn detabing (mut self) {
        if (self._entabingLen != 0us) {
            self._entabingLen -= 1us;

            if (self._entabingLen < self._entabing.len / 2us) {
                self:.fitEntabing ();
            }
        }
    }

    /*!
     * ==========================================================================
     * ==========================================================================
     * =============================   WRITE STRINGS  ===========================
     * ==========================================================================
     * ==========================================================================
     * */

    /**
     * Write a c8 into the stream.
     * @params:
     *     - c: the c8 to append at the end of the stream.
     */
    pub fn write (mut self, c : c8) -> dmut &StringStream {
        self:.push (c);
        if (c == '\n'c8) {
            self._willEntab = true;
        }

        alias self
    }

    /**
     * Write a string in utf8 into the stream.
     * @params:
     *     - c: the string to append at the end of the stream.
     */
    pub fn write {T of [U], U of c8} (mut self, c : T) -> dmut &StringStream {
        self:.push (c);
        alias self
    }

    /**
     * Write a string in utf32 at the end of the stream.
     * @params:
     *     - c: an utf32 string
     */
    pub fn write {T of [U], U of c32} (mut self, c : T) -> dmut &StringStream {
        alias self:.write (c.to![c8] ())
    }

    /**
     * Write a element in the stream
     * @info: the element must be convertible to a [c8] using `std::conv` module.
     * @params:
     *    - c: the element to write that is neither a struct nor a class
     */
    pub fn if (!is!{T}{record R} && !is!{T}{class C} && !is!{T}{entity E}) write {T} (mut self, c : T) -> dmut &StringStream {
        self:.write (std::conv::to!{[c8]} (c));
        alias self
    }

    /**
     * Write a pointer in the stream.
     * @params:
     *    - c: the pointer whose address to write in the stream.
     * @example:
     * ===
     * let j = 123;
     * let i = &j;
     *
     * let dmut stream = copy StringStream ();
     *
     * // Every pointer can be casted to *void, but it has to be written explicitely
     * stream:.write (cast!{*void} (i));
     * ===
     */
    pub fn write (mut self, c : *(void))-> dmut &StringStream {
        let val = Runtime!{*void, usize}::_yrt_unsafe_cast (c);
        self:.write (std::conv::to!{[c8], "x"} (val));
        alias self
    }

    /*!
     * ====================================================================
     * ====================================================================
     * ==========================   CLASSES  ==============================
     * ====================================================================
     * ====================================================================
     * */

    pub fn if (is!{T}{class C} || is!{T}{record C}) write {T} (mut self, c : T) -> dmut &StringStream {
        cte if is!{T}{X impl std::stream::Streamable} {
            c.toStream (alias self);
        } else {
            self:.write (T::typeid, '(');
            for i, j in (expand c,) {
                cte if (i != 0) self:.write (", ");
                self:.write (j);
            }
            self:.write (')');
        }

        alias self
    }

    pub fn if (is!{T}{class C} || is!{T}{record C}) write {T} (mut self, ref c : T) -> dmut &StringStream {
        cte if is!{T}{X impl std::stream::Streamable} {
            c.toStream (alias self);
        } else {
            self:.write (T::typeid, '(');
            for i, j in (expand c,) {
                cte if (i != 0) self:.write (", ");
                self:.write (j);
            }
            self:.write (')');
        }

        alias self
    }

    /*!
     * =================================================================================
     * =================================================================================
     * ==========================   SLICES AND VARIADICS  ==============================
     * =================================================================================
     * =================================================================================
     * */

    /**
     * Write a slice into the stream.
     * @params:
     *    - c: a slice of anything (that is streamable)
     */
    pub fn write {T of [U], U} (mut self, c : T) -> dmut &StringStream {
        let mut j = 0us;
        self:.write ('[');
        for i in c {
            if (j != 0us) {
                self:.write (", "s8);
            }
            j += 1us;
            self:.write (i);
        }
        self:.write (']');
        alias self
    }

    /**
     * Write multiple element into the stream.
     */
    pub fn write {F, T...} (mut self, f : F, r : T) -> dmut &StringStream {
        self:.write (f);
        cte if (is!T {Z of (U,), U...}) {
            for i in r
                self:.write (i);
        } else {
            self:.write (r);
        }
        alias self
    }

    /**
     * Write multiple element into the stream, and add a line return afterwards.
     */
    pub fn writeln {F, T...} (mut self, f : F, r : T) -> dmut &StringStream {
        self:.write (f);
        cte if (is!T {Z of (U,), U...}) {
            for i in r
                self:.write (i);
        } else {
            self:.write (r);
        }
        self:.write ("\n");
        alias self
    }

    /**
     * Write an element in the stream and add a line return afterwards.
     */
    pub fn writeln {F} (mut self, f : F)-> dmut &StringStream {
        self:.write (f);
        self:.write ("\n");
        alias self
    }

    /**
     * Append a line return at the end of the stream.
     */
    pub fn writeln (mut self)-> dmut &StringStream {
        self:.write ("\n");
        alias self
    }

    /**
     * Write a tuple into the stream.
     * @params:
     *    - a: a tuple of streamable values.
     */
    pub fn write {T of (U,), U...} (mut self, a : T) -> dmut &StringStream {
        self:.write ('('c8);
        let mut j = 0;
        for i in a {
            if j != 0 {
                self:.write (','c8);
            }
            self:.write (i);
            j += 1;
        }
        if (j == 1) self:.write (','c8);
        self:.write (')'c8);
        alias self
    }

    /**
     * Write an option type into the stream.
     * @params:
     *     - a: an option of a streamable value.
     */
    pub fn write {T} (mut self, a : T?) -> dmut &StringStream {
        match a {
            Ok  (x:_)   => self:.write ("Ok("s8, x, ')'c8);
            Err (msg:_) => self:.write ("Err("s8, msg, ')'c8);
            Err ()      => self:.write ("Err()"s8);
        }
        alias self
    }

    /*!
     * ====================================================================
     * ====================================================================
     * ==========================   INDEXING  ==============================
     * ====================================================================
     * ====================================================================
     * */


    /**
     * @returns: the content of the stream, in a utf8 string.
     * @complexity: O(1)
     */
    pub fn opIndex (self) -> [c8] {
        self._content [0 .. self._len]
    }

    /**
     * Clear the content of the stream.
     * @example:
     * ===
     *
     * let dmut stream = copy StringStream ();
     * stream:.write ("Some content");
     * stream:.clear ();
     *
     * assert (stream[] == ""s8);
     * ===
     */
    pub fn clear (mut self) {
        self._content = [];
        self._len = 0us;
        self._entabing = [];
        self._entabingLen = 0us;
        self._willEntab = false;
    }

    impl std::stream::Streamable {

        /**
         * Write the content of the stream inside another stream.
         */
        pub over toStream (self, dmut stream: &StringStream) {
            stream:.write (self._content [0 .. self._len]);
        }

    }

    /*!
     * ====================================================================
     * ====================================================================
     * ==========================   PRIVATE  ==============================
     * ====================================================================
     * ====================================================================
     * */

    prv fn push (mut self, i : c8) {
        if self._willEntab {
            for j in self._entabing [0 .. self._entabingLen] {
                if (self._content.len <= self._len + j.len) {
                    self:.grow (self._len + j.len);
                }

                self:.pushFast (j);
            }

            self._willEntab = false;
        }

        if (self._content.len <= self._len + 1) { self:.grow ((self._len + 1us)); }
        self:.pushFast (i);
        if (i == '\n') self._willEntab = true;
    }

    prv fn push (mut self, i : [c8]) {
        if (self._entabingLen == 0us) {
            if (self._content.len <= self._len + i.len) { self:.grow (self._len + i.len); }
            self:.pushFast (i);
        } else {
            for z in i {
                self:.push (z);
            }
        }
    }

    prv fn pushFast (mut self, i : [c8]) {
        for z in i {
            self._content [self._len] = z;
            self._len += 1us;
        }

        self._willEntab = (i.len != 0 && i [$ - 1] == '\n');
    }

    prv fn pushFast (mut self, i : c8) {
        self._content [self._len] = i;
        self._len += 1us;
    }

    prv fn grow (mut self, nlen : usize) {
        if (self._content.len == 0us) {
            self._content = alias core::duplication::allocArray!c8 (nlen);
        } else {
            let dmut aux : [c8] = core::duplication::allocArray!c8 (nlen);
            core::duplication::memCopy!c8 (self._content, alias aux);
            self._content = alias aux;
        }
    }

    prv fn fit (mut self) {
        let dmut aux : [c8] = core::duplication::allocArray!c8 (self._len);
        core::duplication::memCopy!c8 (self._content, alias aux);
        self._content = alias aux;
    }

    prv fn growEntabing (mut self) {
        if (self._entabing.len == 0us) {
            self._entabing = alias core::duplication::allocArray![c8] (1us);
        } else {
            let nlen = (self._entabing.len * 2us);
            let mut aux : [mut [c8]] = core::duplication::allocArray![c8] (nlen);
            core::duplication::memCopy![c8] (self._entabing, alias aux);
            self._entabing = alias aux;
        }
    }

    prv fn fitEntabing (mut self) {
        let mut aux : [mut [c8]] = core::duplication::allocArray![c8] (self._len);
        core::duplication::memCopy![c8] (self._entabing, alias aux);
        self._entabing = alias aux;
    }

}
