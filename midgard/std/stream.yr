in stream;

prv enum : usize
| DEFAULT_ALLOC_SIZE = 16us
| DEFAULT_ENTABING_SIZE = 1us
 -> StreamConst;

/**
 * The print set stores the list of classes that are already printed, to avoid infinite loops when a class contains itself
 */
lazy mut __PRINT_SET__ : [*void => mut ()] = [];

/**
 * Trait used to perform a complex stream writing of classes or records
 * Default implementation exists, and allows to print private fields
 * */
pub trait Streamable {

    /**
     * Print the content of the class on stdout
     * @returns: true if something has been printed, false otherwise
     */
    prot fn __stream__streamContent (self, dmut stream : &StringStream) -> bool {
        stream;
        cte if (__pragma!compile ({self::super.__stream__streamContent (alias stream);})) {
            let printed = self::super.__stream__streamContent (alias stream);
            cte if (typeof (self)::field_infos.len != 0u32 && printed) {
                stream:.write (", "s8);
            }
        }

        cte for i in 0 .. typeof (self)::field_infos.len {
            cte if (i != 0) stream:.write (", ");
            let name = cte {typeof (self)::field_infos [i].name};
            cte if (__pragma!compile ({stream:.write (__pragma!field (self, name));})) {
                stream:.write (__pragma!field (self, name));
            } else {
                stream:.write (".", name, " : ", (typeof (__pragma!field (self, name)))::typeid);
            }
        }

        return cte (typeof (self)::field_infos.len != 0);
    }

    /**
     * Print the class name and content into the stream.
     * This default implementation prints the typename followed by the value of the fields between parentheses. If a recursive field is detected only `(...)` is written for the field values.
     * @params:
     *     - stream: the stream in which the class instance will be written
     */
    pub fn toStream (self, dmut stream : &StringStream)-> void {
        cte if is!{typeof (self)}{class E} {
            let vd = etc::runtime::memory::Runtime!{typeof (self), *void}::_yrt_unsafe_cast (self);
            stream:.write (self.__typeid__, "(");
            if let Err () = __PRINT_SET__ [vd]? {
                __PRINT_SET__ [vd] = ();
                self.__stream__streamContent (alias stream);
                __PRINT_SET__:.remove (vd);
            } else {
                stream:.write ("...");
            }

            stream:.write (")");
        } else {
            stream:.write (self.__typeid__, "(");
            self.__stream__streamContent (alias stream);
        }
    }

}


@final
pub class StringStream {

    // The content of the stream
    let dmut _content : [c8] = [];

    // The list of string used to entab
    let mut _entabing : [mut [c8]] = [];

    // The actual size of the entabing
    let mut _entabingLen : usize = 0us;

    // Toggle when reading a \n char, to trigger the writing of entabing strings at next write
    let mut _willEntab = false;

    /**
     * Create an empty stringstream
     */
    pub self () {}

    /*!
     * ====================================================================
     * ====================================================================
     * ==========================   ENTABING  =============================
     * ====================================================================
     * ====================================================================
     * */

    /**
     * Stores a list of entabing string, and write them at the beginning of each new line.
     * @params:
     *    - txt: the text to write at the beginning of every new line.
     * @example:
     * ==================
     * let dmut str = copy StringStream ();
     *
     * str:.write ("Array {\n");
     * str:.entabing (); // write "\t" at the beginning of new line from now on
     * for i in 0 .. 10 {
     *     str:.write (i, "\n"); // writes \t i \n
     * }
     *
     * str:.detabing ();
     * str:.write ("}");
     * ==================
     */
    pub fn entabing (mut self, txt : [c8] = "\t"s8) {
        if (self._entabing.len == self._entabingLen) {
            self:.growEntabing ();
        }

        self._entabing [self._entabingLen] = txt;
        self._entabingLen += 1us;
    }

    /**
     * Stop the current entabing (if there is any, does nothing otherwise).
     */
    pub fn detabing (mut self) {
        if (self._entabingLen != 0us) {
            self._entabingLen -= 1us;

            if (self._entabingLen < self._entabing.len / 2us) {
                self:.fitEntabing ();
            }
        }
    }

    /*!
     * ==========================================================================
     * ==========================================================================
     * =============================   WRITE STRINGS  ===========================
     * ==========================================================================
     * ==========================================================================
     * */

    /**
     * Write a c8 into the stream.
     * @params:
     *     - c: the c8 to append at the end of the stream.
     */
    pub fn write (mut self, c : c8) -> dmut &StringStream {
        self:.push (c);
        alias self
    }

    /**
     * Write a string in utf8 into the stream.
     * @params:
     *     - c: the string to append at the end of the stream.
     */
    pub fn write {T of [U], U of c8} (mut self, c : T) -> dmut &StringStream {
        self:.push (c);
        alias self
    }

    /**
     * Write a string in utf32 at the end of the stream.
     * @params:
     *     - c: an utf32 string
     */
    pub fn write {T of [U], U of c32} (mut self, c : T) -> dmut &StringStream {
        alias self:.write (c.to![c8] ())
    }

    /**
     * Write any type at the end of the string
     * @params:
     *   - c: the value to write
     * */
    pub fn if (!is!{T}{class C} && !is!{T}{record C} && !is!{T}{entity E}) write {T} (mut self, c : T) -> dmut &StringStream {
        self:.write (std::conv::to!{[c8]} (c))
    }

    /**
     * Write a pointer in the stream.
     * @params:
     *    - c: the pointer whose address to write in the stream.
     * @example:
     * ===
     * let j = 123;
     * let i = &j;
     *
     * let dmut stream = copy StringStream ();
     *
     * // Every pointer can be casted to *void, but it has to be written explicitely
     * stream:.write (cast!{*void} (i));
     * ===
     */
    pub fn write (mut self, c : *(void))-> dmut &StringStream {
        let val = etc::runtime::memory::Runtime!{*void, usize}::_yrt_unsafe_cast (c);
        self:.write (std::conv::to!{[c8], "x"} (val));
        alias self
    }

    /*!
     * ================================================================================
     * ================================================================================
     * ==========================   CLASSES and RECORDS  ==============================
     * ================================================================================
     * ================================================================================
     * */

    /**
     * Write a class or a record into the stream
     * @params:
     *   - c: the element to write
     * @info: consider weither the element is Streamable or not
     * @returns: the stream
     * */
    pub fn if (is!{T}{class C} || is!{T}{record C}) write {T} (mut self, c : T) -> dmut &StringStream {
        cte if is!{T}{X impl std::stream::Streamable} {
            c.toStream (alias self);
        } else {
            cte if is!{T}{class C} {
                let vd = etc::runtime::memory::Runtime!{typeof (self), *void}::_yrt_unsafe_cast (self);
                self:.write (c.__typeinfo.name, '(');
                if vd !in __PRINT_SET__ {
                    __PRINT_SET__ [vd] = ();
                    for i, j in (expand c,) {
                        cte if (i != 0) self:.write (", ");
                        self:.write (j);
                    }
                    __PRINT_SET__:.remove (vd);
                } else {
                    self:.write ("...");
                }

                self:.write (')');
            } else {
                self:.write (T::typeid, '(');
                for i, j in (expand c,) {
                    cte if (i != 0) self:.write (", ");
                    self:.write (j);
                }
                self:.write (')');
            }
        }

        alias self
    }

    /**
     * Write a record into the stream as a reference (to avoid the copy of the record)
     * @params:
     *   - c: the element to write
     * @info: consider weither the element is Streamable or not
     * @returns: the stream
     * */
    pub fn if (is!{T}{record R} || is!{T}{entity E}) write {T} (mut self, ref c : T) -> dmut &StringStream {
        cte if is!{T}{X impl std::stream::Streamable} {
            c.toStream (alias self);
        } else {
            self:.write (T::typeid, '(');
            for i, j in (expand c,) {
                cte if (i != 0) self:.write (", ");
                self:.write (j);
            }
            self:.write (')');
        }

        alias self
    }

    /*!
     * =================================================================================
     * =================================================================================
     * ==========================   SLICES AND VARIADICS  ==============================
     * =================================================================================
     * =================================================================================
     * */

    /**
     * Write a slice into the stream.
     * @params:
     *    - c: a slice of anything (that is streamable)
     */
    pub fn write {T of [U], U} (mut self, c : T) -> dmut &StringStream {
        let mut j = 0us;
        self:.write ('[');
        for i in c {
            if (j != 0us) {
                self:.write (", "s8);
            }
            j += 1us;
            self:.write (i);
        }
        self:.write (']');
        alias self
    }

    /**
     * Write multiple element into the stream.
     */
    pub fn write {F, T...} (mut self, f : F, r : T) -> dmut &StringStream {
        self:.write (f);
        cte if (is!T {Z of (U,), U...}) {
            for i in r
                self:.write (i);
        } else {
            self:.write (r);
        }
        alias self
    }

    /**
     * Write multiple element into the stream, and add a line return afterwards.
     */
    pub fn writeln {F, T...} (mut self, f : F, r : T) -> dmut &StringStream {
        self:.write (f);
        cte if (is!T {Z of (U,), U...}) {
            for i in r
                self:.write (i);
        } else {
            self:.write (r);
        }
        self:.write ("\n");
        alias self
    }

    /**
     * Write an element in the stream and add a line return afterwards.
     */
    pub fn writeln {F} (mut self, f : F)-> dmut &StringStream {
        self:.write (f);
        self:.write ("\n");
        alias self
    }

    /**
     * Append a line return at the end of the stream.
     */
    pub fn writeln (mut self)-> dmut &StringStream {
        self:.write ("\n");
        alias self
    }

    /**
     * Write a tuple into the stream.
     * @params:
     *    - a: a tuple of streamable values.
     */
    pub fn write {T of (U,), U...} (mut self, a : T) -> dmut &StringStream {
        self:.write ('('c8);
        let mut j = 0;
        for i in a {
            if j != 0 {
                self:.write (','c8);
            }
            self:.write (i);
            j += 1;
        }
        if (j == 1) self:.write (','c8);
        self:.write (')'c8);
        alias self
    }

    /**
     * Write an option type into the stream.
     * @params:
     *     - a: an option of a streamable value.
     */
    pub fn write {T} (mut self, a : T?) -> dmut &StringStream {
        match a {
            Ok  (x:_)   => self:.write ("Ok("s8, x, ')'c8);
            Err (msg:_) => self:.write ("Err("s8, msg, ')'c8);
            Err ()      => self:.write ("Err()"s8);
        }
        alias self
    }

    /*!
     * ====================================================================
     * ====================================================================
     * ==========================   INDEXING  ==============================
     * ====================================================================
     * ====================================================================
     * */

    /**
     * @returns: the content of the stream, in a utf8 string.
     * @complexity: O(1)
     */
    pub fn opIndex (self) -> [c8] {
        self._content [0 .. $]
    }

    /**
     * @returns: the content of the stream, in a utf8 string.
     * @complexity: O(1)
     */
    pub fn opIndex (mut self) -> dmut [c8] {
        alias self._content [0 .. $]
    }

    /**
     * Clear the content of the stream.
     * @example:
     * ===
     *
     * let dmut stream = copy StringStream ();
     * stream:.write ("Some content");
     * stream:.clear ();
     *
     * assert (stream[] == ""s8);
     * ===
     */
    pub fn clear (mut self) {
        self._content = [];
        self._entabing = [];
        self._entabingLen = 0us;
        self._willEntab = false;
    }

    impl std::stream::Streamable {

        /**
         * Write the content of the stream inside another stream.
         */
        pub over toStream (self, dmut stream: &StringStream) {
            stream:.write (self._content [0 .. $]);
        }

    }

    /*!
     * ====================================================================
     * ====================================================================
     * ==========================   PRIVATE  ==============================
     * ====================================================================
     * ====================================================================
     * */

    /**
     * Write a char at the end of the stream
     * @params:
     *    - c: the char to write
     * */
    prv fn push (mut self, c : c8) {
        if self._willEntab {
            for j in self._entabing [0 .. self._entabingLen] {
                self._content ~= j;
            }

            self._willEntab = false;
        }

        self._content ~= [c];
        self._willEntab = (c == '\n');
    }

    /**
     * Write a string at the end of the stream
     * @params:
     *    - s: the string to write
     * */
    prv fn push (mut self, s : [c8]) {
        if (self._entabingLen == 0us) {
            self._content ~= s;
            self._willEntab = (s.len != 0 && s [$ - 1] == '\n');
        } else {
            for z in s {
                self:.push (z);
            }
        }
    }

    /**
     * Grow the entabing buffer to accept at least one new element
     * */
    prv fn growEntabing (mut self) {
        if (self._entabing.len == 0us) {
            self._entabing = alias core::types::array::allocArray![c8] (StreamConst::DEFAULT_ENTABING_SIZE);
        } else {
            let nlen = std::algorithm::comparison::max (self._entabing.len * 2us, StreamConst::DEFAULT_ENTABING_SIZE);
            let mut aux : [mut [c8]] = core::types::array::allocArray![c8] (nlen);
            core::types::array::memCopy![c8] (self._entabing, alias aux);
            self._entabing = alias aux;
        }
    }

    /**
     * Fit the entabing buffer to take exactly the required amount of space
     * */
    prv fn fitEntabing (mut self) {
        if (self._entabingLen == 0us) {
            self._entabing = [];
        } else {
            let mut aux : [mut [c8]] = core::types::array::allocArray![c8] (self._entabingLen);
            core::types::array::memCopy![c8] (self._entabing, alias aux);
            self._entabing = alias aux;
        }
    }

}
