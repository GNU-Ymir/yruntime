in implem;

mod iteration;
mod nodes;


use std::collection::list::iteration;
use std::collection::list::nodes;

@abstract
pub class IList {T, mutable : bool} {

    let dmut _head : (&ListNode!{T, mutable})? = none;

    let dmut _tail : (&ListNode!{T, mutable})? = none;

    let mut _len : usize = 0us;

    /**
     * Create an empty list
     * @example:
     * ===========
     * let x = List!(i32)::new ();
     *
     * assert (x.isEmpty ());
     * ===========
     */
    pub self () {}

    prv self (dmut head : (&ListNode!{T, mutable})?, dmut tail : (&ListNode!{T, mutable})?, len : usize)
        with _head = alias head
        , _tail = alias tail
        , _len = len
    {}


    cte if mutable {
        /**
         * Push an element at the end of the list
         * @params:
         *    - val: the element to append
         * @example:
         * ============
         * let dmut x = List!(i32)::new ();
         * x:.push (1);
         * x:.push (1);
         * assert (x.len () == 2);
         * ============
         * @complexity: O (1)
         */
        pub fn push (mut self, dmut val : T)-> void {
            if let Ok (dmut tail) = alias self._tail {
                let dmut n_node = (copy ListNode!{T, mutable} (alias val, alias self._tail, alias tail.next))?;
                tail.next = alias n_node;
                self._tail = alias n_node;
            } else {
                self._head = (copy ListNode!{T, mutable} (alias val, alias self._tail, alias self._head))?;
                self._tail = alias self._head;
            }

            self._len += 1us;
        }

        /**
         * Push an element at the beginning of the list
         * @params:
         *    - val: the value to push
         * @example:
         * ==============
         * let dmut x = List!(i32)::new ();
         * x:.pushFront (1);
         * assert (x.len () == 1us);
         * ==============
         * @complexity: O (1)
         */
        pub fn pushFront (mut self, dmut val : T) -> void {
            if let Ok (dmut head) = alias self._head {
                let dmut n_node = (copy ListNode!{T, mutable} (alias val, alias head.prev, alias self._head))?;
                head.prev = alias n_node;
                self._head = alias n_node;
            } else {
                self._head = (copy ListNode!{T, mutable} (alias val, alias self._tail, alias self._head))?;
                self._tail = alias self._head;
            }

            self._len += 1us;
        }

    } else {
        /**
         * Push an element at the end of the list
         * @params:
         *    - val: the element to append
         * @example:
         * ============
         * let dmut x = List!(i32)::new ();
         * x:.push (1);
         * x:.push (1);
         * assert (x.len () == 2);
         * ============
         * @complexity: O (1)
         */
        pub fn push (mut self, val : T)-> void {
            if let Ok (dmut tail) = alias self._tail {
                let dmut n_node = (copy ListNode!{T, mutable} (val, alias self._tail, alias tail.next))?;
                tail.next = alias n_node;
                self._tail = alias n_node;
            } else {
                self._head = (copy ListNode!{T, mutable} (val, alias self._tail, alias self._head))?;
                self._tail = alias self._head;
            }

            self._len += 1us;
        }

        /**
         * Push an element at the beginning of the list
         * @params:
         *    - val: the value to push
         * @example:
         * ==============
         * let dmut x = List!(i32)::new ();
         * x:.pushFront (1);
         * assert (x.len () == 1us);
         * ==============
         * @complexity: O (1)
         */
        pub fn pushFront (mut self, val : T) -> void {
            if let Ok (dmut head) = alias self._head {
                let dmut n_node = (copy ListNode!{T, mutable} (val, alias head.prev, alias self._head))?;
                head.prev = alias n_node;
                self._head = alias n_node;
            } else {
                self._head = (copy ListNode!{T, mutable} (val, alias self._tail, alias self._head))?;
                self._tail = alias self._head;
            }

            self._len += 1us;
        }
    }

    cte if mutable {
        /**
         * Pop the last element of the list and return it
         * @throws:
         *    - &OutOfArray: if the list is empty
         * @example:
         * =============
         * let dmut x = List!(i32)::new ();
         * x:.push (1);
         * {
         *    assert (x:.pop () == 1);
         * } catch (
         *    _ : &OutOfArray =>
         *        println ("List was empty");
         *    _ : &AssertError =>
         *        println ("Last value of list was not 1");
         * }
         * =============
         * @complexity: O (1)
         */
        pub fn pop (mut self) -> dmut T
            throws core::exception::OutOfArray
        {
            if let Ok (dmut tail) = alias self._tail {
                let dmut ret = alias tail.value;
                if let Ok (dmut prev) = alias tail.prev {
                    prev.next = alias tail.next;
                    self._tail = (alias prev)?;
                } else {
                    self._head = alias tail.prev;
                    self._tail = alias self._head;
                }

                self._len -= 1us;
                return alias ret;
            } else {
                throw copy OutOfArray ();
            }
        }

        /**
         * Remove the first element of the list and return it
         * @throws:
         *    - &OutOfArray: if the list was empty
         * @example:
         * ============
         * let dmut x = List!(i32)::new ();
         * x:.push (12);
         * assert (x:.popFront () == 12);
         * ============
         * @complexity: O (1)
         */
        pub fn popFront (mut self) -> dmut T
            throws core::exception::OutOfArray
        {
            if let Ok (dmut head) = alias self._head {
                let dmut ret = alias head.value;
                if let Ok (dmut next) = alias head.next {
                    next.prev = alias head.prev;
                    self._head = (alias next)?;
                } else {
                    self._head = alias head.next;
                    self._tail = alias self._head;
                }

                self._len -= 1us;
                return alias ret;
            } else {
                throw copy OutOfArray ();
            }
        }

    } else {

        /**
         * Pop the last element of the list and return it
         * @throws:
         *    - &OutOfArray: if the list is empty
         * @example:
         * =============
         * let dmut x = List!(i32)::new ();
         * x:.push (1);
         * {
         *    assert (x:.pop () == 1);
         * } catch (
         *    _ : &OutOfArray =>
         *        println ("List was empty");
         *    _ : &AssertError =>
         *        println ("Last value of list was not 1");
         * }
         * =============
         * @complexity: O (1)
         */
        pub fn pop (mut self) -> T
            throws core::exception::OutOfArray
        {
            if let Ok (dmut tail) = alias self._tail {
                let ret = tail.value;
                if let Ok (dmut prev) = alias tail.prev {
                    prev.next = alias tail.next;
                    self._tail = (alias prev)?;
                } else {
                    self._head = alias tail.prev;
                    self._tail = alias self._head;
                }

                self._len -= 1us;
                return ret;
            } else {
                throw copy core::exception::OutOfArray ();
            }
        }

        /**
         * Remove the first element of the list and return it
         * @throws:
         *    - &OutOfArray: if the list was empty
         * @example:
         * ============
         * let dmut x = List!(i32)::new ();
         * x:.push (12);
         * assert (x:.popFront () == 12);
         * ============
         * @complexity: O (1)
         */
        pub fn popFront (mut self) -> T
            throws core::exception::OutOfArray
        {
            if let Ok (dmut head) = alias self._head {
                let ret = head.value;
                if let Ok (dmut next) = alias head.next {
                    next.prev = alias head.prev;
                    self._head = (alias next)?;
                } else {
                    self._head = alias head.next;
                    self._tail = alias self._head;
                }

                self._len -= 1us;
                return ret;
            } else {
                throw copy core::exception::OutOfArray ();
            }
        }
    }


    /**
     * @returns: true if the list is empty
     * @complexity: O (1)
     */
    pub fn isEmpty (self) -> bool {
        self._len == 0us
    }

    /**
     * Remove all the elements from the list
     * @complexity: O (1)
     */
    pub fn clear (mut self) -> void {
        self._head = none;
        self._tail = none;
    }

    cte if mutable {
        /**
         * @returns: the value of the first element contained in the list, None if the list is empty
         * @complexity: O (1)
         */
        pub fn front (mut self) -> dmut (T)? {
            if let Ok (ListNode!{T, true} (value-> dmut v)) = alias self._head {
                return (alias v)?;
            }

            none
        }

        /**
         * @returns: the value of the last element contained in the list, None if the list is empty
         * @complexity: O (1)
         */
        pub fn back (mut self) -> dmut (T)? {
            if let Ok (ListNode!{T, mutable} (value-> dmut v)) = alias self._tail {
                return (alias v)?;
            }

            none
        }

    }

    /**
     * @returns: the value of the first element contained in the list, None if the list is empty
     * @complexity: O (1)
     */
    pub fn front (self) -> (T)? {
        if let Ok (ListNode!{T, mutable} (value-> v)) = self._head {
            return (v)?;
        }

        none
    }

    /**
     * @returns: the value of the last element contained in the list, None if the list is empty
     * @complexity: O (1)
     */
    pub fn back (self) -> (T)? {
        if let Ok (ListNode!{T, mutable} (value-> v)) = self._tail {
            return (v)?;
        }

        none
    }

    /**
     * This method is used to traverse the list with an iterator
     * @example:
     * ==========
     * let list = list#{1, 2, 3};
     * for v, index in list {
     *     println (v, " ", index);
     * }
     *
     * for v in list {
     *     println (v);
     * }
     * ==========
     * @complexity: O (1)
     */
    pub fn begin (self) -> ListIterator!{T, mutable} {
        ListIterator!{T, mutable} (0us, self._head)
    }

    /**
     * @returns: an iterator to the end of the list, used to stop the loop
     * @example:
     * ============
     * let x = list#{1, 2, 3};
     * let dmut beg_it = alias x.begin ();
     * while (beg_it != x.end ()) {
     *      println (beg_it.get!0);
     *      beg_it:.next ();
     * }
     * ============
     * @complexity: O (1)
     */
    pub fn end (self) -> usize {
        return self._len;
    }


    cte if __pragma!operator("==", T, T) {


        /**
         * @returns: true if self == o
         * @example:
         * ===
         * let l = list#{1, 2, 3};
         * let a = list#{8, 9, 10};
         * let b = list#{1, 2, 3};
         *
         * assert (l != a && l == b);
         * ===
         */
        pub fn opEquals (self, o : &IList!{T, mutable})-> bool {
            if (self._len != o._len) return false;

            let mut selfC = self._head, mut oC = o._head;
            loop {
                match (selfC, oC) {
                    (Ok (h), Ok (oh)) => {
                        if (h.value != oh.value) { return false; }
                        selfC = h.next;
                        oC = oh.next;
                    }
                    (Err (), Err ()) => { return true; }
                    _ => { break {} }
                }
            }

            false
        }
    }

    /**
     * Transform the list into a slice
     * @example:
     * ===
     * let l = list#{1, 2, 3};
     * assert (l[] == [1, 2, 3]);
     * ===
     * @complexity: O (n)
     */
    pub fn opIndex (self)-> mut [mut T] {
        let mut res : [mut T] = core::duplication::allocArray!{T} (self._len);
        for i, j in self {
            res [i] = j;
        }

        alias res
    }

}
