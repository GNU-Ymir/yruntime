in nodes;

/**
 * A map value is a linked list storing all the values with the same modulo hash
 * */
@final
pub class MapValue {K, V, innerMutable : bool} {

    cte assert (__pragma!operator ("==", K, K), "unusable key type : (" ~ K::typeid ~ ") must be be comparable to itself (opEquals or opCmp)");

    // The following node in the list
    pub let dmut next : (&MapValue!{K, V, innerMutable})?;

    // The hash of the key
    pub let h : u64;

    // The key stored in the node
    pub let key : K;

    // The value associated with the key
    cte if !innerMutable {
        pub let mut val : V;

        pub self (h : u64, key : K, val : V, dmut next : (&MapValue!{K, V, innerMutable})?)
            with next = alias next
            , key = key
            , val = val
            , h = h
        {}

        pub fn insert (mut self, key : K, val : V)-> bool {
            if (self.key == key) {
                self.val = val;
                false
            } else if let Ok (ref dmut n) = ref self.next {
                n:.insert (key, val)
            } else {
                self.next = (copy MapValue!{K, V, innerMutable} (self.h, key, val, none))?;
                true
            }
        }

    } else {
        pub let dmut val : V;

        pub self (h : u64, key : K, dmut val : V, dmut next : (&MapValue!{K, V, innerMutable})?)
            with next = alias next
            , key = key
            , val = alias val
            , h = h
        {}

        pub fn insert (mut self, key : K, dmut val : V)-> bool {
            if (self.key == key) {
                self.val = alias val;
                false
            } else if let Ok (ref dmut n) = ref self.next {
                n:.insert (key, alias val)
            } else {
                self.next = (copy MapValue!{K, V, innerMutable} (self.h, key, alias val, none))?;
                true
            }
        }

        pub fn find (mut self, key : K)-> dmut V? {
            if self.key == key {
                (alias self.val)?
            } else if let Ok (dmut n) = alias self.next {
                alias n:.find (key)
            } else {
                none
            }
        }
    }

    pub fn find (self, key : K)-> V? {
        if self.key == key {
            (self.val)?
        } else if let Ok (n) = self.next {
            n.find (key)
        } else {
            none
        }
    }

    pub fn remove (mut self, key : K, ref mut rm : bool)-> dmut (&MapValue!{K, V, innerMutable})? {
        if self.key == key {
            rm = true;
            return alias self.next;
        } else if let Ok (ref dmut n) = ref self.next {
            self.next = n:.remove (key, ref rm);
        }

        alias (self)?
    }

    pub fn opContains (self, key : K)-> bool {
        if (self.key == key) {
            true
        } else if let Ok (n) = self.next {
            n.opContains (key)
        } else {
            false
        }
    }


    impl std::hash::Hashable;

}
