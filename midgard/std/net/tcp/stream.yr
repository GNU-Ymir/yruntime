/**
 * This class implement a tcp stream used to send remote message
 * @Authors: Emile Cadorel
 * @Licence: GPLv3
 * <hr>
 * */

in stream;

use std::net::{addr, addr::_, tcp::errors};
use std::time::dur;

use etc::c::{files, socket, time};
use etc::runtime::errno;

use std::traits;

/**
 * A tcp stream is a tcp connection from a client to a server, or a server to a client.
 * It can be acquired directly by construction, or using a TcpListener when accepting clients.
 * @example:
 * ```
 * pub fn greets_client (dmut client : &TcpStream) {
 *    // Communicate with the client
 *    client:.send ("Hello !!"s8);
 * }
 *
 * let dmut server = copy TcpListener (SockAddr ("127.0.0.1", 8080));
 * loop {
 *    // Accept creates a TcpStream to a connected client
 *    let dmut client = server:.accept ();
 *    println ("New client connected : ", client);
 *    greets_client (client);
 *
 *    // Closing the connection to the client
 *    client:.dispose ();
 * }
 * ```
 *
 * A TcpStream is also used on the client side to connect to a tcp server.
 * @example:
 * ```
 * let dmut client = copy TcpStream (SockAddr ("127.0.0.1", 8080));
 * println ("Message from server : ", client:.rawReceive!{c8} (8us));
 *
 * // client is automatically closed when garbabe collected
 * // but it is recommanded to close it manually to avoid opening too many sockets
 * client:.dispose ();
 * ```
 */
@final
pub class TcpStream {

    // Set to true when the socket fails
    let mut _error : bool = false;

    // The file descriptor of the socket
    let mut _sockFd : i32 = 0;

    // The ip address to which the stream is connected
    let mut _addr : SockAddr;

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          CTORS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Create a tcp stream with an already opened socket (e.g. for tcp listener)
     * */
    pub self (sock : i32, addr : SockAddr)
        with _sockFd = sock
        , _addr = addr
    {}

    /**
     * Connect the stream to 'addr'
     * @example:
     * ```
     * use std::net::tcp;
     *
     * let addr = SockAddr (Ipv4::LOCALHOST, 8080);
     * let dmut client = copy TcpStream (addr);
     *
     * client:.rawSend ("Ping !");
     * client:.dispose ();
     * ```
     *
     * @params:
     *   - addr: the address to which to connect
     *   - timeout: the timeout of the connection
     * @throws:
     *    - TcpError: if the connection fails, or timeout
     * */
    pub self connect (addr : SockAddr, timeout : dur::Duration = dur::seconds (2))
        with _addr = addr
        throws errors::TcpError
    {
        if let SockAddr (ip-> ip : &Ipv6Addr, port-> p) = addr {
            self:.connectV6 (ip, p, timeout);
        }

        else if let SockAddr (ip-> ip : &Ipv4Addr, port-> p) = addr {
            self:.connectV4 (ip, p, timeout);
        }

        else {
            throw copy errors::TcpError (errors::TcpErrorCode::ADDR_TYPE, "unknown address type " ~ (addr.ip.__typeinfo__.name));
        }
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the address to which the stream is connected
     * */
    @field
    pub fn addr (self)-> SockAddr {
        self._addr
    }

    /**
     * @returns: the file descriptor of the socket
     * @warning: for low level management only
     * */
    pub fn getHandle (self)-> i32 {
        self._sockFd
    }

    /**
     * @returns: true iif the socket is still open
     * */
    pub fn isOpen (self)-> bool {
        self._sockFd != 0 && !self._error
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          SENDING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Send a raw bytes to the stream
     * @params:
     *    - val: the value to send
     * @throws:
     *    - TcpError: if the sending failed
     * */
    pub fn if isScalar!{T} send {T} (mut self, val : T)
        throws errors::TcpError
    {
        self:.innerSendRaw (cast!{*u8} (cast!{*void} (&val)), cast!u32 (T::size));
    }

    /**
     * Send raw bytes to the stream
     * @params:
     *    - val: the value to send
     * @throws:
     *    - TcpError: if the sending failed
     * */
    pub fn if isTuple!{T} send {T} (mut self, val : T)
        throws errors::TcpError
    {
        for i in val {
            self:.send (i);
        }
    }

    /**
     * Send a slice to the stream
     * @params:
     *    - val: the value to send
     * @throws:
     *    - TcpError: if the sending failed
     *
     * @info: Send the slice with metadatas to make it reconstructible on the other end without additional informations.
     * @example:
     * ```
     * // With serialization
     * stream:.send (copy [1, 2, 3, 4]);
     * client:.receive!{[i32]} () == [1, 2, 3, 4];
     * ```
     * */
    pub fn send {T of [U], U} (mut self, val : T)
        throws errors::TcpError
    {
        self:.send (val.len);
        for i in val {
            self:.send (i);
        }
    }

    /**
     * Send a slice to the stream
     * @params:
     *    - val: the value to send
     * @throws:
     *    - TcpError: if the sending failed
     *
     * @info: Send only the bytes of the slice without metadatas to make it reconstructible.
     * @example:
     * ```
     * // Without serialization
     * stream:.sendRaw (copy [1, 2, 3, 4]);
     *
     * let dmut result = copy [0 ; 4];
     * client:.receiveRaw (alias result); // raw receive of the data in the slice
     * ```
     * */
    pub fn if isScalar!{U} sendRaw {T of [U], U} (mut self, val : T)
        throws errors::TcpError
    {
        self:.innerSendRaw (cast!{*u8} (cast!{*void} (val.ptr)), cast!u32 (val.len));
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          RECEIVING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Receive a raw bytes to the stream
     * @returns: the received value
     * @throws:
     *    - TcpError: if the receiving failed
     * */
    pub fn if isScalar!{T} receive {T} (mut self)-> T
        throws errors::TcpError
    {
        let mut t : T = T::init;
        self:.innerReceiveRaw (cast!{*u8} (cast!{*void} (&t)), cast!u32 (T::size));
        t
    }

    /**
     * Receive raw bytes to the stream
     * @params:
     *    - val: the value to receive
     * @throws:
     *    - TcpError: if the receiveing failed
     * */
    pub fn if isTuple!{T} receive {T} (mut self)-> T
        throws errors::TcpError
    {
        let dmut buffer : [u8 ; T::size] = [0u8 ; T::size];
        let infos = __pragma!field_infos (T);
        cte for i in 0 .. T::arity {
            let f = self:.receive!{__pragma!field_type (T, i)} ();
            etc::c::memory::memory (cast!{*void} (buffer.ptr + infos [i].offset), cast!{*void} (&f), typeof (f)::size);
        }

        unsafe {
            return *(etc::runtime::memory::Runtime!{*u8, *T}::_yrt_unsafe_cast (buffer.ptr));
        }
    }

    /**
     * Send a slice to the stream
     * @params:
     *    - val: the value to send
     *    - limit: the limit of the slice that can be received (accepting anything <= 'limit')
     * @throws:
     *    - TcpError: if the receiving failed
     *
     * @info: Send the slice with metadatas to make it reconstructible on the other end without additional informations.
     * @example:
     * ```
     * // With serialization
     * stream:.send (copy [1, 2, 3, 4]);
     *
     * // Setting a receive limit of 8, refusing anything bigger to avoid big memory allocation from network requests
     * client:.receive!{[i32]} (limit-> 8) == [1, 2, 3, 4];
     * ```
     * */
    pub fn receive {T of [U], U} (mut self, limit : usize = 1024)-> mut [mut U]
        throws errors::TcpError
    {
        let len = self:.receive!{usize} ();
        if len > limit {
            let a = std::conv::to!{[c8]} (limit);
            let b = std::conv::to!{[c8]} (len);
            throw copy errors::TcpError (errors::TcpErrorCode::SOCKET_CLOSED, "Slice reception too big : " ~ a ~ " < " ~ b);
        }

        let mut result : [mut U] = core::types::array::allocArray!{U} (len);
        for i in val {
            result [i] = self:.receive!{U} ();
        }

        alias result
    }

    /**
     * Raw receive of a pre allocated slice of data
     * @params:
     *    - val: the value to receive
     * @throws:
     *    - TcpError: if the reception failed
     *
     * @info: Receive only the bytes of the slice
     * @example:
     * ```
     * // Without serialization
     * stream:.sendRaw (copy [1, 2, 3, 4]);
     *
     * let dmut result = copy [0 ; 4];
     * client:.receiveRaw (alias result); // raw receive of the data in a preallocated slice
     * ```
     * */
    pub fn if isScalar!{U} receiveRaw {T of [U], U} (mut self, dmut result : T)
        throws errors::TcpError
    {
        self:.innerReceiveRaw (cast!{*u8} (cast!{*void} (result.ptr)), cast!u32 (result.len));
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          CLOSING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dispose the stream by closing the socket
     * */
    pub fn dispose (mut self) {
        if self._sockFd > 0 {
            socket::shutdown (self._sockFd, ShutdownCodes::SHUT_RDWR);

            let ling = linger (1, 0);
            socket::setsockopt (self._sockFd, // free the port of the socket
                                SocketOptions::SOL_SOCKET,
                                SocketOptions::SO_LINGER,
                                cast!{*void} (&ling),
                                cast!u32 (linger::size));

            socket::close (self._sockFd);

            self._sockFd = 0;
            self._addr = SockAddr (Ipv4::UNSPECIFIED, 0);
            self._error = false;
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          MISC          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl std::stream::Streamable {
        pub over toStream (self, dmut stream : &std::stream::StringStream) {
            stream:.write (self.__typeinfo__.name):.write (" (");
            if self._sockFd == 0 || self._error {
                stream:.write ("CLOSED)");
            } else {
                stream:.write ("OPEN-> ", self._addr, ")");
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          DTOR          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */


    __dtor (mut self) {
        self:.dispose ();
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONNECTION V4          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Connect the stream to an ipv4 address
     * */
    prv fn connectV4 (mut self, addr : &Ipv4Addr, port : u16, timeout : dur::Duration)
        throws errors::TcpError
    {
        errno (ErrnoValue::NONE);
        self._sockFd = socket::socket (AddressFamily::AF_INET, SocketType::SOCK_STREAM, 0);
        if self._sockFd <= 0 {
            let err = errno ();
            let errStr = strerrno (err) ~ " (" ~ std::conv::to!{[c8], i32} (err) ~ ")";

            throw copy errors::TcpError (errors::TcpErrorCode::SOCKET_CREATION, "failed to create socket : (errno = " ~ errStr ~ ")");
        }

        let ina = in_addr (s_addr-> addr.toN ());
        let servaddr = sockaddr_in (sin_family-> AddressFamily::AF_INET,
                                    sin_addr-> ina,
                                    sin_port-> htons (port));

        self:.connectWithTimeout (cast!{*sockaddr} (&servaddr), cast!u32 (sockaddr_in::size), timeout);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          CONNECTION V6          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Connect the stream to an ipv6 address
     * */
    prv fn connectV6 (mut self, addr : &Ipv6Addr, port : u16, timeout : dur::Duration)
        throws errors::TcpError
    {
        errno (ErrnoValue::NONE);
        self._sockFd = socket::socket (AddressFamily::AF_INET6, SocketType::SOCK_STREAM, 0);
        if self._sockFd <= 0 {
            let err = errno ();
            let errStr = strerrno (err) ~ " (" ~ std::conv::to!{[c8], i32} (err) ~ ")";

            throw copy errors::TcpError (errors::TcpErrorCode::SOCKET_CREATION, "failed to create socket : (errno = " ~ errStr ~ ")");
        }

        let ina = in6_addr (s6_addr-> addr.toN ());
        let servaddr = sockaddr_in6 (sin6_family-> AddressFamily::AF_INET6,
                                     sin6_port-> htons (port),
                                     sin6_addr-> ina);

        self:.connectWithTimeout (cast!{*sockaddr} (&servaddr), cast!u32 (sockaddr_in6::size), timeout);
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==============================          CONNECT WITH TIMEOUT          ==============================
     * ====================================================================================================
     * ====================================================================================================
     */


    prv fn connectWithTimeout (mut self, addr : *sockaddr, size : u32, timeout : dur::Duration)
        throws errors::TcpError
    {
        self:.setNonBlocking ();

        let mut res = socket::connect (self._sockFd, addr, size);
        if res < 0 {
            let err = errno ();
            let succ = (if err == ErrnoValue::EINPROGRESS {
                let mut dur = dur_t (timeout.getSec (), timeout.getUSec ());
                let mut myset = fd_set ();

                let succ = loop {
                    _yrt_fd_zero (alias &myset);
                    _yrt_fd_set (self._sockFd, &myset);

                    res = select (cast!u32 (self._sockFd + 1), null, cast!{*void} (&myset), null, cast!{*void} (&dur));
                    if (res < 0 && errno () != ErrnoValue::EINTR) {
                        break false;
                    }

                    else if res > 0 {
                        let lon : u32 = i32::size;
                        let mut valopt : i32 = 0;
                        if getsockopt (self._sockFd, SocketOptions::SOL_SOCKET, SocketOptions::SO_ERROR, cast!{*void} (&valopt), &lon) < 0 {
                            break false;
                        }

                        if valopt != 0 {
                            break false;
                        }

                        break true;
                    }

                    else { // timeout
                        break false;
                    }
                }

                succ
            } else { // error connecting
                false
            });

            if !succ {
                let errStr = strerrno (err) ~ " (" ~ std::conv::to!{[c8], i32} (err) ~ ")";
                throw copy errors::TcpError (errors::TcpErrorCode::SOCKET_CREATION, "failed to connect : (errno = " ~ errStr ~ ")");
            }
        }

        self:.setBlockling ();
    }

    prv fn setNonBlocking (mut self) {
        let old = fcntl (self._sockFd, FileFlags::F_GETFL, 0);
        fcntl (self._sockFd, FileFlags::F_SETFL, old | SocketFlag::O_NONBLOCK);
    }

    prv fn setBlockling (mut self) {
        let old = fcntl (self._sockFd, FileFlags::F_GETFL, 0);
        fcntl (self._sockFd, FileFlags::F_SETFL, old & !SocketFlag::O_NONBLOCK);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          INNER SENDING          ==================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Send raw datas to the stream
     * */
    prv fn innerSendRaw (mut self, val : *u8, len : u32)
        throws errors::TcpError
    {
        if self._sockFd == 0 || self._error {
            throw copy errors::TcpError (errors::TcpErrorCode::SOCKET_CLOSED, "Remote connection closed");
        }

        let mut lenToSend = len;
        let mut cur : *u8 = val;
        while lenToSend != 0 {
            errno (ErrnoValue::NONE);
            let sent = socket::send (self._sockFd, cast!{*void} (cur), lenToSend, 16384);
            if sent < 1 {
                self._error = true;
                let err = errno ();
                let errStr = strerrno (err) ~ " (" ~ std::conv::to!{[c8], i32} (err) ~ ")";

                throw copy errors::TcpError (errors::TcpErrorCode::SOCKET_CLOSED, "failed to send : (errno = " ~ errStr ~ ")");
            }

            lenToSend -= cast!u32 (sent);
            cur += cast!usize (sent);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          INNER RECEIVING          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Raw receive of datas from the stream
     * */
    prv fn innerReceiveRaw (mut self, val : *u8, len : u32)
        throws errors::TcpError
    {
        if self._sockFd == 0 || self._error {
            throw copy errors::TcpError (errors::TcpErrorCode::SOCKET_CLOSED, "Remote connection closed");
        }

        let mut cur : *u8 = val;
        let mut lenToRecv = len;
        while lenToRecv != 0 {
            errno (ErrnoValue::NONE);
            let recv = socket::recv (self._sockFd, cast!{*void} (cur), lenToRecv, 0);
            if recv < 1 {
                self._error = true;
                let err = errno ();
                let errStr = strerrno (err) ~ " (" ~ std::conv::to!{[c8], i32} (err) ~ ")";

                throw copy errors::TcpError (errors::TcpErrorCode::SOCKET_CLOSED, "failed to receive : (errno = " ~ errStr ~ ")");
            }

            cur += cast!usize (recv);
            lenToRecv -= cast!u32 (recv);
        }
    }
}
