mod std::conv;
import std::io;

import core::typeinfo;
import core::exception;
import core::duplication;
import core::array;

mod Runtime {
    pub extern (C) def _yrt_ulong_to_double (a : u64)-> f64;
    
    pub extern (C) def _yrt_long_to_double (a : i64)-> f64;
    
    pub extern (C) def _yrt_uint_to_float (a : u32)-> f32;
    
    pub extern (C) def _yrt_int_to_float (a : i32)-> f32;

    pub extern (C) def _yrt_double_to_ulong (a : f64)-> u64;
    
    pub extern (C) def _yrt_double_to_long (a : f64)-> i64;
    
    pub extern (C) def _yrt_float_to_uint (a : f32)-> u32;
    
    pub extern (C) def _yrt_float_to_int (a : f32)-> i32;

    pub extern (C) def _yrt_to_utf8_array (s : [c32])-> dmut [c8];

    pub extern (C) def _yrt_to_utf32_array (s : [c8])-> dmut [c32];

    pub extern (C) def _yrt_double_to_s8 (s : f64)-> dmut [c8];

    pub extern (C) def _yrt_float_to_s8 (s : f32)-> dmut [c8];
}


/**
 * This class can be thrown when a dynamic cast was unsuccessful 
 * It doen't have a real meaning in the language, as it can't really happen
 * But we can force it
 * @example : 
 * ===============
 * class @abstract X { ... }
 * class Y over X { ... }
 * class Z over X { ... }
 * 
 * def enforce_Y  (a : &X) throws &std::conv::CastFailure
 * {
 *    match (a) {
 *        _ : &Y => {
 *             println (\"Success\");
 *        }
 *        _ => {
 *          throw CastFailure::new (a::typeinfo, Y::typeinfo);
 *        }
 *     }
 * } 
 * 
 * def main () {
 *     enforce_Y (Z::new ());
 * } catch {
 *     x : _ => println (x);
 * }
 * 
 * ===============
 */
pub class CastFailure over core::exception::Exception {

    // The type from which we want a cast    
    let _fr : TypeInfo;

    // The type to which we want a cast
    let _to : TypeInfo;

    /**
     * @params: 
     *    - from, the type from which we want a cast
     *    - to, the type to which we want a cast
     */
    pub self (from : TypeInfo, to : TypeInfo) with _fr = from, _to = to {}

    impl std::io::Printable {

        /**
         * Just print the error to stdout
         */
        pub over print (self) {
            self::super.print ();
        }
        
    }
    
}

pub {
    
    /**
     * Transform a u32 into a string
     * @example: 
     * ==========
     * let x = to![c32] (12u32);
     * assert (x == "12");
     * ==========
     */
    def to {T of [U], U of c32, F of u64} (a : F) -> [c32] {
        if (a == 0u64) return "0";
        let mut n = a;
        let mut len = 0u64;
        while n > 0u64 {
            len += 1u64;
            n /= 10u64;
        }
        
        let dmut res = core::duplication::allocArray!(c32)(len);
        let mut j = 1u64;
        for i in len .. 0u64 {
            res [i - 1u64] = to!c32 (a / j % 10u64);
            j *= 10u64;
        } catch {
            _ : &OutOfArray => { }
        }        
        
        res
    }

    /**
     * Transform a i32 into a string
     * @example:
     * ===========
     * let x = to![c32] (-12);
     * assert (x == "-12");
     * ===========
     */
    def to {T of [U], U of c32, F of i64} (a : F) -> [c32] {
        if (a == 0i64) return "0";
        let (mut n, mut len, sign) = if (a < 0i64) {
            (- a, 0u64, true)
        } else { (a, 0u64, false) }
                
        while n > 0i64 {
            len += 1u64;
            n /= 10i64;
        }
        
        let mut j = 1i64;
        if (!sign) {
            let dmut res = core::duplication::allocArray!(c32)(len);
            for i in len .. 0u64 {
                res [i - 1u64] = to!c32 (a / j % 10i64);
                j *= 10i64;
            } catch {
                _ : &OutOfArray => { }
            }
            res
        } else {
            let dmut res = core::duplication::allocArray!(c32)(len + 1u64);
            {
                for i in len .. 0u64 {
                    res [i] = to!c32 (-a / j % 10i64);
                    j *= 10i64;
                }
                res [0] = '-';
            } catch {
                _ : &OutOfArray => { }
            }
            res
        }        
    }



    
    /**
     * Transform is i32 into a string
     * @example: 
     * ============
     * assert (to![c32] (12) == "12")
     * ============
     */
    def to {T of [U], U of c32, F of i32} (a : F) -> [c32] {
        to![c32](cast!i64 (a))
    }

    /**
     * Transform is u32 into a string
     * @example: 
     * ============
     * assert (to![c32] (12u32) == "12")
     * ============
     */
    def to {T of [U], U of c32, F of u32} (a : F) -> [c32] {
        to![c32](cast!u64 (a))
    }

    /**
     * Transform is i16 into a string
     * @example: 
     * ============
     * assert (to![c32] (12i16) == "12")
     * ============
     */
    def to {T of [U], U of c32, F of i16} (a : F) -> [c32] {
        to![c32](cast!i64 (a))
    }

    /**
     * Transform is u16 into a string
     * @example: 
     * ============
     * assert (to![c32] (12u16) == "12")
     * ============
     */
    def to {T of [U], U of c32, F of u16} (a : F) -> [c32] {
        to![c32](cast!u64 (a))
    }

    /**
     * Transform is i8 into a string
     * @example: 
     * ============
     * assert (to![c32] (12i8) == "12")
     * ============
     */
    def to {T of [U], U of c32, F of i8} (a : F) -> [c32] {
        to![c32](cast!i64 (a))
    }

    /**
     * Transform is u8 into a string
     * @example: 
     * ============
     * assert (to![c32] (12u8) == "12")
     * ============
     */
    def to {T of [U], U of c32, F of u8} (a : F) -> [c32] {
        to![c32](cast!u64 (a))
    }

    /**
     * Transform a u32 into a string
     * @example: 
     * ==========
     * let x = to![c8] (12u32);
     * assert (x == "12");
     * ==========
     */
    def to {T of [U], U of c8, F of u64} (a : F) -> [c8] {
        if (a == 0u64) return "0"s8;
        let mut n = a;
        let mut len = 0u64;
        while n > 0u64 {
            len += 1u64;
            n /= 10u64;
        }
        
        let dmut res = core::duplication::allocArray!(c8)(len);
        let mut j = 1u64;
        for i in len .. 0u64 {
            res [i - 1u64] = to!c8 (a / j % 10u64);
            j *= 10u64;
        } catch {
            _ : &OutOfArray => { }
        }        
        
        res
    }

    /**
     * Transform a i32 into a string
     * @example:
     * ===========
     * let x = to![c8] (-12);
     * assert (x == "-12");
     * ===========
     */
    def to {T of [U], U of c8, F of i64} (a : F) -> [c8] {
        if (a == 0i64) return "0"s8;
        let (mut n, mut len, sign) = if (a < 0i64) {
            (- a, 0u64, true)
        } else { (a, 0u64, false) }
                
        while n > 0i64 {
            len += 1u64;
            n /= 10i64;
        }
        
        let mut j = 1i64;
        if (!sign) {
            let dmut res = core::duplication::allocArray!(c8)(len);
            for i in len .. 0u64 {
                res [i - 1u64] = to!c8 (a / j % 10i64);
                j *= 10i64;
            } catch {
                _ : &OutOfArray => { }
            }
            res
        } else {
            let dmut res = core::duplication::allocArray!(c8)(len + 1u64);
            {
                for i in len .. 0u64 {
                    res [i] = to!c8 (-a / j % 10i64);
                    j *= 10i64;
                }
                res [0] = '-'c8;
            } catch {
                _ : &OutOfArray => { }
            }
            res
        }        
    }

    /**
     * Transfrom a utf32 encoded string into a utf8 string
     * @params :
     *   - s: a string in utf32
     */
    def to {T of [U], U of c8, F of [c32]} (s : F)-> dmut [c8] {
        alias Runtime::_yrt_to_utf8_array (s)
    }
    
    /**
     * Transfrom a utf8 encoded string into a utf32 string
     * @params :
     *   - s: a string in utf8
     */
    def to {T of [U], U of c32, F of [c8]} (s : F)-> dmut [c32] {
        alias Runtime::_yrt_to_utf32_array (s)
    }

    /**
     * Create a zero terminated string from a [c8]
     */
    def toStringZ (a : [c8])-> &c8 {
        let dmut res = core::duplication::allocArray!(c8)(a.len + 1u64);
        core::duplication::memCopy (a, alias res);
        {
            res [$-1u64] = '\u{0}'c8;
        } catch {
            _ : &OutOfArray => {}
        }
        res.ptr
    }

    /**
     * @returns: a slice of a where the len is correctly set
     */
    def fromStringZ {U of [c8]} (a : U)-> [c8] {
        let mut len = 0u64;
        for i in a {
            if (i == '\u{0}'c8) break {};
            else len += 1u64;
        }
        __pragma!trusted ({ a [0u64 .. len] })
    }

    /**
     * @returns: a slice of a where the len is correctly set
     */
    def fromStringZ {U of &c8} (a : U)-> [c8]
        throws &SegFault
    {
        let mut len = 0u64;
        loop {
            if (*(a + len) == '\u{0}'c8) break {};
            else len += 1u64;            
        }
        import std::io;
        let dmut res = core::duplication::allocArray!(c8)(len);
        __pragma!trusted ({
            for i in 0u64 .. len {
                res [i] = *(a + i);
            }
        });
        res
    }


    
    /**
     * Transfrom a utf32 encoded char into a utf8 string
     * @params :
     *   - s: a char in utf32
     */
    def to {T of [U], U of c8, F of c32} (s : F) -> dmut [c8] {
        alias Runtime::_yrt_to_utf8_array ([s])
    }
    
    /**
     * Transform is i32 into a string
     * @example: 
     * ============
     * assert (to![c8] (12) == "12"s8)
     * ============
     */
    def to {T of [U], U of c8, F of i32} (a : F) -> [c8] {
        to![c8](cast!i64 (a))
    }

    /**
     * Transform is u32 into a string
     * @example: 
     * ============
     * assert (to![c8] (12u32) == "12"s8)
     * ============
     */
    def to {T of [U], U of c8} (a : u32) -> [c8] {
        to![c8](cast!u64 (a))
    }

    /**
     * Transform is i16 into a string
     * @example: 
     * ============
     * assert (to![c8] (12i16) == "12"s8)
     * ============
     */
    def to {T of [U], U of c8, F of i16} (a : F) -> [c8] {
        to![c8](cast!i64 (a))
    }

    /**
     * Transform is u16 into a string
     * @example: 
     * ============
     * assert (to![c8] (12u16) == "12"s8)
     * ============
     */
    def to {T of [U], U of c8, F of u16} (a : F) -> [c8] {
        to![c8](cast!u64 (a))
    }

    /**
     * Transform is i8 into a string
     * @example: 
     * ============
     * assert (to![c8] (12i8) == "12"s8)
     * ============
     */
    def to {T of [U], U of c8, F of i8} (a : F) -> [c8] {
        to![c8](cast!i64 (a))
    }

    /**
     * Transform is u8 into a string
     * @example: 
     * ============
     * assert (to![c8] (12u8) == "12"s8)
     * ============
     */
    def to {T of [U], U of c8, F of u8} (a : F) -> [c8] {
        to![c8](cast!u64 (a))
    }

    /**
     * Transform a f32 into a string
     * @example: 
     * ===========
     * assert (to![c8] (12.8f) == "12.8"s8)
     * ===========
     */
    def to {T of [U], U of c8, F of f32} (a : F) -> [c8] {
        Runtime::_yrt_float_to_s8 (a)
    }

    /**
     * Transform a f64 into a string
     * @example: 
     * ===========
     * assert (to![c8] (12.8) == "12.8"s8)
     * ===========
     */
    def to {T of [U], U of c8, F of f64} (a : F) -> [c8] {
        Runtime::_yrt_double_to_s8 (a)
    }

    /**
     * Transform a f32 into a string
     * @example: 
     * ===========
     * assert (to![c32] (12.8f) == "12.8")
     * ===========
     */
    def to {T of [U], U of c32, F of f32} (a : F) -> [c32] {
        to![c32] (Runtime::_yrt_float_to_s8 (a))
    }

    /**
     * Transform a f64 into a string
     * @example: 
     * ===========
     * assert (to![c32] (12.8) == "12.8")
     * ===========
     */
    def to {T of [U], U of c32, F of f64} (a : F) -> [c32] {
        to![c32] (Runtime::_yrt_double_to_s8 (a))
    } 

    /**
     * Convert a bool into a string 
     * @example: 
     * ===========
     * assert (to![c8] (false) == "false"s8)
     * ===========
     */
    def to {T of [U], U of c8, F of bool} (a : F)-> [c8] {
        if (a)
            "true"s8
        else
            "false"s8
    }

    /**
     * Convert a bool into a string 
     * @example: 
     * ===========
     * assert (to![c32] (false) == "false")
     * ===========
     */
    def to {T of [U], U of c32, F of bool} (a : F)-> [c32] {
        if (a)
            "true"
        else
            "false"
    }
    
    /**
     * Transform a u64 into a f64
     * @example: 
     * ==========
     * let x = to!f64 (12u64);
     * assert (x == 12.0);
     * ==========
     */
    def to {T of f64, F of u64} (a : F) -> f64 {
        Runtime::_yrt_ulong_to_double (a)
    }

    /**
     * Transform a i64 into a f64
     * @example: 
     * ==========
     * let x = to!f64 (12i64);
     * assert (x == 12.0);
     * ==========
     */
    def to {T of f64, F of i64} (a : F) -> f64 {
        Runtime::_yrt_long_to_double (a)
    }


    /**
     * Transform a i32 into a f64
     * @example: 
     * ==========
     * let x = to!f64 (12);
     * assert (x == 12.0);
     * ==========
     */
    def to {T of f64, F of i32} (a : F) -> f64 {
        Runtime::_yrt_long_to_double (cast!i64 (a))
    }

    /**
     * Transform a u32 into a f64
     * @example: 
     * ==========
     * let x = to!f64 (12);
     * assert (x == 12.0);
     * ==========
     */
    def to {T of f64, F of u32} (a : F) -> f64 {
        Runtime::_yrt_ulong_to_double (cast!u64 (a))
    }

    /**
     * Transform a i32 into a f32
     * @example: 
     * ==========
     * let x = to!f32 (12);
     * assert (x == 12.0f);
     * ==========
     */
    def to {T of f32, F of i32} (a : F) -> f32 {
        Runtime::_yrt_int_to_float (a)
    }

    /**
     * Transform a u32 into a f32
     * @example: 
     * ==========
     * let x = to!f32 (12);
     * assert (x == 12.0f);
     * ==========
     */
    def to {T of f32, F of u32} (a : F) -> f32 {
        Runtime::_yrt_uint_to_float (a)
    }

    /**
     * Transform a f64 into a i64
     * @example:
     * ============
     * let x = to!i64 (12.0);
     * assert (x == 12i64);
     * ============
     */
    def to {T of i64, F of f64} (a : F) -> i64 {
        Runtime::_yrt_double_to_long (a)
    }

    /**
     * Transform a f64 into a u64
     * @example:
     * ============
     * let x = to!u64 (12.0);
     * assert (x == 12u64);
     * ============
     */
    def to {T of u64, F of f64} (a : F) -> u64 {
        Runtime::_yrt_double_to_ulong (a)
    }


    /**
     * Transform a f32 into a i32
     * @example:
     * ============
     * let x = to!i32 (12.f);
     * assert (x == 12);
     * ============
     */
    def to {T of i32, F of f32} (a : F) -> i32 {
        Runtime::_yrt_float_to_int (a)
    }

    /**
     * Transform a f32 into a u32
     * @example:
     * ============
     * let x = to!u32 (12.f);
     * assert (x == 12u32);
     * ============
     */
    def to {T of u32, F of f32} (a : F) -> u32 {
        Runtime::_yrt_float_to_uint (a)
    }

    /**
     * Transform a f32 into a i64
     * @example:
     * ============
     * let x = to!i64 (12.f);
     * assert (x == 12i64);
     * ============
     */
    def to {T of i64, F of f32} (a : F) -> i64 {
        cast!i64 (Runtime::_yrt_float_to_int (a))
    }

    /**
     * Transform a f32 into a u64
     * @example:
     * ============
     * let x = to!u64 (12.f);
     * assert (x == 12u64);
     * ============
     */
    def to {T of u64, F of f32} (a : F) -> u64 {
        cast!u64 (Runtime::_yrt_float_to_uint (a))
    }

    /**
     * Transform a string into a u64
     * @throws: 
     *    - &CastFailure: if the string does not contain a valid u32 literal
     * @example:
     * ===============
     * let x = ("12").to!u64 ();
     * assert (x == 12u64);
     * ===============
     * @assume: the string is stripped, so the only possible char are [0-9]
     * @known_bug: does not check the overflow capacity
     */
    def to {T of u64, F of [c32]} (str : F)-> u64
        throws &CastFailure
    {
        let mut j = 1u64;
        let mut res = 0u64;
        for i in str.len .. 0u64 {
            if (str [i - 1u64] >= '0' && str [i - 1u64] <= '9') {                
                res = res + (j * to!u64 (str [i - 1u64]));
            } else {
                throw CastFailure::new ([c32]::typeinfo, u64::typeinfo); 
            }
            j *= 10u64;
        } catch {
            _ : &OutOfArray => { } // Can't happen
            x : &CastFailure => {
                throw x;
            }
        }
        res
    }

    /**
     * Transform a string into a u32
     * @throws: 
     *    - &CastFailure: if the string does not contain a valid u32 literal
     * @example:
     * ===============
     * let x = ("12"s8).to!u32 ();
     * assert (x == 12u32);
     * ===============
     * @assume: the string is stripped, so the only possible char are [0-9]
     * @known_bug: does not check the overflow capacity
     */
    def to {T of u32, F of [c32]} (str : F)-> T
        throws &CastFailure
    {
        {
            cast!T (to!u64 (str))
        } catch {
            _ : &CastFailure => {
                throw CastFailure::new ([c32]::typeinfo, T::typeinfo);
            }
        }
    }

    /**
     * Transform a string into a u16
     * @throws: 
     *    - &CastFailure: if the string does not contain a valid u32 literal
     * @example:
     * ===============
     * let x = ("12"s8).to!u16 ();
     * assert (x == 12u16);
     * ===============
     * @assume: the string is stripped, so the only possible char are [0-9]
     * @known_bug: does not check the overflow capacity
     */
    def to {T of u16, F of [c32]} (str : F)-> T
        throws &CastFailure
    {
        {
            cast!T (to!u64 (str))
        } catch {
            _ : &CastFailure => {
                throw CastFailure::new ([c32]::typeinfo, T::typeinfo);
            }
        }
    }

    /**
     * Transform a string into a u8
     * @throws: 
     *    - &CastFailure: if the string does not contain a valid u32 literal
     * @example:
     * ===============
     * let x = ("12"s8).to!u8 ();
     * assert (x == 12u8);
     * ===============
     * @assume: the string is stripped, so the only possible char are [0-9]
     * @known_bug: does not check the overflow capacity
     */
    def to {T of u8, F of [c32]} (str : F)-> T
        throws &CastFailure
    {
        {
            cast!T (to!u64 (str))
        } catch {
            _ : &CastFailure => {
                throw CastFailure::new ([c32]::typeinfo, T::typeinfo);
            }
        }
    }
    
    
    /**
     * Transform a string into a u64
     * @throws: 
     *    - &CastFailure: if the string does not contain a valid u32 literal
     * @example:
     * ===============
     * let x = ("12"s8).to!u64 ();
     * assert (x == 12u64);
     * ===============
     * @assume: the string is stripped, so the only possible char are [0-9]
     * @known_bug: does not check the overflow capacity
     */
    def to {T of u64, F of [c8]} (str : F)-> u64
        throws &CastFailure
    {
        let mut j = 1u64;
        let mut res = 0u64;
        for i in str.len .. 0u64 {
            if (str [i - 1u64] >= '0'c8 && str [i - 1u64] <= '9'c8) {                
                res = res + (j * to!u64 (str [i - 1u64]));
            } else {
                throw CastFailure::new ([c8]::typeinfo, u64::typeinfo); 
            }
            j *= 10u64;
        } catch {
            _ : &OutOfArray => { } // Can't happen
            x : &CastFailure => {
                throw x;
            }
        }
        res
    }

    /**
     * Transform a string into a u32
     * @throws: 
     *    - &CastFailure: if the string does not contain a valid u32 literal
     * @example:
     * ===============
     * let x = ("12"s8).to!u32 ();
     * assert (x == 12u32);
     * ===============
     * @assume: the string is stripped, so the only possible char are [0-9]
     * @known_bug: does not check the overflow capacity
     */
    def to {T of u32, F of [c8]} (str : F)-> T
        throws &CastFailure
    {
        {
            cast!T (to!u64 (str))
        } catch {
            _ : &CastFailure => {
                throw CastFailure::new ([c8]::typeinfo, T::typeinfo);
            }
        }
    }

    /**
     * Transform a string into a u16
     * @throws: 
     *    - &CastFailure: if the string does not contain a valid u32 literal
     * @example:
     * ===============
     * let x = ("12"s8).to!u16 ();
     * assert (x == 12u16);
     * ===============
     * @assume: the string is stripped, so the only possible char are [0-9]
     * @known_bug: does not check the overflow capacity
     */
    def to {T of u16, F of [c8]} (str : F)-> T
        throws &CastFailure
    {
        {
            cast!T (to!u64 (str))
        } catch {
            _ : &CastFailure => {
                throw CastFailure::new ([c8]::typeinfo, T::typeinfo);
            }
        }
    }

    /**
     * Transform a string into a u8
     * @throws: 
     *    - &CastFailure: if the string does not contain a valid u32 literal
     * @example:
     * ===============
     * let x = ("12"s8).to!u8 ();
     * assert (x == 12u8);
     * ===============
     * @assume: the string is stripped, so the only possible char are [0-9]
     * @known_bug: does not check the overflow capacity
     */
    def to {T of u8, F of [c8]} (str : F)-> T
        throws &CastFailure
    {
        {
            cast!T (to!u64 (str))
        } catch {
            _ : &CastFailure => {
                throw CastFailure::new ([c8]::typeinfo, T::typeinfo);
            }
        }
    }


    /**
     * Transform a string into a i64
     * @throws: 
     *    - &CastFailure: if the string does not contain a valid i64 literal
     * @example:
     * ===============
     * let x = ("-12").to!i64 ();
     * assert (x == -12i64);
     * ===============
     * @assume: the string is stripped, so the only possible char are [0-9] and '-'
     * @known_bug: does not check the overflow capacity
     */
    def to {T of i64, F of [c32]} (str : F)-> i64
        throws &CastFailure
    {
        let mut j = 1u64;
        let mut res = 0i64;
        for i in str.len .. 0u64 {
            if (str [i - 1u64] >= '0' && str [i - 1u64] <= '9') {                
                res = res + cast!i64 ((j * to!u64 (str [i - 1u64])));
            } else if (i == 1u64 && str [i - 1u64] == '-') {
                res = -res;
            } else {
                throw CastFailure::new ([c32]::typeinfo, i64::typeinfo); 
            }
            j *= 10u64;
        } catch {
            _ : &OutOfArray => { } // Can't happen
            x : &CastFailure => {
                throw x;
            }
        }
        res
    }

    /**
     * Transform a string into a i32, i16 of i8
     * @throws:
     *   - &CastFailure: if the string does not contain a valid i32 literal
     * @example:
     * ===============
     * let x = ("-12").to!i32 ();
     * assert (x == -12);
     * ===============
     * @assume: the string is stripped, so the only possible char are [0-9] and '-'    
     * @known_bug: does not check the overflow capacity
     */
    def to {T of i32, F of [c32]} (str : F)-> T
        throws &CastFailure
    {
        {
            cast!T (to!i64 (str))
        } catch {
            _ : &CastFailure => {
                throw CastFailure::new ([c32]::typeinfo, T::typeinfo);
            }
        }
    }

    /**
     * Transform a string into a i16
     * @throws:
     *   - &CastFailure: if the string does not contain a valid i32 literal
     * @example:
     * ===============
     * let x = ("-12").to!i16 ();
     * assert (x == -12i16);
     * ===============
     * @assume: the string is stripped, so the only possible char are [0-9] and '-'    
     * @known_bug: does not check the overflow capacity
     */
    def to {T of i16, F of [c32]} (str : F)-> T
        throws &CastFailure
    {
        {
            cast!T (to!i64 (str))
        } catch {
            _ : &CastFailure => {
                throw CastFailure::new ([c32]::typeinfo, T::typeinfo);
            }
        }
    }

    /**
     * Transform a string into a i8
     * @throws:
     *   - &CastFailure: if the string does not contain a valid i32 literal
     * @example:
     * ===============
     * let x = ("-12").to!i8 ();
     * assert (x == -12i8);
     * ===============
     * @assume: the string is stripped, so the only possible char are [0-9] and '-'    
     * @known_bug: does not check the overflow capacity
     */
    def to {T of i8, F of [c32]} (str : F)-> T
        throws &CastFailure
    {
        {
            cast!T (to!i64 (str))
        } catch {
            _ : &CastFailure => {
                throw CastFailure::new ([c32]::typeinfo, T::typeinfo);
            }
        }
    }

    
        /**
     * Transform a string into a i64
     * @throws: 
     *    - &CastFailure: if the string does not contain a valid i64 literal
     * @example:
     * ===============
     * let x = ("-12").to!i64 ();
     * assert (x == -12i64);
     * ===============
     * @assume: the string is stripped, so the only possible char are [0-9] and '-'
     * @known_bug: does not check the overflow capacity
     */
    def to {T of i64, F of [c8]} (str : F)-> i64
        throws &CastFailure
    {
        let mut j = 1u64;
        let mut res = 0i64;
        for i in str.len .. 0u64 {
            if (str [i - 1u64] >= '0'c8 && str [i - 1u64] <= '9'c8) {                
                res = res + cast!i64 ((j * to!u64 (str [i - 1u64])));
            } else if (i == 1u64 && str [i - 1u64] == '-'c8) {
                res = -res;
            } else {
                throw CastFailure::new ([c32]::typeinfo, i64::typeinfo); 
            }
            j *= 10u64;
        } catch {
            _ : &OutOfArray => { } // Can't happen
            x : &CastFailure => {
                throw x;
            }
        }
        res
    }

    /**
     * Transform a string into a i32
     * @throws: 
     *    - &CastFailure: if the string does not contain a valid u32 literal
     * @example:
     * ===============
     * let x = ("12"s8).to!i32 ();
     * assert (x == 12i32);
     * ===============
     * @assume: the string is stripped, so the only possible char are [0-9]
     * @known_bug: does not check the overflow capacity
     */
    def to {T of i32, F of [c8]} (str : F)-> T
        throws &CastFailure
    {
        {
            cast!T (to!i64 (str))
        } catch {
            _ : &CastFailure => {
                throw CastFailure::new ([c8]::typeinfo, T::typeinfo);
            }
        }
    }

    /**
     * Transform a string into a i16
     * @throws: 
     *    - &CastFailure: if the string does not contain a valid u32 literal
     * @example:
     * ===============
     * let x = ("12"s8).to!i16 ();
     * assert (x == 12i16);
     * ===============
     * @assume: the string is stripped, so the only possible char are [0-9]
     * @known_bug: does not check the overflow capacity
     */
    def to {T of i16, F of [c8]} (str : F)-> T
        throws &CastFailure
    {
        {
            cast!T (to!i64 (str))
        } catch {
            _ : &CastFailure => {
                throw CastFailure::new ([c8]::typeinfo, T::typeinfo);
            }
        }
    }    

    /**
     * Transform a string into a i8
     * @throws: 
     *    - &CastFailure: if the string does not contain a valid u32 literal
     * @example:
     * ===============
     * let x = ("12"s8).to!i8 ();
     * assert (x == 12i8);
     * ===============
     * @assume: the string is stripped, so the only possible char are [0-9]
     * @known_bug: does not check the overflow capacity
     */
    def to {T of i8, F of [c8]} (str : F)-> T
        throws &CastFailure
    {
        {
            cast!T (to!i64 (str))
        } catch {
            _ : &CastFailure => {
                throw CastFailure::new ([c8]::typeinfo, T::typeinfo);
            }
        }
    }    

    
    /**
     * Transform a string in hexadecimal format into a u32
     * @throws: 
     *    - &CastFailure: if the string does not contain a valid i32 literal
     * @example:
     * ===============
     * let x = ("0xff").(to!(u32, "x"));
     * assert (x == 255u32);
     * ===============
     * @assume: the string is stripped, so the only possible char are [0-9a-f], '0', 'x'
     * @known_bug: does not check the overflow capacity
     */
    def to {T of u64, "x", F of [c32]} (str : F)-> u64
        throws &CastFailure
    {
        let mut j = 1u64;
        let mut res = 0u64;
        {
            if (str.len < 2u64) throw CastFailure::new ([c32]::typeinfo, i32::typeinfo);
            if (str [0] != '0' || str [1] != 'x') throw CastFailure::new ([c32]::typeinfo, i32::typeinfo);
                     
            for i in str.len .. 2u64 {
                if (str [i - 1u64] >= '0' && str [i - 1u64] <= '9') {                
                    res = res + (j * to!u64 (str [i - 1u64]));
                } else if (str [i - 1u64] >= 'a' && str [i - 1u64] <= 'f') {
                    res = res + (j * to!u64 (str [i - 1u64]));
                } else if (str [i - 1u64] >= 'A' && str [i - 1u64] <= 'F') {
                    res = res + (j * to!u64 (str [i - 1u64]));
                } else {
                    throw CastFailure::new ([c32]::typeinfo, u64::typeinfo); 
                }
                j *= 16u64;
            } 
        } catch {
            _ : &OutOfArray => { } // Can't happen
            x : &CastFailure => {
                throw x;
            }
        }
        res
    }
    
    /**
     * Transform a string in hexadecimal format into a u32
     * @throws: 
     *    - &CastFailure: if the string does not contain a valid i32 literal
     * @example:
     * ===============
     * let x = ("0xff").to!{u32, "x"} ();
     * assert (x == 255u32);
     * ===============
     * @assume: the string is stripped, so the only possible char are [0-9a-f], '0', 'x'
     * @known_bug: does not check the overflow capacity
     */
    def to {T of u32, "x", F of [c32]} (str : F)-> T
        throws &CastFailure
    {
        {
            cast!T (to!{u64, "x"} (str))
        } catch {
            _ : &CastFailure => {
                throw CastFailure::new ([c32]::typeinfo, T::typeinfo);
            }
        }
    }

    /**
     * Transform a string in hexadecimal format into a u16
     * @throws: 
     *    - &CastFailure: if the string does not contain a valid i32 literal
     * @example:
     * ===============
     * let x = ("0xff").to!{u16, "x"} ();
     * assert (x == 255u16);
     * ===============
     * @assume: the string is stripped, so the only possible char are [0-9a-f], '0', 'x'
     * @known_bug: does not check the overflow capacity
     */
    def to {T of u16, "x", F of [c32]} (str : F)-> T
        throws &CastFailure
    {
        {
            cast!T (to!{u64, "x"} (str))
        } catch {
            _ : &CastFailure => {
                throw CastFailure::new ([c32]::typeinfo, T::typeinfo);
            }
        }
    }

    /**
     * Transform a string in hexadecimal format into a u8
     * @throws: 
     *    - &CastFailure: if the string does not contain a valid i32 literal
     * @example:
     * ===============
     * let x = ("0xff").to!{u8, "x"} ();
     * assert (x == 255u8);
     * ===============
     * @assume: the string is stripped, so the only possible char are [0-9a-f], '0', 'x'
     * @known_bug: does not check the overflow capacity
     */
    def to {T of u8, "x", F of [c32]} (str : F)-> T
        throws &CastFailure
    {
        {
            cast!T (to!{u64, "x"} (str))
        } catch {
            _ : &CastFailure => {
                throw CastFailure::new ([c32]::typeinfo, T::typeinfo);
            }
        }
    }

    /**
     * Transform a string into a f64
     * @throws: 
     *    - &CastFailure: if the string does not contain a valid f64 literal
     * @example:
     * ===============
     * let x = ("-12.89").(to!f64);
     * assert (x == -12.89);
     * ===============
     * @assume: the string is stripped, so the only possible char are [0-9], '-' and '.'
     */
    def to {T of f64, F of [c32]} (str : F)-> f64
        throws &CastFailure
    {
        let mut j = 1u64;
        let mut z = 1u64;
        let mut int = 0i64;
        let mut float = 0i64;
        let mut floating = true;
        let mut minus = false;
        
        for i in str.len .. 0u64 {
            if (str [i - 1u64] >= '0' && str [i - 1u64] <= '9') {
                if (floating) {
                    float = float + cast!i64 ((j * to!u64 (str [i - 1u64])));
                    j *= 10u64;
                } else {
                    int = int + cast!i64 ((z * to!u64 (str [i - 1u64])));
                    z *= 10u64;
                } 
            } else if (i == 1u64 && str [i - 1u64] == '-') {
                minus = true;
            } else if (str [i - 1u64] == '.') {
                if !floating { // multiple points
                    throw CastFailure::new ([c32]::typeinfo, f64::typeinfo);
                }
                floating = false;
            } else {
                throw CastFailure::new ([c32]::typeinfo, f64::typeinfo);
            }            
        } catch {
            _ : &OutOfArray => { } // Can't happen
            x : &CastFailure => {
                throw x;
            }
        }
        
        let res : f64 = if !floating {
            to!f64 (int) + (to!f64 (float)/to!f64 (j))
        } else { // no points in the string
            to!f64 (float) 
        }
        
        if minus {
            -res
        } else res
    }


    /**
     * Unwrap the content of an option type
     * @example: 
     * ==============
     * def foo (i : i32)-> i32
     *     throws &AssertError
     * {
     *     assert (i != 0);
     *     144 / i
     * }
     * 
     * let j = foo (12)?
     * let k = foo (0)?
     * {
     *     println (j.unwrap ()); // prints "12"
     *     let x = j.unwrap () 
     *             + k.unwrap (); // throw an exception
     *     println (x); 
     * } catch {
     *    err : &CastFailure => {
     *          println (err);
     *    }
     * }
     * ==============
     * @throws : &CastFailure, if the option is empty
     */
    def unwrap {T} (a : T?) -> T
        throws &CastFailure
    {
        match a {
            Ok (x : _) => {
                return x;
            }
            _ => {
                throw CastFailure::new (void::typeinfo, T::typeinfo);
            }
        }
    }

    /**
     * Unwrap the content of an option type containing a class type
     * This function, unlike simple unwrap allows to cast the content of the option into the type of an child class
     * @example: 
     * ==================
     * class @abstract A {
     *   prot self () {}
     *   impl std::io::Printable;
     * }
     * 
     * class B over A {
     *   pub self () {}
     *   impl std::io::Printable;
     * }
     *
     * class C over A {
     *   pub self () {}
     *   impl std::io::Printable;
     * }
     *
     * def foo (i : i32) -> (&A)? {
     *     if (i < 10) { (B::new ()?).to!(&A?} () }
     *     else if (i < 20) { (C::new ()?).to!(&A?} () }
     *     else (&A?)::__err__
     * }
     * 
     * let x = foo (1);
     * let y = foo (14);
     * let z = foo (120);
     * {
     *    println (x.unwrap!(&B} ()); // prints "main::B ()"
     *    println (y.unwrap!(&C} ()); // prints "main::C ()"
     *    println (y.unwrap!(&A} ()); // prints "main::C ()"
     *    println (z.unwrap!(&A} ()); // throw an exception
     * } catch {
     *     err : &CastFailure => {
     *         println (err);
     *     }
     *}
     * ==================
     * @throws : &CastFailure, if the option is empty, or the option does not contain a value of type U
     */
    def if (is!U {J over T}) unwrap {U, T} (a : T?) -> U
        throws &CastFailure
    {
        match a {
            Ok (x : U) => {
                return x;
            }
            Ok (z : _) => {
                throw CastFailure::new (typeof (z)::typeinfo, T::typeinfo);
            }
            _ => {
                throw CastFailure::new (void::typeinfo, T::typeinfo);
            }
        }
    }

    /**
     * Transform a U? into a T? if U is over T
     * @example: 
     * ================
     * class @abstract A {
     *   prot self () {}
     *   impl std::io::Printable;
     * }
     * 
     * class B over A {
     *   pub self () {}
     *   impl std::io::Printable;
     * }
     *
     * class C over A {
     *   pub self () {}
     *   impl std::io::Printable;
     * }
     * 
     * def foo (i : i32) -> (&A)? {
     *     if (i < 10) { (B::new ()?).to!(&A?} () }
     *     else if (i < 20) { (C::new ()?).to!(&A?} () }
     *     else (&A?)::__err__
     * }
     * ================
     */
    def to {T of I?, I, U over I} (a : U?)-> T {
        match a {
            Ok (x: _) => {
                (cast!I (x))?
            }
            _ => {
                (T)::__err__
            }
        }
    }

    
}

/**
 * @assume: a < 10
 * Transform a u64 into a c8
 */
def to {T of c8} (a : u64) -> c8 {
    match a {
        0u32 => { '0'c8 }
        1u32 => { '1'c8 }
        2u32 => { '2'c8 }
        3u32 => { '3'c8 }
        4u32 => { '4'c8 }
        5u32 => { '5'c8 }
        6u32 => { '6'c8 }
        7u32 => { '7'c8 }
        8u32 => { '8'c8 }
        9u32 => { '9'c8 }
        9u32 => { '9'c8 }
        10u32 => { 'a'c8 }
        11u32 => { 'b'c8 }
        12u32 => { 'c'c8 }
        13u32 => { 'd'c8 }
        14u32 => { 'e'c8 }
        15u32 => { 'f'c8 }
        _ => { '\u{0}'c8 }
    }
}

/**
 * @assume: a < 10 and a >= 0
 * Transform a i64 into a c8
 */
def to {T of c8} (a : i64) -> c8 {
    match a {
        0 => { '0'c8 }
        1 => { '1'c8 }
        2 => { '2'c8 }
        3 => { '3'c8 }
        4 => { '4'c8 }
        5 => { '5'c8 }
        6 => { '6'c8 }
        7 => { '7'c8 }
        8 => { '8'c8 }
        9 => { '9'c8 }
        10 => { 'a'c8 }
        11 => { 'b'c8 }
        12 => { 'c'c8 }
        13 => { 'd'c8 }
        14 => { 'e'c8 }
        15 => { 'f'c8 }
        _ => { '\u{0}'c8 }
    }
}


/**
 * @assume: a <= 15
 * Transform a u64 into a c32
 */
def to {T of c32} (a : u64) -> c32 {
    match a {
        0u32 => { '0' }
        1u32 => { '1' }
        2u32 => { '2' }
        3u32 => { '3' }
        4u32 => { '4' }
        5u32 => { '5' }
        6u32 => { '6' }
        7u32 => { '7' }
        8u32 => { '8' }
        9u32 => { '9' }
        10u32 => { 'a' }
        11u32 => { 'b' }
        12u32 => { 'c' }
        13u32 => { 'd' }
        14u32 => { 'e' }
        15u32 => { 'f' }
        _ => { '\u{0}' }
    }
}

/**
 * @assume: a <= 15 and a >= 0
 * Transform a u64 into a c32
 */
def to {T of c32} (a : i64) -> c32 {
    match a {
        0 => { '0' }
        1 => { '1' }
        2 => { '2' }
        3 => { '3' }
        4 => { '4' }
        5 => { '5' }
        6 => { '6' }
        7 => { '7' }
        8 => { '8' }
        9 => { '9' }
        10 => { 'a' }
        11 => { 'b' }
        12 => { 'c' }
        13 => { 'd' }
        14 => { 'e' }
        15 => { 'f' }
        _ => { '\u{0}' }
    }
}


/**
 * Transform a c32 into a u64
 * @assume: a >= '0' and a <= '9' or a >= 'a' and a <= 'f'
 */
def to {T of u64} (a : c32) -> u64 {
    match a {
        '0' => { 0u64 }
        '1' => { 1u64 }
        '2' => { 2u64 }
        '3' => { 3u64 }
        '4' => { 4u64 }
        '5' => { 5u64 }
        '6' => { 6u64 }
        '7' => { 7u64 }
        '8' => { 8u64 }
        '9' => { 9u64 }
        'a' => { 10u64 }
        'b' => { 11u64 }
        'c' => { 12u64 }
        'd' => { 13u64 }
        'e' => { 14u64 }
        'f' => { 15u64 }
        'A' => { 10u64 }
        'B' => { 11u64 }
        'C' => { 12u64 }
        'D' => { 13u64 }
        'E' => { 14u64 }
        'F' => { 15u64 }
        _ => { 0u64 }            
    }
}

/**
 * Transform a c8 into a u64
 * @assume: a >= '0' and a <= '9' or a >= 'a' and a <= 'f'
 */
def to {T of u64} (a : c8) -> u64 {
    match a {
        '0'c8 => { 0u64 }
        '1'c8 => { 1u64 }
        '2'c8 => { 2u64 }
        '3'c8 => { 3u64 }
        '4'c8 => { 4u64 }
        '5'c8 => { 5u64 }
        '6'c8 => { 6u64 }
        '7'c8 => { 7u64 }
        '8'c8 => { 8u64 }
        '9'c8 => { 9u64 }
        'a'c8 => { 10u64 }
        'b'c8 => { 11u64 }
        'c'c8 => { 12u64 }
        'd'c8 => { 13u64 }
        'e'c8 => { 14u64 }
        'f'c8 => { 15u64 }
        'A'c8 => { 10u64 }
        'B'c8 => { 11u64 }
        'C'c8 => { 12u64 }
        'D'c8 => { 13u64 }
        'E'c8 => { 14u64 }
        'F'c8 => { 15u64 }
        _ => { 0u64 }            
    }
}
