/**
 * This modules implement a set of functions named `to` that can be
 * used to convert data from a type to another. For example, the
 * function `to` can be used to transform a data to a string `to![c8]
 * (value)`. All the function for conversion are called `to`, with
 * some exceptions such as `toStringZ` that transform a Ymir string
 * into a null terminated string that can be used in a C program, and
 * `fromStringZ` that transform a C string into a string usable in
 * Ymir. This module mainly contains conversion functions from or to
 * string data, other module of the std provides conversion function
 * to other kind of data types such as <code class="hljs"><a href="./std_config_conv.html">std::config::conv</a></code>.
 * It is recommanded to use the name `to` when creating conversion
 * functions, in order to keep the same standard everywhere.
 *
 *  @Authors: Emile Cadorel
 * @License: GPLv3
 * <hr>
 * @example:
 * ```
 *
 * class A {
 *      let i : i32;
 *
 *      pub self (i : i32) with i = i {}
 *
 *      impl Streamable;
 * }
 *
 * let str_i = (89).to![c8] (); // transform a int into a [c8]
 * let str_f = (128.983f).to![c32] (); // transform a float into a [c32]
 *
 * // float conversion is not quite exact due to float encoding
 * // but the prec parameter allows the adjust the precision
 * // By the default the prec is set to 6
 * let str_f2 =  (128.983f).to![c32] (prec-> 12u32); // with 12 number after the decimal point
 *
 * println (str_i); // 89
 * println (str_f); // 128.983
 * println (str_f2); // 128.983001708984
 *
 * let str_hex = (7686u32).to!{[c8], "x"} (); // using hexadecimal form
 * let str_bit = (87192u32).to!{[c8], "b"} (); // using binary form
 * let str_oc = (234u32).to!{[c8], "o"} (); // using octal form
 * let str_19 = (10943).to!{[c8], 19us} (); // using arbitrary base
 * let str_d_sci = (18293.0).to!{[c32], "e"} (prec-> 2u32); // using scientific notation, default precision is 6
 *
 * println (str_hex); // "0x1e06"
 * println (str_bit); // "0b10101010010011000"
 * println (str_oc);  // "0o352"
 * println (str_19); // 1b5i, maximum base is 36 (10 digits + 26 letters)
 * println (str_d_sci); // 1.83e+04
 *
 * let float_s = "78.9872".to!f32 ()?; // transform a string into a f32
 * let i_s = "1452".to!i32 ()?; // transform a string into a i32
 * let h_s = "0xff".to!{u32, "x"} ()?; // transform a string from hex form to u32
 * let o_s = "0o128".to!{u32, "o"} ()?; // transform a string from octal form to u32
 * let b_s = "0b101101".to!{u32, "b"} ()?; // transform a string from binary form to u32
 * let arb_s = "189bz".to!{i32, 36us} ()?; // using arbitrary base (maximum being 36)
 *
 * // conversion from string might fail and throw CastFailure
 * println (float_s); // Ok (78.987198), float conversion is not quite exact due to float encoding system
 * println (i_s); // Ok (1452)
 * println (h_s); // Ok (255)
 * println (o_s); // Ok (88)
 * println (b_s); // Ok (45)
 * println (arb_s); // Ok (2064959)
 *
 * let f_i = (898172.0989178f).to!i32 (); // float to int
 * let i_f = f_i.to!f32 (); // int to float
 *
 * println (f_i); // 898172
 * println (i_f); // 898172.000000
 *
 * let str_a = A::new (76).to![c8] (); // streamable class are convertible to string [c8] and [c32]
 * println (str_a); // A(76)
 *
 * let decoded = ("Hello world, Καλημέρα κόσμε, コンニチハ").to![c32] (); // convert utf8 to utf32
 * let encoded = decoded.to![c8] (); // convert utf32 into utf8
 *
 * println (decoded.len, " ", decoded); // 34 Hello world, Καλημέρα κόσμε, コンニチハ
 * println (encoded.len, " ", encoded); // 59 Hello world, Καλημέρα κόσμε, コンニチハ
 * ```
 */

in conv;

use std::{io, stream, traits};
use std::conv::errors;


pub mod errors;
pub mod utf;

mod ::utils;

/*!
 * ====================================================================================================
 * ====================================================================================================
 * ============================          UNSIGNED INT CONVERSION          =============================
 * ====================================================================================================
 * ====================================================================================================
 */

/**
 * Transform a unsigned int into a string.
 * @example:
 * ```
 * let x = to![c32] (12u32);
 * let y = (879us).to![c8] ();
 *
 * assert (x == "12"s32 && y == "879");
 * ```
 */
pub fn if (isUnsigned!{F} && isChar!{U}) to {T of [U], U, F} (a : F) -> dmut T {
    alias to!{T, 10, F} (a)
}

/**
 * Transform a unsigned int into a string, using hexadecimal form.
 * @example:
 * ```
 * let x = to!{[c32], "x"} (12u32);
 * let y = (879us).to!{[c8], "x"} ();
 *
 * assert (x == "0xc" && y == "0x36f");
 * ```
 */
pub fn if (isUnsigned!{F} && isChar!{U}) to {T of [U], U, "x", F} (a : F, upper : bool = false) -> dmut T {
    let dmut res : T = copy cast!{T} ("0x");
    res ~= to!{T, 16, F} (a, upper-> upper);
    alias res
}

/**
 * Transform a unsigned int into a string, using binary format.
 * @example:
 * ```
 * let x = to!{[c32], "b"} (12u32);
 * let y = (879us).to!{[c8], "b"} ();
 *
 * assert (x == "0b1100" && y == "0b1101101111");
 * ```
 */
pub fn if (isUnsigned!{F} && isChar!{U}) to {T of [U], U, "b", F} (a : F) -> dmut T {
    let dmut res : T = copy cast!{T} ("0b");
    res ~= to!{T, 2, F} (a);
    alias res
}

/**
 * Transform a unsigned int into a string, using octal format.
 * @example:
 * ```
 * let x = to!{[c32], "o"} (12u32);
 * let y = (879us).to!{[c8], "o"} ();
 * assert (x == "0o14" && y == "0o1557");
 * ```
 */
pub fn if (isUnsigned!{F} && isChar!{U}) to {T of [U], U, "o", F} (a : F) -> dmut T {
    let dmut res : T = copy cast!{T} ("0o");
    res ~= to!{T, 8, F} (a);
    alias res
}

/**
 * Transform a unsigned int into a string, using the base `base`.
 * @template:
 *    - base: the base to use when converting the int to string.
 * @cteassert `(base <= 36)`
 * @example:
 * ```
 * let x = to!{[c32], 11us} (12u32);
 * let y = (879us).to!{[c8], 18us} ();
 *
 * assert (x == "11" && y == "2cf");
 * ```
 */
pub fn if (isUnsigned!{I} && isChar!{C} && isIntegral!{N}) to {T of [C], C, base : N, I, N} (a : I, upper : bool = false) -> dmut T {
    cte assert (36 >= base, "Maximum base is 36");

    if (a == 0) {
        return copy cast!{T} ("0");
    }

    let mut n = a;
    let mut len = 0us;
    while n > 0 {
        len += 1;
        n /= cast!I (base);
    }

    let dmut res = core::types::array::allocArray!(C) (len);
    let mut j : I = 1;
    for i in len .. 0us {
        res [i - 1us] = std::conv::utils::to!C ((a / j) % cast!{I} (base), cast!{I} (base), upper-> upper);
        j *= cast!{I} (base);
    }

    alias res
}

/*!
 * ====================================================================================================
 * ====================================================================================================
 * =============================          SIGNED INT CONVERSION          ==============================
 * ====================================================================================================
 * ====================================================================================================
 */

/**
 * Transform a signed int into a string, using base 10.
 * @example:
 * ```
 * let x = to![c32] (-12);
 * let y = (-7810).to![c8] ();
 *
 * assert (x == "-12" && y == "-7810");
 * ```
 */
pub fn if (isSigned!{F} && isChar!{U}) to {T of [U], U, F} (a : F) -> dmut [U] {
    alias to!{T, 10, F} (a)
}

/**
 * Transform a signed int into a string, using hexadecimal form.
 * @example:
 * ```
 * let x = to!{[c32], "x"} (12);
 * let y = (879is).to!{[c8], "x"} ();
 *
 * assert (x == "0xc" && y == "0x36f");
 * ```
 */
pub fn if (isSigned!{F} && isChar!{U}) to {T of [U], U, "x", F} (a : F, upper : bool = false) -> dmut [U] {
    let dmut res = to!{T, 16, F} (a, upper-> upper);
    if (res.len > 0 && res [0] == '-') {
        let dmut res2 : [U] = copy cast!{T} ("-0x");
        res2 ~= res [1 .. $];

        alias res2
    } else {
        let dmut res2 : [U] = copy cast!{T} ("0x");
        res2 ~= res;

        alias res2
    }
}

/**
 * Transform a signed int into a string, using binary format.
 * @example:
 * ```
 * let x = to!{[c32], "b"} (12);
 * let y = (879is).to!{[c8], "b"} ();
 *
 * assert (x == "0b1100" && y == "0b1101101111");
 * ```
 */
pub fn if (isSigned!{F} && isChar!{U}) to {T of [U], U, "b", F} (a : F) -> dmut [U] {
    let dmut res = to!{T, 2, F} (a);
    if (res.len > 0 && res [0] == '-') {
        let dmut res2 : [U] = copy cast!{T} ("-0b");
        res2 ~= res [1 .. $];

        alias res2
    } else {
        let dmut res2 : [U] = copy cast!{T} ("0b");
        res2 ~= res;

        alias res2
    }
}

/**
 * Transform a signed int into a string, using octal format.
 * @example:
 * ```
 * let x = to!{[c32], "o"} (12);
 * let y = (879is).to!{[c8], "o"} ();
 * assert (x == "0o14" && y == "0o1557");
 * ```
 */
pub fn if (isSigned!{F} && isChar!{U}) to {T of [U], U, "o", F} (a : F) -> dmut [U] {
    let dmut res = to!{T, 8, F} (a);
    if (res.len > 0 && res [0] == '-') {
        let dmut res2 : [U] = copy cast!{T} ("-0o");
        res2 ~= res [1 .. $];

        alias res2
    } else {
        let dmut res2 : [U] = copy cast!{T} ("0o");
        res2 ~= res;

        alias res2
    }
}

/**
 * Transform a signed int into a string, using base `base`.
 * @template:
 *    - base: the base to use when converting the int to string.
 * @cteassert `(base <= 36)`
 * @example:
 * ```
 * let x = to!{[c32], 7us} (-12);
 * let y = (-89102).to!{[c8], 21us} ();
 *
 * assert (x == "-15" aa y == "-9d0k");
 * ```
 */
pub fn if (isSigned!{I} && isChar!{C} && isIntegral!{N}) to {T of [C], C, base : N, I, N} (a : I, upper : bool = false) -> dmut T {
    cte assert (36 >= base, "Maximum base is 36 < " ~ base);

    if (a == 0)  {
        return copy cast!{T} ("0");
    }

    let (mut n, mut len, sign) = if (a < 0) {
        (-a, 0us, true)
    } else { (a, 0us, false) }

    while n > 0 {
        len += 1;
        n /= cast!I (base);
    }

    let mut j : I = 1;
    if (!sign) {
        let dmut res = core::types::array::allocArray!(C)(len);
        for i in len .. 0us {
            res [i - 1us] = std::conv::utils::to!C ((a / j) % cast!I (base), cast!I (base), upper);
            j *= cast!I (base);
        }

        return alias res;
    } else {
        let dmut res = core::types::array::allocArray!(C)(len + 1us);
        res [0] = '-';

        for i in len .. 0us {
            res [i] = std::conv::utils::to!C ((-a / j) % cast!I (base), cast!I (base), upper);
            j *= cast!I (base);
        }

        return alias res;
    }
}

/*!
 * ====================================================================================================
 * ====================================================================================================
 * ================================          STRING ENCODING          =================================
 * ====================================================================================================
 * ====================================================================================================
 */

/**
 * Decode and reencode a string into the correct utf format
 * @params :
 *   - s: a string in any utf
 * @returns: a string in another utf
 * @example:
 * ```
 * let encoded = ("Hello world, Καλημέρα κόσμε, コンニチハ").to![c8] (); // convert utf32 to utf8
 *
 * println (encoded.len, " ", encoded); // 59 Hello world, Καλημέρα κόσμε, コンニチハ
 *
 * let decoded = ("Hello world, Καλημέρα κόσμε, コンニチハ").to![c32] (); // convert utf8 to utf32
 * println (decoded.len, " ", decoded); // 34 Hello world, Καλημέρα κόσμε, コンニチハ
 * ```
 */
pub fn if (isChar!{IN} && isChar!{OUT}) to {T of [OUT], OUT, F of [IN], IN} (s : F)-> dmut T {
    cte if (IN::size == OUT::size) {
        return copy s;
    }

    else {
        let dmut s8 = cte if (is!{IN}{X of c8}) {
            copy s
        } else { utf::decode (s) };

        cte if (is!{OUT}{x of c8}) {
            return alias s8;
        } else {
            return utf::encode!{OUT} (s8);
        }
    }
}

/**
 * Transform a string into a slice of unsigned int.
 * @params:
 *    - s: an string
 * @example:
 * ```
 * let val = "😉";
 *
 * assert (val.to![u8] () == [0xf0u8, 0x9fu8, 0x98u8, 0x89u8]);
 * ```
 */
pub fn if (isChar!{C} && isUnsigned!{U} && U::size == C::size) to {OUT of [U], U, IN of [C], C} (s : IN)-> dmut OUT {
    let dmut res = core::types::array::allocArray!U (s.len);
    etc::c::memory::memcpy (cast!{*void} (res.ptr), cast!{*void} (s.ptr), res.len);

    alias res
}

/**
 * Transform a slice of unsigned int into string.
 * @params:
 *    - s: a slice
 * @example:
 * ```
 * let val = [0xf0u8, 0x9fu8, 0x98u8, 0x89u8];
 *
 * assert (val.to![c8] () == "😉");
 * ```
 * */
pub fn if (isChar!{C} && isUnsigned!{U} && U::size == C::size) to {OUT of [C], C, IN of [U], U} (s : IN)-> dmut OUT {
    let dmut res = core::types::array::allocArray!{C} (s.len);
    etc::c::memory::memcpy (cast!{*void} (res.ptr), cast!{*void} (s.ptr), res.len);

    alias res
}

/*!
 * ====================================================================================================
 * ====================================================================================================
 * =================================          FLOAT ENCODING          =================================
 * ====================================================================================================
 * ====================================================================================================
 */

/**
 * Transform a float into a string
 * @example:
 * ```
 * assert (to![c32] (12.8) == "12.8")
 * ```
 * */
pub fn if (isChar!{U} && isFloating!{F}) to {T of [U], U, F} (a : F, prec : u32 = 6u32) -> dmut T {
    let dmut str8 = cte if is!{F}{X of f32} {
        utils::_yrt_f32_to_string (a, prec)
    } else cte if is!{F}{X of f64} {
        utils::_yrt_f64_to_string (a, prec)
    } else cte if is!{F}{X of f80} {
        utils::_yrt_f80_to_string (a, prec)
    } else {
        utils::_yrt_fsize_to_string (a, prec)
    };

    cte if is!{U}{X of c8} {
        return alias str8;
    } else {
        return to!{T} (str8);
    }
}

/**
 * Transform a float into a string, using scientific notation.
 * @params:
 *     - prec: the number of digits after the decimal point.
 * @example:
 * ```
 * let f_s = (12.9834982f).to!{[c32], "e"} (prec-> 4u32);
 * let d_s = (81792.983).to!{[c8], "e"} (prec-> 1u32);
 *
 * assert (f_s == "1.2983e+01" && d_s == "8.2e+04");
 * ```
 */
pub fn if (isChar!{U} && isFloating!{F}) to {T of [U], U, "e", F} (a : F, prec : u32 = 6u32) -> dmut T {
    let dmut str8 = cte if is!{F}{X of f32} {
        utils::_yrt_f32_to_string_exp (a, prec)
    } else cte if is!{F}{X of f64} {
        utils::_yrt_f64_to_string_exp (a, prec)
    } else cte if is!{F}{X of f80} {
        utils::_yrt_f80_to_string_exp (a, prec)
    } else {
        utils::_yrt_fsize_to_string_exp (a, prec)
    };

    cte if is!{U}{X of c8} {
        return alias str8;
    } else {
        return to!{T} (str8);
    }
}

/*!
 * ====================================================================================================
 * ====================================================================================================
 * =================================          BOOL ENCODING          ==================================
 * ====================================================================================================
 * ====================================================================================================
 */

/**
 * Convert a bool into a string.
 * @example:
 * ```
 * assert (to![c8] (false) == "false")
 * ```
 */
pub fn if isChar!{U} to {T of [U], U, F of bool} (a : F)-> T {
    if (a) {
        cast!{T} ("true")
    } else {
        cast!{T} ("false")
    }
}

/*!
 * ====================================================================================================
 * ====================================================================================================
 * =================================          CLASS ENCODING          =================================
 * ====================================================================================================
 * ====================================================================================================
 */

/**
 * Transform a class or a record into a string.
 * @example:
 * ```
 * mod main;
 * class A {
 *     let i : i32;
 *     pub self (i : i32) with i = i {}
 *     impl Streamable;
 * }
 *
 * assert (A::new (789).to![c8] () == "main::A(789)");
 * ```
 */
pub fn if (isChar!{U} && (is!{F}{class C} || is!{F}{record C})) to {T of [U], U, F} (a : F)-> dmut T {
    let dmut stream = copy StringStream ();
    stream:.write (a);

    cte if is!{U}{X of c8} {
        return stream:[];
    } else {
        return std::conv::to!{T} (stream []);
    }
}

/**
 * Transform a record or an entity into a string.
 * @example:
 * ```
 * mod main;
 * record A {
 *    pub let x : i32;
 *    pub self (x : i32)
 *        with x = x
 *    {}
 * }
 *
 *
 * assert (A (12).to![c8] () == "main::A(12)");
 * ```
 */
pub fn if (isChar!{U} && (is!{F}{record R} || is!{F}{entity E})) to {T of [U], U, F} (ref a : F)-> dmut T {
    let dmut stream = copy StringStream ();
    stream:.write (a);

    cte if is!{U}{X of c8} {
        return stream:[];
    } else {
        return std::conv::to!{T} (stream []);
    }
}

/*!
 * ====================================================================================================
 * ====================================================================================================
 * =============================          STRING TO INT DECODING          =============================
 * ====================================================================================================
 * ====================================================================================================
 */

/**
 * Transform a string into a unsigned int.
 * @throws:
 *    - &CastFailure: if the string does not contain a valid u32 literal
 * @example:
 * ```
 * let x = ("12").to!u64 ();
 * let y = ("87").to!u32 ();
 *
 * assert (x == 12u64 && y == 87u32);
 * ```
 * @assume: the string is stripped, so the only possible char are [0-9]
 * @KnownBug: does not check the overflow capacity
 */
pub fn if (isUnsigned!{T} && isChar!{U}) to {T, F of [U], U} (str : F)-> T
    throws CastFailure
{
    to!{T, 10us, F} (str)
}

/**
 * Transform an hexadecimal string into a unsigned integer.
 * @throws:
 *    - &CastFailure: if the string does not contain a valid literal
 * @example:
 * ```
 * let x = ("0xff").to!{u64, "x"} ();
 * let y = ("0x14E").to!{u32, "x"} ();
 *
 * assert (x == 255u64 && y == 334u32);
 * ```
 * @KnownBug: does not check the overflow capacity
 */
pub fn if (isUnsigned!{T} && isChar!{U}) to {T, "x", F of [U], U} (str : F)-> T
    throws CastFailure
{
    if (str.len < 2us || (str [0us] != '0') || (str [1us] != 'x')) {
        throw copy CastFailure (T::typeinfo, [U]::typeinfo);
    }

    to!{T, 16us, F} (str[2us .. $])
}

/**
 * Transform a binary string into a unsigned integer.
 * @throws:
 *    - &CastFailure: if the string does not contain a valid literal
 * @example:
 * ```
 * let x = ("0b1001").to!{u64, "b"} ();
 * let y = ("0b1011").to!{u32, "b"} ();
 *
 * assert (x == 5u64 && y == 11u32);
 * ```
 * @KnownBug: does not check the overflow capacity
 */
pub fn if (isUnsigned!{T} && isChar!{U}) to {T, "b", F of [U], U} (str : F)-> T
    throws CastFailure
{
    if (str.len < 2us || str [0us] != '0' || str [1us] != 'b') {
        throw copy CastFailure (T::typeinfo, [U]::typeinfo);
    }

    to!{T, 2us, F} (str[2us .. $])
}

/**
 * Transform an octal string into a unsigned integer
 * @throws:
 *    - &CastFailure: if the string does not contain a valid literal
 * @example:
 * ```
 * let x = ("0o7777").to!{u64, "o"} ();
 * let y = ("0o1234").to!{u32, "o"} ();
 *
 * assert (x == 4095u64 && y == 668u32);
 * ```
 * @KnownBug: does not check the overflow capacity
 */
pub fn if (isUnsigned!{T} && isChar!{U}) to {T, "o", F of [U], U} (str : F)-> T
    throws CastFailure
{
    if (str.len < 2us || str [0us] != '0' || str [1us] != 'o') {
        throw copy CastFailure (T::typeinfo, [U]::typeinfo);
    }

    to!{T, 8us, F} (str[2us .. $])
}

/**
 * Transform a string into a unsigned integer form an arbitrary base `base`.
 * @throws:
 *    - &CastFailure: if the string does not contain a valid literal
 * @cteassert: `(base <= 36)`
 * @example:
 * ```
 * let a = ("12").to!{u64, 10us} ();
 * assert (a == 12u64);
 *
 * let x = ("1ku3").to!{u64, 31us} ();
 * assert (x == 49944u64);
 * ```
 * @KnownBug: does not check the overflow capacity
 */
pub fn if (isUnsigned!{T} && isChar!{U} && isIntegral!{N}) to {T, base : N, F of [U], U, N} (str : F)-> T
    throws CastFailure
{
    cte assert (36us >= base, "Maximum base is 36");

    let mut j = 1us;
    let mut res = 0us;
    for i in str.len .. 0us {
        res = res + (j * std::conv::utils::to!usize (str [i - 1us], base));
        j *= base;
    } catch {
        _ : &CastFailure => {
            throw copy CastFailure (T::typeinfo, [U]::typeinfo);
        }
    }

    cast!T (res)
}

/**
 * Transform a string into a signed integer.
 * @throws:
 *    - &CastFailure: if the string does not contain a valid i64 literal
 * @example:
 * ```
 * let x = ("-12").to!i64 ();
 * let y = ("89").to!i32 ();
 *
 * assert (x == -12i64 && y == 89);
 * ```
 * @KnownBug: does not check the overflow capacity
 */
pub fn if (isSigned!{T} && isChar!{U}) to {T, F of [U], U} (str : F)-> T
    throws CastFailure
{
    to!{T, 10, F} (str)
}

/**
 * Transform a string into a signed integer
 * @throws:
 *    - &CastFailure: if the string does not contain a valid i64 literal
 * @example:
 * ```
 * let x = ("-12").to!{i64, 10us} ();
 * let y = ("-1ku3").to!{i32, 31us} ();
 *
 * assert (x == -12i64 && y == -49944);
 * ```
 * @KnownBug: does not check the overflow capacity
 */
pub fn if (isSigned!{T} && isChar!{U} && isIntegral!{N}) to {T, base : N, F of [U], U, N} (str : F)-> T
    throws CastFailure
{
    cte assert (36 >= base, "Maximum base is 36");

    let mut j : T = 1;
    let mut res : T = 0;
    {
        for i in str.len .. 0us {
            if (i == 1us && str [i - 1us] == '-') {
                res = -res;
            } else {
                res += (j * std::conv::utils::to!{T} (str [i - 1us], cast!T (base)));
            }

            j *= base;
        }
    } catch {
        _ => throw copy CastFailure (F::typeinfo, T::typeinfo);
    }
    res
}

/*!
 * ====================================================================================================
 * ====================================================================================================
 * ================================          STRING TO FLOAT          =================================
 * ====================================================================================================
 * ====================================================================================================
 */

/**
 * Transform a string into a float.
 * @throws:
 *    - &CastFailure: if the string does not contain a valid f64 literal
 * @example:
 * ```
 * let x = ("-12.89").to!f64 ();
 * let y = ("89.12").to!f32 ();
 *
 * assert (x == -12.89 && y == 89.12f);
 * ```
 */
pub fn if (isFloating!{F} && isChar!{U}) to {F, T of [U], U} (str : T)-> F
    throws CastFailure
{
    let str8 = cte if is!{U}{X of c8} {
        str
    } else { to![c8] (str) };

    let mut succ = false;
    let res = cte if is!{F}{F of f32} {
        std::conv::utils::_yrt_string_to_f32 (str8, ref succ)
    } else cte if is!{F}{F of f64} {
        std::conv::utils::_yrt_string_to_f64 (str8, ref succ)
    } else cte if is!{F}{F of f80} {
        std::conv::utils::_yrt_string_to_f80 (str8, ref succ)
    } else {
        std::conv::utils::_yrt_string_to_fsize (str8, ref succ)
    };

    if !succ {
        throw copy CastFailure (T::typeinfo, [U]::typeinfo);
    }

    res
}

/*!
 * ====================================================================================================
 * ====================================================================================================
 * ================================          STRING TO C CONV          ================================
 * ====================================================================================================
 * ====================================================================================================
 */


/**
 * Create a zero terminated string from a [c8].
 * This function is useful when sending string to C programs. In Ymir there is not guarantee that string are ending with the character null.
 * @example:
 * ```
 * /*
 *  The standard C function to print to stdout
 * */
 * extern (C) fn printf (format : *c8, ...)-> void;
 *
 * // because of dcopy, now [c8] in no longer in the text but in the heap
 * // So it may not be ending with '\u{0}'.
 * let dmut fmt = dcopy "Printing %d and %s\n";
 *
 * // the string "test of ..." in located in the text, so it is ending with `\u{0}`
 * // No need to convert it
 * printf (fmt.toStringZ (), 89, "test of string in text".ptr);  // Printing 89 and test of string in text
 * ```
 */
pub fn toStringZ (a : [c8])-> *c8 {
    let dmut res = core::types::array::allocArray!(c8)(a.len + 1us);
    core::types::array::memCopy (a, alias res);
    {
        res [$ - 1] = '\u{0}';
    }

    res.ptr
}

/**
 * @params:
 *    - a: a null terminated string whose len might be wrong
 * @returns: a slice of a where the len is correctly set
 * @example:
 * ```
 * /*
 *   C function to read in a file
 *   @params:
 *       - buffer: the buffer to fill
 *       - len: the maximum len  that can be read
 *   @returns: the length that was read
 * */
 * extern (C) fn read (fd : i32, buffer : *c8, len : u32)-> i32;
 *
 * // Allocate a buffer
 * let dmut buf = ['\u{0}' ; new 255us];
 *
 * // Read in the buffer
 * let len = read (fd, buf.ptr, cast!u32 (buf.len));
 *
 * // slicing the buffer to the first occurence of `\u{0}`;
 * buf = fromStringZ (buf);
 *
 * assert (buf.len == cast!usize (len));
 * ```
 */
pub fn fromStringZ {U of [c8]} (a : U)-> [c8] {
    let mut len = 0us;
    for i in a {
        if (i == '\u{0}') break;;
        else len += 1us;
    }

    a [0us .. len]
}

/**
 * Transform a null terminated string acquired from C program into a Ymir string.
 * @params:
 *     - a: a null terminated string
 * @returns: a slice of a where the len is correctly set
 * @warning: this function is critical, it can throw SegFault, but it can also throw nothing but that does not necessarily mean it worked correctly. It is better to verify beforehand that the string that is passed to the function is correctly set.
 * @example:
 * ```
 * /*
 *    C function to get the value of a environment variable
 *  */
 * extern (C) fn getenv (len : u32)-> *c8;
 *
 * // Retreive the value from C language, and transform it in Ymir string
 * let value = getenv ("HOME".ptr).fromStringZ ();
 *
 * println (value, " ", value.len);
 * ```
 */
@unsafe
pub fn fromStringZ {U of *c8} (a : U)-> [c8] {
    let mut len = cast!usize (etc::c::memory::strlen (a));
    let dmut res = core::types::array::allocArray!(c8)(len);
    for i in 0us .. len {
        res [i] = *(a + i);
    }

    res
}
