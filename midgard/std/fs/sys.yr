/**
 * This module implements basic function to manipulate local filesystem, such as creating directories, deleting files, etc.
 * @Authors: Emile Cadorel
 * @License: GPLv3
 */

in sys;

use etc::runtime::{errno, env};
use etc::c::{dirent, files, memory};

use std::{io, stream, conv};

use std::fs::{path, iteration, errors};
use std::time::instant;

/**
 * Create the directory at path
 * @params:
 *   - path: the path of the new directory, absolute or relative to cwd
 *   - recursive: if true, create the parent directories if they don't exists
 *   - permission: set the permission of the created directory (default: 0o775)
 * @throws:
 *   - FsError: if there was an error in the creation of the directory, cf FsErrorCode
 * @example:
 * ========================
 * use std::fs::{sys, path};
 *
 * createDir (Path ("./some/dir"));
 * assert (isDir (Path ("./some/dir")));
 *
 * // Creation of directory can be recursive
 * createDir (Path ("./some/dir/and/some/sub/directories/"), recursive-> true);
 * assert (isDir (Path ("./some/dir/and/some/sub/directories/")));
 *
 * // Permission of created directory can be defined
 * createDir (Path ("./some/dir/small_permissions"), permission-> 0o600);
 * assert (isDir (Path ("./some/dir/small_permissions")));
 * ========================
 */
pub fn createDir (path : Path, recursive : bool = false, permission : i32 = 0o775)
    throws FsError
{
    let parent = path.parent ();
    if (isDir (parent)) {
        let code = etc::c::dirent::mkdir (path.toStr ().toStringZ (), permission);
        if (code == -1) {
            throw copy FsError (errors::to!{FsErrorCode} (errno ()), path.toStr ());
        }
    } else if (recursive) {
        {
            if (!parent.isEmpty ()) {
                createDir (parent, recursive-> true, permission-> permission);
            }
        } catch {
            FsError (code-> code) => {
                throw copy FsError (code, path.toStr ());
            }
        }
        etc::c::dirent::mkdir (path.toStr ().toStringZ (), permission);
    } else {
        throw copy FsError (FsErrorCode::PARENT_DONT_EXIST, path.parent ().toStr ());
    }
}


/**
 * Check for the existence of a directory
 * @params:
 *    - path: the path to the directory to access, absolute or relative to cwd
 * @returns:
 *     - true if the directory exists and is accessible
 *     - false if it does not exists or if it not a directory or current user does not have permission to access it
 * @example:
 * ========================
 * import std::fs::sys;
 * import std::fs::path; // for Path
 *
 * if isDir (Path ("./some/dir")) {
 *    println ("Directory exists");
 * } else {
 *    println ("Directory does not exists");
 * }
 * ========================
 */
pub fn isDir (path : Path)-> bool {
    let dir = opendir (path.toStr ().toStringZ ());
    if (dir != null) {
        closedir (dir);
        true
    } else {
        false
    }
}

/**
 * Remove a directory at a given path location
 * @params:
 *   - path: the path of the directory to remove
 *   - recursive: if true, remove the directory after removing all its content
 * @Warning: recursive deletion must be used very carefully
 * @throws:
 *    - FsError:
 *          + the directory is not empty, (and the removing is not recursive)
 *          + the user lacks the permission
 *          + the path does not exists
 *          + the path is not a directory
 *          + other reasons
 * @example:
 * ========================
 * use std::fs::{sys, path};
 *
 * removeDir (Path ("./some/dir"));
 * assert (!isDir (Path ("./some/dir")));
 * assert (isDir (Path ("./some")));
 * ========================
 */
pub fn removeDir (path : Path, recursive : bool = false)
    throws FsError
{
    if (isDir (path)) {
        if (recursive) {
            for i in readDir (path) match i {
                FsEntry (kind-> FsEntryKind::FILE, path-> p) => { removeFile (p); }
                FsEntry (kind-> FsEntryKind::DIR, path-> p) => {
                    removeDir (p, recursive-> true);
                }
                FsEntry (path-> p) => {
                    removeFsEntry (p);
                }
            }
        }

        if (etc::c::dirent::rmdir (path.toStr ().toStringZ ()) == -1) {
            throw copy FsError (errors::to!{FsErrorCode} (errno ()), path.toStr ());
        }
    } else {
        throw copy FsError (FsErrorCode::PARENT_DONT_EXIST, path.toStr ());
    }
}


/**
 * Copy the content of a directory into another location
 * @params:
 *    - src: the directory to copy
 *    - dst: the destination location
 *    - recursive: copy sub directories of srcrecursively
 *    - create: create the destination directory ? (if true, the creation is recursive)
 * @throws:
 *   - FsError:
 *      + The source directory does not exist
 *      + The destination directory does not exist, and `create` was set to false
 *      + Permission denied (either reading or writing)
 *      + other reasons
 * @example:
 * =====================
 * use std::fs::{sys, path};
 *
 * copyDir (Path ("./some/dir"), Path ("/tmp/some/other/dir"), recursive-> true, create-> true);
 * assert (isDir (Path ("/tmp/some/other/dir")));
 * =====================
 */
pub fn copyDir (src : Path, dst : Path, recursive : bool = false, create : bool = false)
    throws FsError
{
    if isDir (src) {
        if (create && !isDir (dst)) { createDir (dst, recursive-> true); }
        else if !isDir (dst) { throw copy FsError (FsErrorCode::PARENT_DONT_EXIST, dst.toStr ()); }
        for i in readDir (src) match i {
            FsEntry (kind-> FsEntryKind::FILE, path-> p) => { copyFile (p, dst.push (p.removePrefix (src))); }
            FsEntry (kind-> FsEntryKind::DIR, path-> p) => {
                createDir (dst.push (p.removePrefix (src)));
                if (recursive) copyDir (p, dst.push (p.removePrefix (src)), recursive-> true, create-> create);
            }
            FsEntry (path-> p) => {
                copyFsEntry (p, dst.push (p.removePrefix (src)));
            }
        }
    } else {
        throw copy FsError (FsErrorCode::PARENT_DONT_EXIST, src.toStr ());
    }
}

/**
 * @returns: an iterator over the entries of a directory
 * @example:
 * ===
 * import std::fs::{sys, path};
 *
 * // List entries of a directory
 * for entry in readDir (Path ("./some/dir")) {
 *     println (entry);
 * }
 * ===
 */
pub fn readDir (path : Path)-> FsEntry
    throws FsError
{
    if (isDir (path)) {
        return FsEntry (path, FsEntryKind::DIR);
    }

    throw copy FsError (errors::to!{FsErrorCode} (errno ()), path.toStr ())
}

/**
 * Create a temporary directory, and return its path
 * @params:
 *    - root: the path of the parent temporary directory in which the directory will be created
 *    - prefix: prefix to add at the beginning of the name of the temp directory
 * @returns: the path of the created temporary directory
 */
pub fn tempDirectory (root : Path = Path ("/tmp"), prefix : [c8] = "")-> Path
    throws FsError
{
    let template = root.push (prefix ~ "XXXXXX").toStr ();
    let res = etc::c::files::mkdtemp (template.toStringZ ());
    if (res != null) {
        unsafe {
            Path (res.fromStringZ ())
        }
    } else throw copy FsError (errors::to!{FsErrorCode} (errno ()), root.toStr ());
}

/**
 * Create a new file without openning it
 * @params:
 *    - name: the absolute path of the file (or relative to the execution)
 * @throws:
 *   - FsError:
 *         + the file already exists
 *         + permission denied
 *         + path is invalid
 * @example:
 * =================
 * use std::fs::{sys, path};
 *
 * createFile (Path ("./some/dir/file.txt"));
 * assert (isFile (Path ("./some/dir/file.txt"));
 * =================
 */
pub fn createFile (path : Path)
    throws FsError
{
    let f = etc::c::files::fopen (path.toStr ().toStringZ (), "w".ptr);
    if (f == null) {
        throw copy FsError (errors::to!(FsErrorCode) (errno ()), path.toStr ())
    }

    etc::c::files::fclose (f);
}


/**
 * @returns: the instant of last modification of a file
 * @throws: FsError, if the path does not refer to a file
 * @example:
 * ============
 * use std::fs::{sys, path};
 *
 * let path1 = Path ("./some/dir/file.txt");
 * let path2 = Path ("./some/dir/file2.txt");
 *
 * if (fileDate (path1) > fileDate (path2)) {
 *     println ("Path ", path2, " is older than ", path1);
 * }
 * ============
 */
pub fn fileDate (path : Path)-> std::time::instant::Instant
    throws FsError
{
    let mut fileStat = etc::c::files::stat_t ();
    let f = etc::c::files::stat (path.toStr ().toStringZ (), alias &fileStat);
    if (f != 0) {
        throw copy FsError (errors::to!{FsErrorCode} (errno ()), path.toStr ());
    }

    Instant (fileStat.st_mtime, 0u64)
}

/**
 * Check the existence of a file.
 * @params:
 *    - path: the path of the file, absolute or relative to cwd
 * @returns:
 *    - true if the file exists and is a file
 *    - false if the file does not exists or is not a file, or the current user does not have permission to access it
 * @example:
 * =================
 * use std::fs::_;
 *
 * if (isFile (Path ("./some/dir/file.txt"))) {
 *     println ("File exists");
 * }
 * =================
 */
pub fn isFile (path : Path)-> bool {
    etc::c::files::access (path.toStr ().toStringZ (), AccessMode::F_OK) == 0
}

/**
 * Check wether a file exists and is writable by the current user.
 * @params:
 *    - path: the path of the file, absolute or relative to cwd
 * @returns: true if the file exists and is writable
 * @example:
 * =================
 * use std::fs::_;
 *
 * if (isWritable (Path ("./some/dir/file.txt")) {
 *     println ("File is writable");
 * }
 * =================
 */
pub fn isWritable (path : Path)-> bool {
    etc::c::files::access (path.toStr ().toStringZ (), AccessMode::W_OK) == 0
}

/**
 * Check wether a file exists and is readable by the current user.
 * @params:
 *    - path: the path of the file, absolute or relative to cwd
 * @returns: true if the file exists and is readable
 * @example:
 * =================
 * use std::fs::_;
 *
 * if (isReadable (Path ("./some/dir/file.txt")) {
 *     println ("File is readable");
 * }
 * =================
 */
pub fn isReadable (path : Path)-> bool {
    etc::c::files::access (path.toStr ().toStringZ (), AccessMode::R_OK) == 0
}

/**
 * Check wether a file exists and is executable by the current user.
 * @params:
 *    - path: the path of the file, absolute or relative to cwd
 * @returns: true if the file exists and is executable
 * @example:
 * =================
 * use std::fs::_;
 *
 * if (isExecutable (Path ("./some/dir/file.txt")) {
 *     println ("File is readable");
 * }
 * =================
 */
pub fn isExecutable (path : Path)-> bool {
    etc::c::files::access (path.toStr ().toStringZ (), AccessMode::X_OK) == 0
}

/**
 * Remove a file from the file system
 * @params:
 *    - path: the path of the file, absolute or relative to cwd
 * @throws:
 *   - FsError:
 *       + the file does not exists
 *       + permission denied
 *       + this is not a file
 */
pub fn removeFile (path : Path)
    throws FsError
{
    if (isFile (path)) {
        if unlink (path.toStr ().toStringZ ()) == -1 {
            throw copy FsError (errors::to!{FsErrorCode} (errno ()), path.toStr ())
        }
    } else {
        throw copy FsError (FsErrorCode::PERMISSION_DENIED, path.toStr ())
    }
}

/**
 * Copy a file to another file location.
 * @params:
 *    - src: the path of the file to copy
 *    - dst: the path of the file created by the copy (path of the file, not of the parent directory)
 * @throws:
 *   - FsError:
 *      + the src file does not exists
 *      + the dst file already exists
 *      + permission denied
 *      + this is not a file
 * @example:
 * ===
 * use std::fs::{sys, path};
 *
 * assert (isFile (Path ("./some/dir/file.txt")));
 * assert (isDir (Path ("./some/other/dir")));
 *
 * copyFile (Path ("./some/dir/file.txt"), Path ("./some/other/dir/copy.txt"));
 * assert (isFile (Path ("./some/other/dir/copy.txt")));
 * ===
 */
pub fn copyFile (src : Path, dst : Path)
    throws FsError
{
    let dmut srcF = fs::file::File::open (src);
    let dmut dstF = fs::file::File::create (dst, write-> true);
    dstF:.write (srcF:.readAll ());
}

/**
 * Remove an entry from the file system that is neither a directory nor a file (e.g. a symbolic link).
 * @params:
 *    - path: the path of the fs entry to remove
 * @throws:
 *   - FsError:
 *       + the entry does not exists
 *       + permission denied
 *       + this is a file, or a dir
 */
pub fn removeFsEntry (path : Path)
    throws FsError
{
    if (!isDir (path) && !isFile (path)) {
        if unlink (path.toStr ().toStringZ ()) == -1 {
            throw copy FsError (errors::to!{FsErrorCode} (errno ()), path.toStr ())
        }
    } else {
        throw copy FsError (FsErrorCode::PERMISSION_DENIED, path.toStr ())
    }
}


/**
 * Copy a filesystem entry that is neither a directory nor a file (e.g. a symbolic link).
 * @params:
 *    - src: the path of the filesystem entry to copy
 *    - dst: the path of where to create the copy of the filesystem entry
 * @throws:
 *    - FsError:
 *       + the src does not exists
 *       + the dst already exists
 *       + permission denied
 *       + this is not a symbolic link
 *       + others
 */
pub fn copyFsEntry (src : Path, dst : Path)
    throws FsError
{
    if isReadable (dst) { throw copy FsError (FsErrorCode::ALREADY_EXISTS, dst.toStr ()); }
    if !isDir (src) && !isFile (src) {
        let dmut buf = ['\u{0}' ; 255us];
        if readlink (src.toStr ().toStringZ (), alias buf.ptr, 255) == -1 {
            throw copy FsError (errors::to!{FsErrorCode} (errno ()), src.toStr ());
        }

        if symlink (dst.toStr ().toStringZ (), buf.ptr) == -1 {
            throw copy FsError (errors::to!{FsErrorCode} (errno ()), src.toStr ());
        }
    }
}
