/**
 * This module implements the class Path, that is used to describe a path in a the filesystem.
 * @Authors: Emile Cadorel
 * @License: GPLv3
 * <hr>
 * @example:
 * ```
 * use std::fs::path;
 *
 * // Path are created from string, containing a path
 * let p = Path ("./some/dir");
 *
 * // A custom separator can be used
 * let c = Path (".\\some\\windows\\dir\\", sep-> "\\");
 * let m = Path ("std::fs::path", sep-> "::");
 *
 * // parts, return the elements composing the path
 * assert (c.parts () == [".", "some", "windows", "dir"]);
 * assert (m.parts () == ["std", "fs", "path"]);
 *
 * // append a sub element to a path
 * let fp = p.push ("some_file.txt");
 *
 * // append a path to a path from string, or a path
 * let sp = c.push ("another/path/str");
 * let sp2 = c.push (Path ("another/path/str"));
 *
 * assert (sp == sp2);
 *
 * // file returns the last element of the path
 * assert (fp.file () == "some_file.txt" && fp.parts () == [".", "some", "dir", "some_file.txt"]);
 *
 * // root returns the first element of the path
 * assert (fp.root () == ".");
 *
 * // path can be translated to string
 * assert (m.toStr () == "std/fs/path");
 *
 * // Or by using a custom separator
 * assert (m.toStr (sep-> "::") == "std::fs::path");
 * ```
 */
in path;

use std::{conv, stream};

pub record Path {

    // The content of the path
    let mut _parts : [[c8]] = [];

    /**
     * Create an empty path
     * */
    pub self () {}

    /**
     * Create a new path from a utf8 path.
     * @params:
     *    - path: the path to split
     *    - sep: the token used to split the path
     * @warning: the path does not keep track of the separator, it is up to the user to maintain a consistence with the separators (cf. self::push).
     * @complexity: O(n * m), where n is the number of char `path` and m the number of char in the separator
     * @example:
     * ```
     * use std::fs::path;
     *
     * // Create a path using the standard separator '/' ('\\' on windows)
     * let path = Path ("foo/bar/baz.txt");
     *
     * // parts lists the different component of the path
     * assert (path.parts () == ["foo", "bar", "baz.txt"]);
     * ```
     */
    pub self (path : [c8], sep : [c8] = __version WINDOWS { "\\" } else { "/" }) {
        let mut last = 0us;
        for i in 0us .. path.len {
            if path [i .. $].len >= sep.len {
                if path [i .. i + sep.len] == sep {
                    self:.intern_push (path [last .. i]);
                    last = i + sep.len;
                }
            }
        }

        if last != path.len {
            self:.intern_push (path [last .. $]);
        }
    }

    /**
     * Inner construction to avoid unnecessary copies.
     * @complexity: O(1)
     * @params:
     *    - parts: the parts of the path (aliased)
     * */
    prv self (parts : [[c8]])
        with _parts = parts
    {}

    /**
     * Transform the path into a string.
     * @complexity: O(n), where n is the number of char in the parts of the path
     * @example:
     * ```
     * use std::fs::path;
     *
     * let path = Path ("/foo/test.txt");
     *
     * // using the standard separator '/'
     * assert (path.toStr () == "/foo/test.txt");
     *
     * // Or using a custom separator '!'
     * assert (path.toStr (sep-> "!") == "!foo!test.txt");
     * ```
     */
    pub fn toStr (self, sep : [c8] = "/")-> [c8] {
        let dmut stream = copy std::stream::StringStream ();
        if (self._parts.len != 0us) {
            stream:.write (self._parts [0]);
            for i in self._parts [1 .. $] {
                stream:.write (sep, i);
            }
        }

        stream[]
    }

    /**
     * Compare two paths.
     * @params:
     *   - o: another path
     * @complexity: O(n), where n is the number of char in the parts of the path
     * @example:
     * ```
     * use std::fs::path;
     *
     * let p = Path ("/some/root/dir");
     * let p2 = Path ("/");
     *
     * assert (p != p2 && p == p2.push ("some/root/dir"));
     * ```
     */
    pub fn opEquals (self, ref o : Path)-> bool {
        self._parts == o._parts
    }

    /**
     * Compare two paths.
     * @params:
     *   - o: another path
     * @complexity: O(n), where n is the number of char in the parts of the path
     * @example:
     * ```
     * use std::fs::path;
     *
     * let p = Path ("/some/root/dir");
     * let p2 = Path ("/");
     *
     * assert (p != p2 && p == p2.push ("some/root/dir"));
     * ```
     */
    pub fn opEquals (self, o : Path)-> bool {
        self._parts == o._parts
    }

    /**
     * Append a path to the current path, from a string. The string is splitted according the to the separator of given as parameter.
     * @params:
     *    - path: the path to split and append to the path
     *    - sep: the token used to split the path
     * @warning: the separator of the current path is not kept in memory, it is up to the user to maintain a consistence with the separators.
     * @complexity: O(k + (n x m)), where k is the number of parts in the self path, and n being the number of char in the path string, and m being the number of char in the sep string
     * @example:
     * ```
     * use std::fs::path;
     *
     * let mut path = Path ("/");
     * path = path.push ("foo/bar/");
     * path = path.push ("test.txt");
     * assert (path.toStr () == "/foo/bar/test.txt");
     *
     * // Example of inconsistent separators, that create no problem for the class
     * // but has to be kept in mind by the user
     * let mut ipath = Path ("std::fs::path", sep-> "::");
     * ipath = ipath.push ("some::dir/some::file", sep-> "/");
     *
     * assert (ipath.parts () == ["std", "fs", "path", "some::dir", "some::file"]);
     * ```
     */
    pub fn push (self, path : [c8], sep : [c8] = __version WINDOWS { "\\" } else { "/" })-> Path {
        let mut result = self;
        {
            let mut last = 0us;
            for i in 0us .. path.len {
                if (path [i .. $].len >= sep.len) {
                    if (path [i .. i + sep.len] == sep) {
                        result:.intern_push (path [last .. i]);
                        last = i + sep.len;
                    }
                }
            }

            if (last != path.len) {
                result:.intern_push (path [last .. $]);
            }
        }

        result
    }

    /**
     * Append a path to the current path.
     * @params:
     *    - path: the path to append at the end of the current path.
     * @returns: a new Path being the concatenation of the two paths
     * @complexity: O(k + l), where k is the number of parts in the self path, and l the number of parts in the path to push
     * @example:
     * ```
     * use std::fs::path;
     *
     * let mut path = Path ("/");
     *
     * //  Pushing sub directories to the path (the last '/' is useless, and will be omitted)
     * path = path.push (Path ("foo/bar/"));
     *
     * // append a filename to the path (the fact that it is a filename is up to the user)
     * path = path.push (Path ("test.txt"));
     *
     * assert (path.toStr () == "/foo/bar/test.txt");
     * ```
     */
    pub fn push (self, ref path : Path) -> Path {
        let dmut aux = self;
        for i in path._parts {
            aux:.intern_push (i);
        }

        aux
    }

    /**
     * Append a path to the current path.
     * @params:
     *    - path: the path to append at the end of the current path.
     * @returns: a new Path being the concatenation of the two paths
     * @complexity: O(k + l), where k is the number of parts in the self path, and l the number of parts in the path to push
     * @example:
     * ```
     * use std::fs::path;
     *
     * let mut path = Path ("/");
     *
     * //  Pushing sub directories to the path (the last '/' is useless, and will be omitted)
     * path = path.push (Path ("foo/bar/"));
     *
     * // append a filename to the path (the fact that it is a filename is up to the user)
     * path = path.push (Path ("test.txt"));
     *
     * assert (path.toStr () == "/foo/bar/test.txt");
     * ```
     */
    pub fn push (self, path : Path) -> Path {
        let dmut aux = self;
        for i in path._parts {
            aux:.intern_push (i);
        }

        aux
    }

   /**
     * @returns: the parts composing the path.
     * @complexity: O(1)
     * @example:
     * ```
     * use std::fs::path;
     *
     * // Create an absolute path
     * let abs = Path ("/some/absolute/dir/test.txt");
     *
     * // Because path is absolute the first element of parts is an empty string
     * assert (abs.parts () == ["", "some", "absolute", "dir", "test.txt"]);
     *
     * // Create a relative path
     * let rel = Path ("./some/relative/dir/test.txt");
     *
     * // It is a relative path, it does not contain an empty string at first index of parts
     * assert (rel.parts () == [".", "some", "relative", "dir", "test.txt"]);
     * ```
     */
    pub fn parts (self)-> [[c8]] {
        self._parts
    }

    /**
     * @returns: true iif the path is absolute (defined from the root directory)
     * @warning: empty paths are considered relative
     * @complexity: O(1)
     * @example:
     * ```
     * use std::fs::path;
     * use std::env; // for currentDir
     *
     * let abs = Path ("/some/absolute/dir");
     * let rel = Path ("./some/relative/dir");
     *
     * assert (abs.isAbsolute () && !rel.isAbsolute ());
     *
     * // One can create an absolute path from a relative path using std::env::currentDir ()
     * let absFromRel = env::currentDir ().push (rel);
     * assert (absFromRel.isAbsolute ());
     * ```
     */
    pub fn isAbsolute (self)-> bool {
        if (self._parts.len > 0us) {
            self._parts [0us] == ""
        } else {
            true
        }
    }

    /**
     * @returns: true if a path is empty
     * @warning: an empty path is different from a absolute path pointing to root, as it contains not part when a root directory contains only one part being an empty string
     * @complexity: O(1)
     * @example:
     * ```
     * use std::fs::path;
     *
     * let root = Path ("/");
     * let cwd = Path (".");
     *
     * // There is no way to create an empty path from a constructor
     * // But we can get one using a function that returns an empty path (for example parent, or commonPrefix)
     * let empty1 = root.parent ();
     * let empty2 = cwd.parent ();
     *
     * assert (empty1.isEmpty () && empty2.isEmpty ());
     *
     * // root is not empty, it contains one empty component
     * assert (!cwd.isEmpty () && !root.isEmpty ());
     *
     * // Empty means it really contains nothing
     * assert (empty1.toStr () == "" && empty1.parts () == []);
     *
     * // Empty path can still be used to create valid paths
     * let notEmpty = empty1.push (".");
     * assert (!notEmpty.isEmpty () && notEmpty == cwd);
     *
     * ```
     */
    pub fn isEmpty (self)-> bool {
        self._parts.len == 0us
    }

    /**
     * Create a new path pointing to the parent directory of the current path.
     * @warning:
     *     - if the current path is empty, then parent path is also empty, thus in that case self.parent () == self.
     *     - parents of root path and of paths containing only one element, are empty paths.
     * @complexity: O(k - 1), with k being the number of parts in the path
     * @example:
     * ```
     * use std::fs::path;
     *
     * let path = Path ("/foo/bar/baz.txt");
     *
     * // Parent remove the last component of a path
     * let parent = path.parent ();
     *
     * assert (parent.toStr () == "/foo/bar");
     *
     * // A root path has an empty parent directory (empty does not mean root, it means empty)
     * let root = Path ("/");
     * assert (root.parent ().toStr () == "" && root.parent ().isEmpty ());
     * ```
     */
    pub fn parent (self)-> Path {
        if (self._parts.len == 0us) {
            self
        } else {
            Path (self._parts [0 .. $ - 1])
        }
    }

    /**
     * @returns: the file name of the current path.
     * @warning: does not verify that it actually points to a file, you can assume that it just returns self.parts ()[$ - 1us] when self.parts().len != 0us, and empty otherwise.
     * @complexity: O(1)
     * @example:
     * ```
     * use std::fs::path;
     *
     * let path = Path ("/foo/bar/baz.txt");

     * // The filename is the last component of a path
     * assert (path.file () == "baz.txt");
     *
     * // In case of empty path the file is simply empty
     * let empty = Path ("/").parent ();
     * assert (empty.file () == "");
     * ```
     */
    pub fn file (self)-> [c8] {
        if (self._parts.len > 0us) {
            return self._parts [$ - 1us];
        }

        ""
    }

    /**
     * @returns: the root name of the current path.
     * @info:
     *    - it returns the first element of the parts of the path, self.parts()[0us] when self.parts().len != 0us.
     *    - it returns an empty string if the path is empty.
     * @complexity: O(1)
     * @example:
     * ```
     * use std::fs::path;
     *
     * let path = Path ("/foo/bar/baz.txt");
     *
     * // root dir is defined by an empty part string at first index
     * assert (path.root () == "");
     *
     * let path2 = Path ("foo/bar");
     * assert (path2.root () == "foo");
     *
     * // Empty path root is undefined, but for convinience it just return an empty string
     * let empty = Path ("/").parent ();
     * assert (empty.root () == "");
     * ```
     */
    pub fn root (self)-> [c8] {
        if (self._parts.len > 0us) {
            return self._parts [0us];
        }

        ""
    }

    /**
     * @params:
     *    - sep: the token describing an extension (`"."s8` by default)
     * @returns: a new path where the extension of the file has been removed.
     * @complexity: O(n + k) with n being the len of the file part of the path, and k being the number of component of the path
     * @example:
     * ```
     * use std::fs::path;
     *
     * let path = Path ("/foo/bar/baz.txt");
     *
     * // Remove the .txt extension
     * assert (path.stripExtension ().file () == "baz");
     *
     * let path2 = Path ("/foo/bar/baz.tar.gz");
     *
     * // Remove the .gz extension an keep the .tar one
     * assert (path2.stripExtension ().file () == "baz.tar");
     *
     * let path3 = Path ("/foo/bar/baz");
     *
     * // Path has no extension, so it does nothing
     * assert (path3.stripExtension ().file () == "baz");
     *
     * let path4 = Path ("/foo/bar/baz::txt");
     *
     * // Using a custom token as extension delimiter, to remove ::txt extension
     * assert (path4.stripExtension (sep-> "::").file () == "baz");
     * ```
     */
    pub fn stripExtension (self, sep : [c8] = ".")-> Path {
        if (self._parts.len == 0us) { return self; }

        let mut aux = Path (self._parts [0 .. $ - 1]);
        let mut file = self._parts [$ - 1us];
        if file.len > 0us {
            for i in 1us .. file.len {
                if (file [$ - i .. $].len >= sep.len) {
                    if (file [$ - i .. $ - i + sep.len] == sep) {
                        file = file [0us .. $ - i];
                        break {}
                    }
                }
            }
        }

        aux:.intern_push (file);
        aux
    }

    /**
     * @params:
     *    - sep: the token describing an extension (`"."` by default)
     * @returns: the extension of the file of the path.
     * @complexity: O(n) with n being the len of the file part of the path
     * @example:
     * ```
     * use std::fs::path;
     *
     * let path = Path ("/foo/bar/baz.txt");
     * assert (path.extension () == "txt");
     *
     * let path2 = Path ("/foo/bar/baz.tar.gz");
     * assert (path2.extension () == "gz");
     *
     * // If path has no extension, simply return an empty string
     * let path3 = Path ("/foo/bar/baz");
     * assert (path3.extension () == "");
     *
     * // A custom extension separator can be used
     * let path4 = Path ("/foo/bar/baz::txt");
     * assert (path4.extension (sep-> "::") == "txt");
     * ```
     */
    pub fn extension (self, sep : [c8] = ".")-> [c8] {
        let file = self.file ();
        if (file.len != 0us) {
            for i in 0us .. file.len {
                if (file [$ - i .. $].len >= sep.len) {
                    if (file [$ - i .. $ - i + sep.len] == sep) {
                        return file [($ - i + sep.len) .. $];
                    }
                }
            }
        }

        ""
    }

    /**
     * Add an new extension to the file of a path.
     * @params:
     *    - ext: the extension to add to the file part of the path.
     *    - sep: the separator to use when adding the extension ("." by default)
     * @complexity: O(n + k), where n is the len of the file part of the path, and k is the number of parts in the path
     * @example:
     * ```
     * use std::fs::path;
     *
     * let path = Path ("/foo/bar/baz").addExtension ("txt");
     * assert (path.file () == "baz.txt");
     *
     * let path2 = Path ("/foo/bar/baz.tar").addExtension ("gz");
     * assert (path2.file () == "baz.tar.gz");
     *
     * // empty path are not empty after adding an extension to them
     * let empty = Path ("").parent ().addExtension ("empty");
     * assert (empty.file  () == ".empty");
     * ```
     */
    pub fn addExtension (self, ext : [c8], sep : [c8] = ".")-> Path {
        if (self._parts.len > 0) {
            let mut aux = Path (self._parts [0 .. $ - 1]);
            let mut file = self.file ();
            aux:.intern_push (file ~ sep ~ ext);
            aux
        } else {
            let mut aux = Path ();
            aux:.intern_push (sep ~ ext);

            aux
        }
    }

    /**
     * Remove a prefix path to the current path. This function can be useful to create relative paths.
     * @params:
     *    - prefix: the prefix path to remove from the current path
     * @info: does nothing if `prefix` is not a prefix of self.
     * @returns: a new path with the prefix removed.
     * @complexity: O (k), where k is the number of parts in the self path
     * @example:
     * ```
     * use std::fs::path;
     *
     * let root = Path ("/foo/bar");
     * let subPath = Path ("/foo/bar/baz/file.txt");
     *
     * let cwd = Path ("./");
     * let relativePath = subPath.removePrefix (root);
     *
     * // Create a new relative path from "./"
     * assert (cwd.push (relativePath).toStr () == "./baz/file.txt");
     * ```
     */
    pub fn removePrefix (self, prefix : Path)-> Path {
        if (self._parts.len < prefix._parts.len) return self;

        for i in 0us .. prefix._parts.len {
            if (prefix._parts [i] != self._parts [i]) {
                return self;
            }
        }

        let parts = copy [self._parts [i] for i in prefix._parts.len .. self._parts.len];
        Path (parts)
    }

    /**
     * @returns: true iif the self path is a prefix of subPath
     * @warning: an empty path is considered to be the prefix of every possible paths
     * @complexity: O(k), where k is the number of parts in the self path
     * @example:
     * ```
     * use std::fs::path;
     *
     * let root = Path ("/some/absolute/path");
     * let abs = Path ("/some/absolute/path/with/some/dirs");
     * let rel = Path ("./some/relative/dir");
     *
     * assert (root.isPrefix (abs) && !root.isPrefix (rel));
     *
     * // A path is a prefix of itself
     * assert (root.isPrefix (root) && rel.isPrefix (rel));
     * ```
     */
    pub fn isPrefix (self, subPath : Path)-> bool {
        if (self._parts.len > subPath._parts.len) return false;

        for i in 0us .. self._parts.len {
            if (subPath._parts [i] != self._parts [i]) {
                return false;
            }
        }

        true
    }

    /**
     * @returns: A parent path that is common to self and other
     * @complexity: O(k), where k is the minimum number of parts in the self path and other path
     * @example:
     * ```
     * use std::fs::path;
     *
     * let abs1 = Path ("/some/absolute/path/leading/to/dir/1");
     * let abs2 = Path ("/some/absolute/path/with/other/dirs");
     *
     * assert (abs1.commonPrefix (abs2) == Path ("/some/absolute/path"));
     *
     * // This is a commutative operation
     * assert (abs1.commonPrefix (abs2) == abs2.commonPrefix (abs1));
     *
     * // Evidently commonPrefix returns a prefix (when not empty)
     * assert (abs1.commonPrefix (abs2).isPrefix (abs1));
     * assert (abs1.commonPrefix (abs2).isPrefix (abs2));
     *
     *
     * let root = Path ("/");
     * let cwd = Path (".");
     *
     * // If there is no common prefix an empty path is returned
     * assert (root.commonPrefix (cwd).isEmpty ());
     *
     * // In that case it is still a prefix to root nor cwd
     *  assert (root.commonPrefix (cwd).isPrefix (root));
     * ```
     */
    pub fn commonPrefix (self, other : Path)-> Path {
        let min = std::algorithm::comparison::min (self._parts.len, other._parts.len);
        let mut len = 0us;
        for i in 0us .. min {
            if self._parts [i] != other._parts [i] {
                len = i;
                break {}
            }
        }

        if (len != 0) {
            let parts = copy [self._parts [i] for i in 0us .. len];
            let mut aux = Path (parts);
            aux
        } else {
            Path ()
        }
    }

    /**
     * Remove the root of the path.
     * @info: does nothing if `self` is empty.
     * @complexity: O(k), where k is the number of parts in the self path
     * @example:
     * ```
     * use std::fs::path;
     *
     * let p = Path ("/path/to/somewhere");
     * let d = Path ("path/to/somewhere");
     *
     * assert (p.removeRoot ().toStr () == "path/to/somewhere");
     * assert (d.removeRoot ().toStr () == "to/somewhere");
     * ```
     */
    pub fn removeRoot (self)-> Path {
        if (self._parts.len != 0us) {
            let parts = copy [self._parts [i] for i in 1 .. self._parts.len];
            Path (parts)
        } else {
            Path ()
        }
    }


    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ======================================          MISC          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    impl Streamable {
        pub over toStream (self, dmut stream : &StringStream) {
            stream:.write ("Path (");
            if (self._parts.len != 0us) {
                stream:.write (self._parts [0]);
                for i in self._parts [1 .. $] {
                    stream:.write ('/', i);
                }
            }
            stream:.write (')');
        }
    }

    impl core::types::Hashable;

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          PRIVATE          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Push a file at the end of the path
     * */
    prv fn intern_push (mut self, v : [c8]) {
        self._parts = self._parts ~ copy [v];
    }

}
