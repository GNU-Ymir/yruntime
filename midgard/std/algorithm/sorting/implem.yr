/**
 * Module containing the implementation of the quicksort algorithms.
 * @authors: Emile Cadorel
 * @license: GPLv3
 */

in implem;

/**
 * Implementation of the quicksort algorithm.
 * @params:
 *    - a: the slice to sort
 * @templates:
 *    - F: the predicate to use to sort the array
 */
fn quicksort {F : fn (U, U)-> bool, T of [U], U} (mut a : mut [mut U]) {
    if (a.len < 2us) return {};

    let pivot = a[a.len / 2us];
    let mut i = 0us, mut j = a.len - 1us;
    loop {
        while (F (a[i], pivot)) {
            if (i == a.len) return {}
            i += 1us;
        }

        while (F (pivot, a[j])) {
            if (j == 0us) return {}
            j -= 1us;
        }

        if (i >= j) break {}

        let temp = a[i];
        a[i] = a[j];
        a[j] = temp;

        i += 1us;
        j -= 1us;
    }

    quicksort (a [0us .. i]);
    quicksort (a [i .. $]);
}

/**
 * Quick sort without predicate.
 * @params:
 *   - a: the slice to sort
 */
fn quicksort_simple {T of [U], U} (mut a : mut [mut U]) {
    if (a.len < 2us) return {};

    let pivot = a[a.len / 2us];
    let mut i = 0us, mut j = a.len - 1us;
    loop {
        while (a[i] < pivot) i += 1us;
        while (pivot < a[j]) j -= 1us;

        if (i >= j) break {}

        let temp = a[i];
        a[i] = a[j];
        a[j] = temp;

        i += 1us;
        j -= 1us;
    }

    quicksort_simple (a [0us .. i]);
    quicksort_simple (a [i .. $]);
}
