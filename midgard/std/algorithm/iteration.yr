/**
 * Module containing generic iteration algorithms.
 * @authors: Emile Cadorel
 * @license: GPLv3
 */

in iteration;

/**
 * Implement the homonym function fold
 * @returns: the accumulation of the slice and the initial seed
 * @example:
 * ===============
 * let i = copy [1, 2, 3, 4];
 * assert (i.fold!{|x,y| => x + y} () == 10?);
 * assert (i.fold!{|x,y| => x * y} () == 24?);
 * ===============
 * @complexity: O (n), with n = a.len
 */
pub fn fold {F : fn (U, U)-> U, T of [U], U} (a : T)-> U? {
    if (a.len > 0) {
        let mut res = a [0];
        for i in a [1 .. $] {
            res = F (res, i);
        }

        res?
    } else {
        none
    }
}

/**
 * Implement the homonym function fold
 * @returns: the accumulation of the slice and the initial seed
 * @example:
 * ===============
 * let i = copy [1, 2, 3, 4];
 * assert (i.fold (|x,y| => x + y) == 10);
 * assert (i.fold (|x,y| => x * y) == 24);
 * ===============
 * @complexity: O (n), with n = a.len
 */
pub fn fold {T of [U], U} (a : T, func : fn (U, U)-> U)-> U? {
    if (a.len > 0) {
        let mut res = a [0];
        for i in a [1 .. $] {
            res = func (res, i);
        }

        res?
    } else {
        none
    }
}

/**
 * Implement the homonym function fold
 * @returns: the accumulation of the slice and the initial seed
 * @example:
 * ===============
 * let i = copy [1, 2, 3, 4];
 * let z = 2;
 *
 * let a = i.fold (copy |x,y| => x + y + z); // 1 + (2 + 2) + (3 + 2) + (4 + 2)
 * let b = i.fold (copy |x,y| => {
 *      if (y % z == 1) { x + y } else { x }
 * }); // 1 + 3
 *
 * assert (a == 16?);
 * assert (b == 4?);
 * ===============
 * @complexity: O (n), with n = a.len
 */
pub fn fold {T of [U], U} (a : T, func : dg (U, U)-> U)-> U? {
    if (a.len > 0) {
        let mut res = a [0];
        for i in a [1 .. $] {
            res = func (res, i);
        }

        res?
    } else {
        none
    }
}

/**
 * Implement the homonym function fold
 * @returns: the accumulation of the slice and the initial seed
 * @example:
 * ===============
 * let i = [1, 2, 3, 4];
 * assert (i.fold!{|x,y| => x + y} () == 10);
 * assert (i.fold!{|x,y| => x * y} () == 24);
 * ===============
 * @complexity: O (n), with n = a.len
 */
pub fn if (N > 0) fold {F : fn (U,U)-> U, T of [U ; N], U, N : usize} (a : T)-> U {
    let mut res = a [0];
    for i in a [1 .. $] {
        res = F (res, i);
    }

    res
}

/**
 * Implement the homonym function fold
 * @returns: the accumulation of the slice and the initial seed
 * @example:
 * ===============
 * let i = [1, 2, 3, 4];
 * assert (i.fold (|x,y| => x + y) == 10);
 * assert (i.fold (|x,y| => x * y) == 24);
 * ===============
 * @complexity: O (n), with n = a.len
 */
pub fn if (N > 0) fold {T of [U ; N], U, N : usize} (a : T, func : fn (U, U)-> U)-> U {
    let mut res = a [0];
    for i in a [1 .. $] {
        res = func (res, i);
    }

    res
}

/**
 * Implement the homonym function fold
 * @returns: the accumulation of the slice and the initial seed
 * @example:
 * ===============
 * let i = [1, 2, 3, 4];
 * let z = 1;
 * let a = i.fold (copy |x,y| => x + y + z); // 1 + (2 + 2) + (3 + 2) + (4 + 2)
 * let b = i.fold (copy |x,y| => {
 *    if (y % z == 1) { x + y } else { x }
 * }); // 1 + 3
 *
 * assert (a == 16);
 * assert (b == 4);
 * ===============
 * @complexity: O (n), with n = a.len
 */
pub fn if (N > 0) fold {T of [U ; N], U, N : usize} (a : T, func : dg (U, U)-> U)-> U {
    let mut res = a [0];
    for i in a [1 .. $] {
        res = func (res, i);
    }

    res
}
