/**
 * Module containing generic iteration algorithms.
 * @authors: Emile Cadorel
 * @license: GPLv3
 */

in iteration;

// /**
//  * Implement the homonym function fold
//  * This function takes a seed as initial value, the seed is set at U::init as default
//  * Then it traverse the slice and for each element x of the slice result = F (result, x)
//  * @info: the operation of the accumulator F, does not need to be commutative
//  * @returns: the accumulation of the slice and the initial seed
//  * @example:
//  * ===============
//  * let i = [1, 2, 3];
//  * assert (i.scan!{|x,y| x + y} (0) == 6);
//  * assert (i.scan!{|x,y| x + y} (12) == 18);
//  * ===============
//  * @complexity: O (n), with n = a.len
//  */
// pub fn fold {F : fn (U,U)-> U, T of [U], U} (a : T, seed : U)-> U {
//     let mut res = seed;
//     for i in a {
//         res = F (res, i);
//     }
//     res
// }

// /**
//  * Implement the homonym function fold
//  * This function takes a seed as initial value, the seed is set at U::init as default
//  * Then it traverse the slice and for each element x of the slice result = F (result, x)
//  * @info: the operation of the accumulator F, does not need to be commutative
//  * @returns: the accumulation of the slice and the initial seed
//  * @example:
//  * ===============
//  * let i = [1, 2, 3];
//  * assert (i.scan!{|x,y| x + y} (0) == 6);
//  * assert (i.scan!{|x,y| x + y} (12) == 18);
//  * ===============
//  * @complexity: O (n), with n = a.len
//  */
// pub fn fold {F : fn (U,U)-> U, T of [U], U} (a : T)-> U {
//     let mut res = cte if (is!U (X of f32)) 0.f else cte if (is!U (X of f64)) 0.0 else U::init;
//     for i in a {
//         res = F (res, i);
//     }
//     res
// }

// /**
//  * Implement the homonym function fold
//  * This function takes a seed as initial value
//  * Then it traverse the slice and for each element x of the slice result = F (result, x)
//  * @info: the operation of the accumulator F, does not need to be commutative
//  * @returns: the accumulation of the slice and the initial seed
//  * @example:
//  * ===============
//  * let i = [1, 2, 3];
//  * assert (i.scan!{|x,y| x + y} (0) == 6);
//  * assert (i.scan!{|x,y| x + y} (12) == 18);
//  * ===============
//  * @complexity: O (n), with n = a.len
//  */
// pub fn fold {F : fn (U,U)-> U, T impl Seq!U, U} (a : T, seed : U)-> U {
//     let mut res = seed;
//     for i in a {
//         res = F (res, x);
//     }
//     res
// }

// /**
//  * Implement the homonym function fold
//  * This function set a initial result at U::init (or 0.0 if U is a float type) as default
//  * Then it traverse the slice and for each element x of the slice result = F (result, x)
//  * @info: the operation of the accumulator F, does not need to be commutative
//  * @returns: the accumulation of the slice and the initial seed
//  * @example:
//  * ===============
//  * let i = [1, 2, 3];
//  * assert (i.scan!{|x,y| x + y} () == 6);
//  * let j = [1., 2., 3.0];
//  * assert (i.scan!{|x,y| x + y} () == 6.0);
//  * ===============
//  * @complexity: O (n), with n = a.len
//  */
// pub fn fold {F : fn (U,U)-> U, T impl Seq!U, U} (a : T)-> U {
//     let mut res = cte if (is!U (X of f32)) 0.f else cte if (is!U (X of f64)) 0.0 else U::init;
//     for i in a {
//         res = F (res, x);
//     }
//     res
// }
