in env;

use etc;
use std::fs::path;
use std::net::addr;

@final
pub class EnvironmentError over core::exception::Exception {

    let _msg : [c8];

    pub self (msg : [c8])
        with _msg = msg
    {}

    @field
    pub fn msg (self)-> [c8] {
        self._msg
    }

}


/**
 * @returns: the list of arguments passed to the program.
 * @info: this arguments are traditionnaly passed to the main function
 * @example:
 * ```
 * use std::env;
 *
 * fn main (args : [[c8]])
 *     throws AssertError
 * {
 *    assert (env::args () == args);
 * }
 * ```
 */
pub fn args () -> [[c8]] {
    etc::runtime::env::_yrt_get_main_args ()
}

/**
 * @returns: the current working directory path
 * @info:
 * the path is empty if the current directory is invalid, possible explanation :
 *   - not sufficiant rights to access current working dir
 *   - the current working dir does not exists
 */
pub fn currentDir () -> Path {
    Path (etc::runtime::env::_yrt_get_current_dir ())
}

/**
 * Change the working directory
 * @params:
 *    - path: the path of the new current dir (relative to actual current dir, or an absolute path)
 * @throws:
 *   - &EnvironmentError: if the operation failed (e.g. due to permission problems, directory does not exists, etc.)
 * @example:
 * ```
 * use std::fs::path; // for Path
 * use std::env;
 *
 * setCurrentDir (Path ("/tmp/"));
 * assert (currentDir ().toStr () == "/tmp");
 * ```
 */
pub fn setCurrentDir (path : Path)
    throws EnvironmentError
{
    if (etc::c::env::chdir (std::conv::toStringZ (path.toStr ())) != 0) {
        throw copy EnvironmentError ("failed to change working directory to : " ~ path.toStr ());
    }
}

/**
 * Change the working directory
 * @params:
 *    - path: the path of the new current dir (relative to actual current dir, or an absolute path)
 * @throws:
 *   - &EnvironmentError: if the operation failed (e.g. due to permission problems, directory does not exists, etc.)
 * @example:
 * ```
 * use std::fs::path; // for Path
 * use std::env;
 *
 * setCurrentDir (Path ("/tmp/"));
 * assert (currentDir ().toStr () == "/tmp");
 * ```
 */
pub fn setCurrentDir (ref path : Path)
    throws EnvironmentError
{
    if (etc::c::env::chdir (std::conv::toStringZ (path.toStr ())) != 0) {
        throw copy EnvironmentError ("failed to change working directory to : " ~ path.toStr ());
    }
}

/**
 * @returns: the content of an environment variable
 * @example:
 * ```
 * use std::io; // for println
 * use std::env;
 *
 * // Retreive the environment variable HOME
 * let home_dir = getVar ("HOME");
 *
 * // For the user alice
 * println (home_dir); // /home/alice
 * ```
 */
@unsafe
pub fn getVar (name : [c8])-> [c8] {
    let content = etc::c::env::getenv (std::conv::toStringZ (name));
    if (content == null) {
        ""
    } else {
        copy std::conv::fromStringZ (content)
    }
}

/**
 * Set the value of an environment variable.
 * @params:
 *    - name: the name of the variable to set
 *    - value: the value to associate to the environment variable
 * @example:
 * ```
 * use std::io; // for println
 * use std::env;
 *
 * env::setVar ("KEY", "VALUE");
 * assert (env::getVar ("KEY") == "VALUE");
 * ```
 */
pub fn setVar (name : [c8], value : [c8]) {
    etc::c::env::setenv (std::conv::toStringZ (name), std::conv::toStringZ (value), 1);
}

/**
 * Remove an environment variable
 * @params:
 *    - name: the name of the variable to remove
 * @example:
 * ```
 * use std::io; // for println
 * use std::env;
 *
 * env::setVar ("KEY", "VALUE");
 * assert (env::getVar ("KEY") == "VALUE");
 *
 * env::removeVar ("KEY");
 * assert (env::getVar ("KEY") == "" && !env::isVarSet ("KEY"));
 * ```
 */
pub fn removeVar (name : [c8]) {
    etc::c::env::unsetenv (std::conv::toStringZ (name));
}

/**
 * @returns: `true` if the environment variable `name` is set
 * @example:
 * ```
 * use std::io; // for println
 * use std::env;
 *
 * env::setVar ("KEY", "VALUE");
 * assert (env::isVarSet ("KEY"));
 *
 * env::removeVar ("KEY");
 * assert (!env::isVarSet ("KEY"));
 * ```
 */
pub fn isVarSet (name : [c8])-> bool {
    let content = etc::c::env::getenv (std::conv::toStringZ (name));
    content == null
}

/**
 * @returns: the name of the current user
 * @example:
 * ```
 * use std::io;  // for println
 * use std::env;
 *
 * // For the user alice
 * println (whoami ()); // alice
 * ```
 */
@unsafe
pub fn whoami () -> [c8] {
    getVar ("USER")
}

/**
 * List network interfaces of the machine and return their associated ips
 * @example:
 * ```
 * use std::env;
 *
 * let ifaces = getIpInterfaces ();
 * if let Ok (fc) = ifaces ["lo"] {
 *    println (fc); // [127.0.0.1, ::1]
 * }
 * ```
 * * */
@unsafe
pub fn getIpInterfaces ()-> [[c8] => [&IpAddr]] {
    use etc::c::socket;

    let mut result : [[c8] => mut [mut &IpAddr]] = copy [];
    let mut list : *ifaddrs = null;
    let mut ifa : *ifaddrs = null;
    if (getifaddrs (&list) != 0) return result; // no interfaces?

    ifa = list;
    while ifa != null {
        if ifa [0].ifa_addr != null {
            let name = std::conv::fromStringZ (ifa [0].ifa_name);

            if (ifa [0].ifa_addr [0].sin_family == AddressFamily::AF_INET) {
                let addr = cast!{*sockaddr_in} (ifa [0].ifa_addr) [0];
                let h = addr.sin_addr.s_addr;
                let pack : *u8 = cast!{*u8} (cast!{*void} (&h));
                let ip = copy Ipv4Addr ([pack [0], pack [1], pack [2], pack [3]]);

                if let Ok (lst) = result [name] {
                    result [name] = alias (lst ~ [ip]);
                } else {
                    result [name] = copy [ip];
                }
            } else if (ifa [0].ifa_addr [0].sin_family == AddressFamily::AF_INET6) {
                let addr = cast!{*sockaddr_in6} (ifa [0].ifa_addr) [0];
                let dmut h = addr.sin6_addr.s6_addr;
                for i in (0 .. 16).stepBy (2) {
                    let swap = h [i];
                    h [i] = h [i + 1];
                    h [i + 1] = swap;
                }

                let pack : *u16 = cast!{*u16} (cast!{*void} (h.ptr));
                let ip = copy Ipv6Addr ([pack [0], pack [1],  pack [2], pack [3],
                                         pack [4], pack [5], pack [6], pack [7]]);

                if let Ok (lst) = result [name] {
                    result [name] = alias (lst ~ [ip]);
                } else {
                    result [name] = copy [ip];
                }
            }
        }
        ifa = ifa [0].ifa_next;
    }

    freeifaddrs (list);
    result
}
