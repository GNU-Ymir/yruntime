/**
 * This module implement format functions, that format a list of parameters into a string according to a description.
 * Formatter are used to align text, and format it in different form (hexadecimal, binary, scientific notations, etc.).
 *
 * @Authors: Emile Cadorel
 * @License: GPLv3
 * <hr>
 *
 * @example:
 * =========
 * use std::format;
 *
 * // Simple formatting using formatter without information {}
 * let mut f = format ("i : {}, j : {}"s8, 89, "test"s8);
 * assert (f == "i : 89, j : test"s8);
 *
 * // aligning the parameter, char = '+', left = '<', len = '8'
 * f = format ("{:+<8}"s8, 12u32);
 * assert (f == "12++++++"s8);
 *
 * // aligning the parameter, char = '=', left = '<', len = '8'
 * // and put the sign '+' if the value is positive, and in hexadecimal 'x'
 * f = format ("{:=<+8x}"s8, 12u32);
 * assert (f == "+0xc====="s8);
 *
 * // aligning the parameter 1, char = '=', right = '>' len = '8', parameter 0 is ignored
 * f = format ("{1:=>8}"s8, 89u32, 78u32);
 * assert (f == "======78"s8);
 *
 * // aligning parameter '1', char = '-', center = '^', len = parameter[i - 0] (parameter 0 here)
 * f = format ("{1:-^*}"s8, 8u32, 19u32);
 * assert (f == "---19---"s8);
 *
 * // aligning parameter '1', char = '+', left = '<', len = parameter[i - 0], in hexa format = 'x'
 * f = format ("{1:+<*x} {0}"s8, 10, 255u32);
 * assert (f == "0xff++++++ 10"s8);
 *
 * // parameter '3' is centered and formated in scientific format, aligned with '=',
 * // the width is the parameter '0', the precision the parameter '1' and the value the parameter '2'
 * f = format ("{:=^*.*e}"s8, 20, 3, 314.0);
 * assert (f == "======3.140e+02======"s8);
 *
 * // parameter '1' is right aligned in binary format, width is 10, and parameter '0' is formated after
 * f = format ("{1:->10b} {0}"s8, "foo", 4u32);
 * assert (f == "-----0b100 foo"s8);
 *
 * // formatter are ignored if the { are doubled, so we can write the value { in a format
 * f = format ("{{} {0:}"s8, 9);
 * assert (f == "{} 9"s8);
 *
 * // And a simple formatting to end all that ;)
 * f = format ("{} and {}"s8, 1, true);
 * assert (f == "1 and true"s8);
 * ===========
 */

in format;

pub mod ::errors;
mod ::implem;


use std::{format::_, stream, traits};

/**
 * Format the parameters passed to the function according to the format given as first parameter.
 * @params:
 *   - str: the format
 *   - a: the list of values to format
 * @throws:
 *   - FormatError: if the format is not valid for the type of values
 *
 * @Grammar:
 * =================
 * format_string := (any_c8 | maybe_format)*
 * maybe_format := ('{' '{') | format
 * format := '{' (argument)? (':' format_spec)? '}'
 * argument := ([0-9]*)
 *
 * format_spec := align (sign)? (type)? ('.' precision)?
 * fill := any_c8
 * align := (fill? ('<' | '^' | '>') width)?
 * sign := '+'
 * type := 'o' | 'x' | 'b' | 'e'
 * width := ([0-9])* | '*'
 * precision := ([0-9])* | '*'
 * =================
 */
pub fn format {T...} (str : [c8], a : T)-> [c8]
    throws FormatError
{
    let dmut stream = copy StringStream ();
    let z = (expand a,);
    implem::format (str, z, alias stream);

    stream[]
}
