mod std::container::map;
import std::io;
import std::traits;
import core::typeinfo, core::duplication;
import std::option;
import std::algorithm::comparison;

pub {

    /**
     * A map is a collection of values that associate keys to values. 
     * Each key can appear only once in the map
     * Warning : 
     * ===========
     * A map is not thread safe, if it is mutable, if
     * multiple thread try to modify the map at the same time, it
     * could occur data races.
     * ===========
     * Example : 
     * ==========
     * let mut m = Map!([c32], i32)::new ()
     * (alias m).insert ("foo", 1)
     * (alias m).insert ("bar", 2);
     * println (m); // {foo=> 1, bar=> 2}
     * ==========
     * The implementation used is a tree map, and the tree is assured to be balanced at each insertion
     * The values of the map are immutable, but the map itself is mutable
     */
    class @final Map (K, V) {

        let mut _head : Node = Empty::new ();

        /**
         * A new empty map
         */
        pub self () {}

        /** Used for deep copy */
        prv self (mut head : Node) with _head = alias head {}
        
        /**
         * Insert a new element in the map
         * Example : 
         * ===========
         * let mut m = Map!(i32, i32)::new ();
         * (alias m).insert (12, 34);
         * println (m); // {12=> 34}
         * ===========
         * Complexity : O (h), where h is the height of the tree
         */
        pub def insert (mut self, k : K, v : V) {
            self._head = alias ((alias self).insert (alias self._head, k, v));
        }

        /**
         * Insert a new element in the map, or replace it if it already exists
         * Complexity : O(h), where h is the height of the map
         */
        prv def insert (self, mut head : Node, k : K, v : V) -> mut Node {
            match (ref head) {
                Empty () => {
                    return Value!(K, V)::new (k, v);
                }
                Value!(K, V) (key-> key : _, left-> ref mut left : _, right-> ref mut right : _) => {
                    if (key > k) {
                        left = alias (self.insert (alias left, k, v));
                    } else if (key < k) {
                        right = alias (self.insert (alias right, k, v));
                    } else {
                        return alias (Value!(K, V)::new (k, v, alias left, alias right));
                    }
                    head.height = max (left.height, right.height) + 1us;
                    
                    let balance = left.height -:i64 right.height;
                    
                    let l_key = match (left) { Value!(K, V) (key-> x : _) => { x } _ => k }
                    let r_key = match (right) { Value!(K, V) (key-> x : _) => { x } _ => k }
                    
                    if (balance > 1 && k < l_key)
                        return alias (self.rightRotate (alias head));

                    if (balance > 1 && k > l_key) {
                        left = alias self.leftRotate (alias left);
                        return alias self.rightRotate (alias head);
                    }

                    if (balance < -1 && k > r_key) {
                        return alias (self.leftRotate (alias head));
                    }
                    
                    if (balance < -1 && k < r_key) {
                        right = alias self.rightRotate (alias right);
                        return alias self.rightRotate (alias head);
                    }
                }
            }
            return alias head;
        }

        /**
         * Create a duplication of the map, and insert a new value in it
         * Complexity : O (n + h), where n is the number of values in the map, and h is the height of the tree
         */
        pub def insert (self, k : K, v : V) -> mut Map!(K, V) {
            let mut ret = dcopy self;
            (alias ret).insert (k, v);
            alias ret
        }
        
        /**
         * Perform a left rotation on a node to balance the tree
         * Complexity : O (1)
         */
        prv def leftRotate (self, mut node : Node) -> mut Node {
            match (ref node) {
                mut x : Value!(K, V) = Value!(K, V) (right-> ref mut right : _) => {
                    match (ref right) {
                        mut y : Value!(K, V) => {
                            let mut T2 = alias y.left;
                            y.left = alias node;                            
                            x.right = alias T2;
                            
                            y.height = 1us + max (y.left.height, y.right.height);
                            x.height = 1us + max (x.left.height, x.right.height);
                            
                            return alias y;       
                        }
                    };
                }                
            }

            return alias node;
        }

        /**
         * Perform a right rotation on a node to balance the tree
         * Complexity : O (1)
         */
        prv def rightRotate (self, mut node : Node) -> mut Node {
            match (ref node) {
                mut x : Value!(K, V) => {
                    match (ref x.left) {
                        mut y : Value!(K, V) => {
                            
                            let mut T2 = alias y.right;
                            y.right = alias node;
                            x.left = alias T2;

                            y.height = 1us + max (y.left.height, y.right.height);
                            x.height = 1us + max (x.left.height, x.right.height);
                            
                            return alias y;       
                        }
                    };
                }                
            }

            return alias node;
        }

        /**
         * Returns : the element with the key /k/ in the map
         * Example : 
         * =============
         * let m = Map!([c32], i32)::new ();
         * // ...
         * println (m ["foo"]);
         * =============
         * Complexity : O (h), where h is the height of the tree
         */
        pub def opIndex (self, k : K) -> Option!(V) {
            self.get (self._head, k)
        }        

        /**
         * Returns : the value indexed with the key /k/ 
         * Complexity : O (h), where h is the height of the tree
         */
        prv def get (self, head : Node, k : K) -> Option!(V) {
            match (head) {
                Value!(K, V) (key-> key : _, value-> value : _, left-> l : _, right-> r : _) => {
                    if (k == key) Some!(V)::new (value)
                    else if (k < key) self.get (l, k)
                    else self.get (r, k)
                }
                _ => {
                    let m : Option!(V) = std::option::None!(V)::new ();
                    m
                }
            }
        }

        /**
         * Returns : true, if the map contains the key /key/, and false otherwise
         */
        pub def opContain (self, key : K) -> bool {
            match (self.get (self._head, key)) {
                std::option::None!(V) () => {
                    false
                }
                _ => true
            }
        }
        
        
        impl std::io::Printable {
            pub over print (self) {
                print ("{", self._head, "}");
            }
        }

        impl core::duplication::Copiable {
            pub over deepCopy (self) -> mut Map!(K, V) {
                return Map!(K, V)::new (dcopy self._head)
            }
        }
        
    }
    
}

pub {

    /**
     * This is the internal part of a map
     * This cannot go outside of this module, and is only used to represent a map
     * There are two type of nodes : 
     * - Value (K, V), where K is a type of Key, and V is a type of Value
     * - Empty, an empty node
     */
    class @abstract Node {

        /**
         * The height of the node = 1 + max (height (left), height (right))
         */
        pub let mut height : usize = 0us;
        
        pub self () {}
        
        impl std::io::Printable;

        impl core::duplication::Copiable;
    }

    /**
     * This is a node of a list containing a value, and pointing to the next element of the list
     * The content of the list is immutable
     */
    class Value (K, V) over Node {

        /**
         * The key contained in the node
         */
        pub let key : K;

        /**
         * The value contained in the node
         */
        pub let value : V;
        
        /**
         * Pointer to the left element
         */
        pub let mut left : Node = Empty::new ();

        /**
         * Pointer to the right element
         */
        pub let mut right : Node = Empty::new ();
        
        /**
         * Create a node, with a given value 
         */
        pub self (key : K, value : V) with key = key, value = value {
            self.height = 0us;
        }

        
        pub self (key : K, value : V, mut left : Node, mut right : Node) with
            key = key,
            value = value,
            left = alias left,
            right = alias right
        {
            import std::algorithm::comparison;
            self.height = 1us + max (self.left.height, self.right.height)
        }

        pub over print (self) {            
            match (self.left) {
                l : Value!(K, V) =>
                    print (l, ", ");
            }            

            cte if (is!(K)(X impl Printable) || isPrimitive!(K))
                print (self.key)
            else
                print ((self.key)::typeinfo.name);
            
            print ("=> ");
            
            cte if (is!(V)(X impl Printable) || isPrimitive!(V))
                print (self.value)
            else
                print ((self.value)::typeinfo.name);

            match (self.right) {
                r : Value!(K, V) =>
                    print (", ", r);                
            }
        }                

        pub over deepCopy (self) -> mut Node {
            Value!(K, V)::new (self.key, self.value, dcopy self.left, dcopy self.right)
        }
        
    }

    /**
     * This is a empty node, that marks the end of a list
     */
    class Empty over Node {
        pub self () {}

        pub over print (self) {}

        pub over deepCopy (self) -> mut Node {
            alias Empty::new ()
        }
    }

}
