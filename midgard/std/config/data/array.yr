in array;

use std::stream;
use std::config::errors;

/**
 * An array is a list of `Config`.
 * @example:
 * ```
 * let dmut array = copy Array ();
 * array:.push (copy Str ("foo"));
 * array:.push (copy Int (42));
 *
 * // Arrays are iterable
 * for v, index in array {
 *     println ("At index ", index, " the value is ", v);
 * }
 * ```
 */
@final
pub class Array over Config {

    let mut _content : [mut &Config] = [];

    /**
     * Creates a new Array of nodes, containing a pre constructed list of Configs
     * @params:
     *    - nodes: some nodes to put in the array
     */
    pub self (mut nodes : [mut &Config]) {
        self._content = alias nodes;
    }

    /**
     * Creates a new empty Array
     */
    pub self () {}

    /**
     * Add a node at the end of the Array.
     * @example:
     * ```
     * let dmut array = copy Array ();
     * array:.push (copy Int (1));
     * array:.push (copy Int (2));
     * match array [$ - 1u64] {// access the last element of the array
     *    Int (value-> x) => assert (x == 2);
     * }
     * ```
     */
    pub fn push (mut self, node : &Config) -> void {
        self._content ~= [node];
    }

    /**
     * Access an element at a given Index in the array
     * @throws:
     *   - &OutOfArray: if the index is not in the array
     * @example:
     * ```
     * let i : &Config = copy Int (12);
     * let j : &Config = copt Int (42);
     * let dmut array = copy Array ([i, j]);
     * {
     *     match array [0] {
     *         Int (value-> x)  => println ("index 0 contains : ", x);
     *     }
     * } catch {
     *    ConfigError () => println ("Array does not contain elements");
     * }
     * ```
     */

    pub over opIndex (self, i : u32) -> &Config
        throws ConfigOutError
    {
        if i >= self._content.len {
            throw copy ConfigOutError (self._content.len, i);
        }

        self._content [i]
    }

    /**
     * @returns: a slice of the elements contained in the array
     * @example:
     * ```
     * let i : &Config = copy Int (12);
     * let j : &Config = copy Int (42);
     * let dmut array = copy Array (copy [i, j]);
     *
     * let slc : [&Config] = array [];
     * ```
     */
    pub fn opIndex (self)-> [&Config] {
        self._content
    }

    /**
     * Change the element at index i
     * throws:
     *   - &OutOfArray: if i is not a valid index of the array
     * @example:
     * ```
     * let i : &Config = copy Int (12);
     * let j : &Config = copy Int (42);
     * let dmut array = copy Array (copy [i]);
     * {
     *    array:[0] = j;
     * } catch {
     *    ConfigError () => println ("Array does not contain elements");
     * }
     * ```
     */
    pub over opIndexAssign (mut self, i : u32, node : &Config) -> void
        throws ConfigOutError
    {
        if i >= self._content.len {
            throw copy ConfigOutError (self._content.len, i);
        }

        self._content [i] = node;
    }

    /**
     * An alias to get the length of the array
     * @example:
     * ```
     * let i : &Config = copy Int (12);
     * let j : &Config = copy Int (42);
     * let dmut array = copy Array (copy [i, j]);
     * {
     *    // print the last element of the array
     *    println (array [$ - 1u64]);
     * } catch {
     *    _: &OutOfArray => println ("Array does not contain elements");
     * }
     * ```
     */
    pub fn opDollar (self) -> usize {
        self._content.len
    }

    /**
     * @returns: the number of element contained in the array.
     * @example:
     * ```
     * let i : &Config = copy Int (12);
     * let j : &Config = copy Int (42);
     * let dmut array = copy Array (copy [i, j]);
     * assert (array.len == 2us);
     * ```
     */
    @field
    pub fn len (self) -> usize {
        self._content.len
    }

    impl Streamable {

        /**
         * Arrays are printable
         */
        pub over toStream (self, dmut stream : &StringStream) -> void {
            stream:.write ("Array ("s8);
            for i, j in self._content {
                if i != 0 { stream:.write (", "s8); }
                stream:.write (j);
            }
            stream:.write (")");
        }
    }
}
