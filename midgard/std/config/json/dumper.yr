/**
 * Json dumper to dump a toml string from a configuration
 * @Authors: Emile Cadorel
 * @License: GPLv3
 */

in dumper;

use std::{syntax::_, stream};
use std::{config::_, char};


/**
 * A toml dumper that produces an utf8 string from a configuration
 * */
pub record JsonDumper {

    // The root node of the config to dump
    let _root : &Config;

    /**
     * @params:
     *    - root: the configuration to dump
     * */
    pub self (root : &Config)
        with _root = root
    {}

    /**
     * Dump the configuration to an utf8 string
     * */
    pub fn dump (self)-> [c8] {
        let dmut res = copy StringStream ();
        self.dump (self._root, alias res, 0, 0);

        res[]
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          PRIVATES          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Dump the configuration to the stream
     * @params:
     *    - c: the configuration to dump
     *    - stream: the stream to fill
     * */
    prv fn dump (self, c : &Config, dmut stream : &StringStream, indent : i32, retIndent : i32) {
        match c {
            d : &Dict => {
                self.dumpDict (d, alias stream, indent, retIndent);
            }
            a : &Array => {
                self.dumpArray (a, alias stream, indent, retIndent);
            }
            Int (value-> i) => {
                stream:.write (i);
            }
            Float (value-> f) => {
                stream:.write (f);
            }
            Bool (value-> b) => {
                if (b) stream:.write ("\"true\"");
                else   stream:.write ("\"false\"");
            }
            Str (value-> s) => {
                stream:.write ("\"", s, "\"");
            }
        }
    }

    /**
     * Dump an array in json format
     * @params:
     *    - d: the dict to dump
     *    - stream: the stream to fill
     * */
    prv fn dumpArray (self, a : &Array, dmut stream : &StringStream, indent : i32, retIndent : i32) {
        stream:.write ("[");
        for i, v in a[] {
            if i != 0 {
                stream:.write (", ");
            }

            self.dump (v, alias stream, indent, retIndent);
        }

        stream:.write ("]");
    }

    /**
     * Dump a dictionnary in json format
     * @params:
     *    - d: the dict to dump
     *    - stream: the stream to fill
     * */
    prv fn dumpDict (self, d : &Dict, dmut stream : &StringStream, indent : i32, retIndent : i32) {
        stream:.write ("{");
        if d[].len != 0 {
            stream:.write ("\n");
            for _ in 0 .. indent + 3 {
                stream:.write (" ");
            }
        }

        let mut z = 0us;
        for k, v in d[] {
            if z != 0 {
                stream:.write (",\n");
                for _ in 0 .. indent + 3 {
                    stream:.write (" ");
                }
            }

            stream:.write ("\"", k, "\" : ");
            self.dump (v, alias stream, indent + cast!i32 (k.len) + 3, indent + 3);
            z += 1;
        }

        if d[].len != 0 {
            stream:.write ("\n");
            for _ in 0 .. retIndent {
                stream:.write (" ");
            }
        }

        stream:.write ("}");
    }

}
