mod std::config::conv;

import core::typeinfo, core::array, core::exception, core::object;
import std::config::_;
import std::io;

/**
 * Simple trait to impl in a class to be convertible to a Config
 */
trait Serializable {
    pub def serialize (self)-> &Config;
}

/**
 * Try to transform the configuration into a structure
 * @example: 
 * ============
 * import std::config::toml;
 * import std::io;
 * 
 * struct 
 * | mut package : Foo
 *  -> Package;
 *  
 * struct 
 * | mut name : [c32]
 * | mut version : [c32]
 *  -> Foo;
 *
 * let tomlFile = str#{ 
 *     [package]
 *     name = "package name"
 *     version = "1.0.0"
 * };
 * 
 * { 
 *    let cfg = tomlFile.parse ().to!Package ();
 *    println (cfg);
 * } catch {
 *    err: &ConfigError => { 
 *         println (err); 
 *    }
 * }
 * ============
 * @throws: 
 *   - &ConfigError: if the cast cannot be made
 */
pub def to {struct T} (cfg : &Config)-> T
    throws &ConfigError
{
    match cfg {
        x : &Dict => {
            return CfgToConfig::fromDict!T (x);
        }
        _ => {
            throw ConfigError::new (T::typeinfo, cfg::typeinfo);
        }
    }
}

/**
 * Transform a configuration into a class
 * @info: The class must have a constructor taking a configuration as a parameter
 * @example: 
 * ===========================
 * class A {
 *    let i = 0;
 *    pub self (c : &Config) {
 *        match c {
 *             Int (i-> i:_) => { self.i = i; }
 *        }
 *    }
 * }
 * 
 * {
 *     let c = tomlFile.parse ().to!(&A) ();
 *     println (c);
 * } catch {
 *     err: &ConfigError => { 
 *          println (err); 
 *     }
 * }
 * ===========================
 */
pub def to {class T} (cfg : &Config)-> T
    throws &ConfigError
{
    {
        // If the constructor does not throw anything the catcher beneath will not work
        __pragma!fake_throw (&ConfigError); 
        T::new (cfg)
    } catch {
        ex : _  => {
            throw ConfigError::new (T::typeinfo, cfg::typeinfo, subError-> ex?);
        }
    }    
}


/**
 * Transform a structure into a configuration
 * @example: 
 * ===============
 * struct 
 * | x : i32
 * | foo : [c32]
 * | inner : [X]
 *  -> X;
 * 
 * let st = X (1, "foo", [X (2, "bar", [])]);
 * let cfg : &Config = st.to!(&Config} ();
 * ===============
 */
pub def to {C of &Config, struct T} (value : T)-> &Config {
    StructToCfg::to!{&Config, T} (value)
}

/**
 * Transform a class into a configuration
 * @example:
 * ===================
 * class A {
 *     impl std::config::conv::Serializable {
 *          pub over seralize (self)-> &Config {
 *              let dmut d = Dict::new ();
 *              d:.insert ("foo", Float::new (12.0));
 *              d
 *          }
 *     }
 * }
 * ===================
 */
pub def to {C of &Config, T impl Serializable} (value : T)-> &Config {
    StructToCfg::to!{&Config, T} (value)
}

pub def to {C of &Config, class T} (value : T)-> &Config {
    cte assert ("Class " ~ T::typeid ~ " does not impl Serializable");
}

mod CfgToConfig {

    /**
     * Transform the dictionnary into a struct
     * @example: 
     * ============ 
     * ============ 
     * @throws: 
     *   - &ConfigError: if the configuration does not contains every field of the struct
     * @info: if the configuration contains more information they are ignored
     */
    pub def fromDict {struct T} (dict : &Dict)-> T
        throws &ConfigError
    {
        __pragma!fake_throw (&ConfigError); // if the struct is empty
        let dmut t = [0u8 ; new sizeof (T)];
        cte for i in 0us .. (__pragma!field_offsets (T)).len {
            let offset = (__pragma!field_offsets (T)) [i];
            let size = sizeof (__pragma!field_type (T, (__pragma!field_names (T))[i]));
            let dmut z : &(mut void) = alias (cast!(&void) ((t [offset .. (offset + size)]).ptr));
            
            if ((__pragma!field_names (T))[i] in dict) {
                cte if (is!(__pragma!field_type (T, (__pragma!field_names (T))[i])) {class C} && !__pragma!compile ({
                    to!(__pragma!field_type (T, (__pragma!field_names (T))[i])) (dict [(__pragma!field_names (T))[i]]);
                })) {
                    cte assert (false, "Type : '" ~ (__pragma!field_type (T, (__pragma!field_names (T))[i]))::typeid ~ "' is not decodable from a configuration, it must have a constructor with a '&Config' as parameter");
                } else {                    
                    {
                        *(cast! (&(__pragma!field_type (T, (__pragma!field_names (T))[i]))) (z)) = to!(__pragma!field_type (T, (__pragma!field_names (T))[i])) (dict [(__pragma!field_names (T))[i]]);                    
                    } catch {                        
                        err : &ConfigError => {
                            throw ConfigError::new (name-> (__pragma!field_names (T))[i], T::typeinfo, dict::typeinfo, subError-> (cast!(&Exception) (err))?);
                        }
                        _ => {
                            throw ConfigError::new (name-> (__pragma!field_names (T))[i], T::typeinfo, dict::typeinfo);
                        }
                    }
                }
            } else {                
                cte if (!(__pragma!field_has_value (T))[i]) {
                    throw ConfigError::new (name-> (__pragma!field_names (T))[i], T::typeinfo, dict::typeinfo);
                } else {
                    *(cast! (&(__pragma!field_type (T, (__pragma!field_names (T))[i]))) (z)) = __pragma!field_value (T, (__pragma!field_names (T))[i]);
                }
            }        
        }    

        __pragma!trusted ({*(cast!(&T) (cast!(&void) (t.ptr)))})
    } catch {
        err : &ConfigError => {
            throw err;
        }
        _  => {
            throw ConfigError::new (T::typeinfo, dict::typeinfo);
        }
    }

    /**
     * Transform an array configuration into an array
     * @example: 
     * ============ 
     * ============ 
     * @throws: 
     *   - &ConfigError: if the configuration casting failed
     */
    pub def fromArray {T of [U], U} (cfg : &Array) -> T
        throws &ConfigError
    {
        import std::collection::vec;
        let dmut res = Vec!{U}::new ();
        for i in cfg {
            match i {
                Ok (inner: &Config) =>  {
                    res:.push (inner.to!U ());
                }
            }                    
        }
        
        res:.fit ();
        return res [];
    }
    
    /**
     * Transform a configuration into a i64
     * @example: 
     * =============
     * let i = Int::new (12);
     * assert (i.to!(i64) () == 12i64);
     * =============
     * @throws: 
     *   - &ConfigError: if the cast cannot be made
     */
    pub def to {T of i64} (cfg : &Config)-> T
        throws &ConfigError
    {
        match cfg {
            Int (i-> i:_) => { return i; }
            _ => {
                throw ConfigError::new (T::typeinfo, cfg::typeinfo);
            }
        }
    }

    /**
     * Transform a configuration into a i64
     * @example: 
     * =============
     * let i = Int::new (12);
     * assert (i.to!(i32) () == 12);
     * =============
     * @throws: 
     *   - &ConfigError: if the cast cannot be made
     */
    pub def to {T of i32} (cfg : &Config)-> T
        throws &ConfigError
    {
        match cfg {
            Int (i-> i:_) => { return cast!i32 (i); }
            _ => {
                throw ConfigError::new (T::typeinfo, cfg::typeinfo);
            }
        }
    }    

    /**
     * Transform a configuration into a f64
     * @example: 
     * =============
     * let i = Float::new (12.0);
     * assert (i.to!(f64) () == 12.0);
     * =============
     * @throws: 
     *   - &ConfigError: if the cast cannot be made
     */
    pub def to {T of f64} (cfg : &Config)-> T
        throws &ConfigError
    {
        match cfg {
            Float (f-> f:_) => { return f; }
            _ => {
                throw ConfigError::new (T::typeinfo, cfg::typeinfo);
            }
        }
    }

    /**
     * Transform a configuration into a string
     * @example: 
     * =============
     * let i = Str::new ("foo");
     * assert (i.to!([c32]) () == "foo");
     * =============
     * @throws: 
     *   - &ConfigError: if the cast cannot be made
     */
    pub def to {T of [U], U of c32} (cfg : &Config)-> T
        throws &ConfigError
    {
        match cfg {
            Str (str-> str:_) => { return str; }            
            _ => {
                throw ConfigError::new (T::typeinfo, cfg::typeinfo);
            }
        }
    }

    /**
     * Transform a configuration into a bool
     * @example: 
     * =============
     * let i = Bool::new (false);
     * assert (i.to!(bool) () == false);
     * =============
     * @throws: 
     *   - &ConfigError: if the cast cannot be made
     */
    pub def to {T of bool} (cfg : &Config)-> T
        throws &ConfigError
    {
        match cfg {
            Bool (b-> b:_) => { return b; }
            _ => {
                throw ConfigError::new (T::typeinfo, cfg::typeinfo);
            }
        }
    }

    /**
     * Transform a configuration into an array
     * @example: 
     * =============
     * let i = Array::new (Int::new (1), Int::new (2));
     * assert (i.to!([i32]) () == [1, 2]);
     * =============
     * @throws: 
     *   - &ConfigError: if the cast cannot be made
     */
    pub def to {T of [U], U} (cfg : &Config)-> T
        throws &ConfigError
    {
        import std::collection::vec;
        match cfg {
            x : &Array => { return fromArray!(T) (x); }
            _ => {
                cte if (is!(U)(Z of c32)) {
                    match cfg {
                        Str (str-> str:_) => {            
                            return str; 
                        }
                    }
                }
                return [cfg.to!(U) ()];                
            }
        }
    }
}

mod StructToCfg {

    /**
     * Transform a structure into a configuration
     * @example: 
     * ===============
     * struct 
     * | x : i32
     * | foo : [c32]
     * | inner : [X]
     *  -> X;
     * 
     * let st = X (1, "foo", [X (2, "bar", [])]);
     * let cfg : &Config = st.to!(&Config) ();
     * ===============
     */
    pub def to {C of &Config, struct T} (value : T)-> &Config {
        let dmut res = Dict::new ();
        cte for i in 0u32 .. (typeof (__pragma!tupleof (value))::arity) {
            let name = (__pragma!field_names (T))[i];
            cte if (__pragma!compile ({
                let _ = StructToCfg::to!(&Config) ((__pragma!tupleof (value)).i);
            })) {
                let x = StructToCfg::to!(&Config) ((__pragma!tupleof (value)).i);
                res:.insert (name, x);
            } else {
                cte if (is!{typeof ((__pragma!tupleof (value)).i)} {class U}) {
                    cte assert (false, "Field of " ~ T::typeid ~ " of class " ~ typeof ((__pragma!tupleof (value)).i)::typeid ~ " does not impl Serializable");
                } else {
                    cte assert (false, "Field of " ~ T::typeid ~ " of type '" ~ typeof ((__pragma!tupleof (value)).i)::typeid ~ "' cannot be encoded by a configuration");
                }
            }
        }
        
        res
    }

    /**
     * Transform a class into a configuration
     * @example:
     * ===================
     * class A {
     *     impl std::config::conv::Serializable {
     *          pub over seralize (self)-> &Config {
     *              let dmut d = Dict::new ();
     *              d:.insert ("foo", Float::new (12.0));
     *              d
     *          }
     *     }
     * }
     * ===================
     */
    pub def to {C of &Config, T impl Serializable} (value : T)-> &Config {
        value.serialize ()
    }
    
    /**
     * Transform a i64 into a configuration
     * @example: 
     * ============
     * let i = 90i64;
     * let cfg : &Config = i.to!(&Config) ();
     * ============
     */
    pub def to {C of &Config, T of i64} (value : T)-> &Config {
        Int::new (value)
    }

    /**
     * Transform a i32 into a configuration
     * @example: 
     * ============
     * let i = 90;
     * let cfg : &Config = i.to!(&Config) ();
     * ============
     */
    pub def to {C of &Config, T of i32} (value : T)-> &Config {
        Int::new (cast!i64 (value))
    }

    /**
     * Transform a bool into a configuration
     * @example: 
     * ============
     * let b = false;
     * let cfg : &Config = b.to!(&Config) ();
     * ============
     */
    pub def to {C of &Config, T of bool} (value : T)-> &Config {
        Bool::new (value)
    }

    /**
     * Transform a f64 into a configuration
     * @example: 
     * ============
     * let f = 3.14;
     * let cfg : &Config = f.to!(&Config) ();
     * ============
     */
    pub def to {C of &Config, T of f64} (value : T)-> &Config {
        Float::new (value)
    }

    /**
     * Transform a [c32] into a configuration
     * @example: 
     * ============
     * let str = "test";
     * let cfg : &Config = str.to!(&Config) ();
     * ============
     */
    pub def to {C of &Config, T of [U], U of c32} (value : T)-> &Config {
        Str::new (value)
    }

    /**
     * Transform a slice into a configuration
     * @example: 
     * ============
     * let slc = [1, 2, 3];
     * let cfg : &Config = slc.to!(&Config) ();
     * ============
     */
    pub def to {C of &Config, T of [U], U} (value : T)-> &Config {
        let dmut arr = Array::new ();
        for i in value {
            arr:.push (StructToCfg::to!(&Config) (i));
        }
        arr
    }

}
