/**
 * Module used to parse command line options
 * @Authors: Emile Cadorel
 * @License: GPLv3
 */

in args;

pub mod ::argument;
pub mod ::errors;

use std::{traits,
          stream,
          conv::errors,
          config::{args::_, data}};

/**
 * Argument parser
 * */
pub class ArgumentParser {

    // The list of position arguments (with no name)
    let mut _positions : [Argument] = [];

    // The list of option arguments (named with a value)
    let mut _options : [Argument] = [];

    // The list of sub command arguments (triggered by a flag)
    let mut _subCommands : [Argument] = [];

    // The list of flag argument that when set throws the help required error
    let mut _helps : [Argument] = [];

    // The list of flag arguments (named with no values)
    let mut _flags : [Argument] = [];

    /**
     * Create an empty argument parser
     * */
    pub self () {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          PARSING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Parse command line options
     * @params:
     *   - args: the command line options to parse
     * */
    pub fn parse (self, args : [[c8]])-> &Dict
        throws CommandLineError
    {
        let mut currentPositional = 0us;
        let mut rest = args [1 .. $];
        let dmut resultConfig = copy Dict ();

        while rest.len > 0 {
            let (name, isHyphenated) = self.parseOptionName (rest [0]);
            if (isHyphenated) {
                if let Ok (sub) = self.isSubCommand (name, true) {
                    resultConfig:[sub.long] = self.parseSubCommand (sub, rest);
                    break;
                }

                else if let Ok (flg) = self.isFlag (name) {
                    resultConfig:[flg.long] = copy Bool (true);
                    rest = rest [1 .. $];
                }

                else if let Ok () = self.isHelp (name) {
                    throw copy HelpRequestError ();
                }

                else if let Ok (opt) = self.isOption (name) {
                    let (val, rest_) = self.parseOption (opt, rest [1 .. $]);
                    rest = rest_;
                    resultConfig:[opt.long] = val;
                }

                else {
                    throw copy UnknownArgument (name);
                }
            } else {
                if let Ok (sub) = self.isSubCommand (name, false) {
                    resultConfig:[sub.long] = self.parseSubCommand (sub, rest);
                    break;
                }

                else if currentPositional < self._positions.len {
                    let opt = self._positions [currentPositional];
                    let (val, rest_) = self.parseOption (opt, rest);
                    resultConfig:[opt.long] = val;
                    currentPositional += 1;
                    rest = rest_;
                }

                else {
                    throw copy UnknownArgument (name);
                }
            }
        }

        self.checkMandatories (currentPositional, resultConfig);
        self.insertMissingFlags (alias resultConfig);

        resultConfig
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          EXPLANATION          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * @returns: the usage of the argument parser in a single line
     * */
    pub fn getUsage (self)-> [c8] {
        let dmut stream = copy StringStream ();
        stream:.write ("usage ");
        let mut i = 0;
        for f in self._flags {
            if i != 0 { stream:.write (" "); }
            self.exportUsageOption (f, alias stream, isFlag-> true);
            i += 1;
        }

        for f in self._helps {
            if i != 0 { stream:.write (" "); }
            self.exportUsageOption (f, alias stream, isFlag-> true);
            i += 1;
        }

        for f in self._options {
            if i != 0 { stream:.write (" "); }
            self.exportUsageOption (f, alias stream);
            i += 1;
        }

        for f in self._positions {
            if i != 0 { stream:.write (" "); }
            self.exportUsageOption (f, alias stream, isPositional-> true);
            i += 1;
        }

        for f in self._subCommands {
            if i != 0 { stream:.write (" "); }
            self.exportUsageOption (f, alias stream, isSub-> true);
            i += 1;
        }

        stream[]
    }

    /**
     * @returns: the help of the argument parser
     * */
    pub fn getHelp (self)-> [c8] {
        []
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          POSITIONAL          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Add a position argument
     * @params:
     *    - name: the name used to retreive the position argument in the generated configuration (e.g. 'list').
     *    - comment: the comments to print for help
     * @example:
     * =========
     * use std::config::_;
     *
     * let parser = ArgumentParser ()
     *              :.position!{i64} ("A", comment-> "first int")
     *              :.position!{i64} ("B", comment-> "second int");
     *              :.position!{[c8]} ("C", comment-> "a string");
     *              :.position!{f64} ("D", comment-> "a float");
     *
     * let args = parser.parse (["./a.out", "1", "2", "foo", "87.12"]);
     *
     * assert (args ["A"].to!{i64} () == 1);
     * assert (args ["B"].to!{i64} () == 2);
     * assert (args ["C"].to!{[c8]} () == "foo");
     * assert (args ["D"].to!{f64} () == 87.12);
     * =========
     * */
    pub fn if (isIntegral!{T} || isFloating!{T} || is!{T}{X of [c8]}) position {T} (mut self, name : [c8], comments : [c8] = "")-> dmut &ArgumentParser {
        let type = cte if isSigned!{T} {
            copy Int (0)
        } else cte if isFloating!{T} {
            copy Float (0.0)
        } else { copy Str ("") };

        self._positions ~= [Argument (long-> name, short-> "", comment-> comments, type-> type?, hyphenated-> false, mandatory-> true)];
        alias self
    }

    /**
     * Add a list position argument
     * @params:
     *    - name: the name used to retreive the position argument in the generated configuration (e.g. 'list').
     *    - comment: the comments to print for help
     * @example:
     * =========
     * let parser = ArgumentParser ()
     *              :.position!{"list", [i64]} (comment-> "list of int");
     *
     * let args = parser.parse (["./a.out", "1", "2", "3"])
     *                  .to!{[[c8] => [i64]} (); // transform the configuration into a map
     *
     * assert (args ["list"] == [1, 2, 3]);
     * =========
     * */
    pub fn  if (isIntegral!{U} || isFloating!{U} || is!{U}{X of [c8]}) position {T of [U], U} (mut self, name : [c8], comments : [c8] = "")-> dmut &ArgumentParser {
        let dmut lst = copy Array ();

        cte if isSigned!{U} {
            lst:.push (copy Int (0));
        } else cte if isFloating!{U} {
            lst:.push (copy Float (0.0));
        } else {
            lst:.push (copy Str (""));
        }

        self._positions ~= [Argument (long-> name, short-> "", comment-> comments, type-> lst?, hyphenated-> false, mandatory-> true)];
        alias self
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          SUBCOMMAND          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Add a sub command parser
     * @params:
     *    - name: the name of the command (long name of the option to set for the sub command to be executed)
     *    - cmd: the function to call when the argument is found
     *    - short: the short name of the argument
     *    - comment: the comments to print in the help
     *    - hyphenated: true iif '--' are mandatory for the option to be triggered
     * @example:
     * ===============
     * fn subCmd (args : [[c8]])-> (&Config)? {
     *    let subParser = ArgumentParser ()
     *                    :.option!{i64} ("foo", comment-> "Int value of foo");
     *
     *    // needs to return an option to catch errors in a function pointer
     *    return subParser.parse (args)?;
     * }
     *
     *
     * let superCmd = ArgumentParser ()
     *                :.sub ("sub", &subCmd, short-> "s", comment-> "sub command", hyphenated-> false);
     *
     * let cfg = superCmd.parse (["./a.out", "sub", "--foo", "78"]);
     * println (cfg ["sub"]["foo"]); // 78
     * ===============
     * */
    pub fn sub (mut self, name : [c8], cmd : dg ([[c8]])-> (&Config)?, short : [c8] = "", comments : [c8] = "", hyphenated : bool = true, mandatory : bool = false)-> dmut &ArgumentParser {
        self._subCommands ~= [Argument (long-> name, short-> short, comment-> comments, cmd-> cmd, hyphenated-> hyphenated, mandatory-> mandatory)];
        alias self
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          OPTION          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Add a option argument
     * @params:
     *    - name: the name used to retreive the option argument in the generated configuration (e.g. 'list').
     *    - comment: the comments to print for help
     * @example:
     * =========
     * use std::config::_;
     *
     * let parser = ArgumentParser ()
     *              :.option!{i64} ("fst", comment-> "first int")
     *              :.option!{i64} ("scd", short-> "s", comment-> "second int");
     *              :.option!{[c8]} ("thd", comment-> "a string");
     *              :.option!{f64} ("fth", comment-> "a float");
     *
     * let args = parser.parse (["./a.out", "--fst", "1", "-s", "2", "--thd", "foo", "--fth", 87.12"]);
     *
     * assert (args ["A"].to!{i64} () == 1);
     * assert (args ["B"].to!{i64} () == 2);
     * assert (args ["C"].to!{[c8]} () == "foo");
     * assert (args ["D"].to!{f64} () == 87.12);
     * =========
     * */
    pub fn if (isIntegral!{T} || isFloating!{T} || is!{T}{X of [c8]}) option {T} (mut self, name : [c8], short : [c8] = "", comments : [c8] = "", mandatory : bool = false)-> dmut &ArgumentParser {
        let type = cte if isSigned!{T} {
            copy Int (0)
        } else cte if isFloating!{T} {
            copy Float (0.0)
        } else { copy Str ("") };

        self._options ~= [Argument (long-> name, short-> short, comment-> comments, type-> type?, hyphenated-> true, mandatory-> mandatory)];
        alias self
    }

    /**
     * Add a list option argument
     * @params:
     *    - name: the name used to retreive the option argument in the generated configuration (e.g. 'list').
     *    - comment: the comments to print for help
     *    - short: the short name of the option
     * @example:
     * =========
     * let parser = ArgumentParser ()
     *              :.option!{[i64]} ("list", short-> "-l", comment-> "list of int");
     *
     * let args = parser.parse (["./a.out", "-l", 1", "2", "3"])
     *                  .to!{[[c8] => [i64]} (); // transform the configuration into a map
     *
     * assert (args ["list"] == [1, 2, 3]);
     * =========
     * */
    pub fn if (isIntegral!{T} || isFloating!{T} || is!{T}{X of [c8]}) option {T of [U], U} (mut self, name : [c8], short : [c8] = "", comments : [c8] = "", mandatory : bool = false)-> dmut &ArgumentParser {
        let dmut lst = copy Array ();

        cte if isSigned!{T} {
            lst:.push (copy Int (0));
        } else cte if isFloating!{T} {
            lst:.push (copy Float (0.0));
        } else {
            lst:.push (copy Str (""));
        }

        self._options ~= [Argument (long-> name, short-> short, comment-> comments, type-> lst?, hyphenated-> true, mandatory-> mandatory)];
        alias self
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          FLAGS          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Add a flag argument
     * @params:
     *    - name: the name of the flag
     *    - short: the short name of the flag
     *    - comment: the comments to display in the help
     * @example:
     * =============
     * let parser = ArgumentParser ()
     *              :.flag ("foo", short-> "f", comment-> "a flag");
     *
     * let args1 = parser.parse (["./a.out", "-f"]);
     * // flag inserted in the result dictionnary and set to true
     * assert (args1 ["foo"].to!{bool} () == true);
     *
     * let args2 = parser.parse (["./a.out"]);
     * // still present in the dictionnary but set to false
     * assert (args2 ["foo"].to!{bool} () == false);
     * */
    pub fn flag (mut self, name : [c8], short : [c8] = "", comments : [c8] = "")-> dmut &ArgumentParser {
        self._flags ~= [Argument (name, short-> short, comment-> comments, type-> none, hyphenated-> true, mandatory-> false)];
        alias self
    }

    /**
     * Add an help flag argument.
     * An help flag triggers an HelpRequestError error throwing when the flag is set instead setting it in the result dictionnary.
     * @params:
     *    - name: the name of the flag
     *    - short: the short name of the flag
     *    - comment: the comments to display in the help
     * @example:
     * ===========
     * let parser = ArgumentParser ()
     *              :.help ("help", short-> "h", comment-> "print help and exit");
     *
     * {
     *    let args1 = parser.parse (["./a.out", "-h"]);
     *    println ("Cmd options : ", args1);
     * } catch {
     *    err => {
     *       // print the error message (here the help message)
     *       println (parser.explain (err));
     *    }
     * }
     * ===========
     * * */
    pub fn help (mut self, name : [c8], short : [c8] = "", comments : [c8] = "")-> dmut &ArgumentParser {
        self._helps ~= [Argument (name, short-> short, comment-> comments, type-> none, hyphenated-> true, mandatory-> false)];
        alias self
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===============================          PRIVATE SEARCHING          ================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Search for a sub command whose name is 'name'
     * @params:
     *    - name: the name of the subcommand to find
     *    - hyphenated: true if the name was hyphenated
     * @returns: the sub command or none if not found
     * */
    prv fn isSubCommand (self, name : [c8], hyphenated : bool)-> (Argument)? {
        for s in self._subCommands {
            if (hyphenated || !s.hyphenated) && (s.long == name || s.short == name) {
                return s?;
            }
        }

        none
    }

    /**
     * Search for a flag whose name is 'name'
     * @params:
     *   - name: the name of the flag to find
     *  @returns: the flag or none if not found
     * */
    prv fn isFlag (self, name : [c8])-> (Argument)? {
        for s in self._flags {
            if s.long == name || s.short == name {
                return s?;
            }
        }

        none
    }

    /**
     * Search for an option whose name is 'name'
     * @params:
     *   - name: the name of the option to find
     *  @returns: the flag or none if not found
     * */
    prv fn isOption (self, name : [c8])-> (Argument)? {
        for s in self._options {
            if s.long == name || s.short == name {
                return s?;
            }
        }

        none
    }

    /**
     * Search for an help flag whose name is 'name'
     * @params:
     *   - name: the name of the flag to find
     *  @returns: the flag or none if not found
     * */
    prv fn isHelp (self, name : [c8])-> (Argument)? {
        for s in self._helps {
            if s.long == name || s.short == name {
                return s?;
            }
        }

        none
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ================================          PRIVATE PARSING          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Parse an option name
     * @params:
     *    - name: the possible name
     *  @returns:
     *     - .0: the parsed name
     *     - .1: true if it was hyphenated
     * */
    prv fn parseOptionName (self, name : [c8])-> ([c8], bool) {
        if (name.len > 2 && name [0] == '-' && name [1] == '-') {
            return (name [2 .. $], true);
        }

        else if (name.len > 1 && name [0] == '-') {
            return (name [1 .. $], true);
        }

        (name, false)
    }

    /**
     * Parse a sub command line option
     * @params:
     *    - sub: the sub command to run
     *    - rest: the argument to pass to the sub command
     * */
    prv fn parseSubCommand (self, sub : Argument, rest : [[c8]])-> &Config
        throws CommandLineError
    {
        if let Ok (func) = sub.subCommand {
            match func (rest) {
                Ok (cfg) => return cfg;
                Err (err) => throw copy MalformedArgument (sub.long, err?);
            }
        }

        throw copy InvalidCommandLine ();
    }


    /**
     * Parse an option
     * @params:
     *    - opt: the argument option to parse
     *    - rest: the command line arguments
     * @returns:
     *    - .0: the configuration
     *    - .1: the argument that are not consumed
     * */
    prv fn parseOption (self, opt : Argument, rest : [[c8]])-> (&Config, [[c8]])
        throws CommandLineError
    {
        match opt.type {
            Ok (Int ()) => return self.parseIntOption (opt, rest);
            Ok (Float ()) => return self.parseFloatOption (opt, rest);
            Ok (Str ()) => return self.parseStrOption (opt, rest);
            Ok (a : &Array) => return self.parseArrayOption (opt, a, rest);
        }

        throw copy InvalidCommandLine ();
    }

    /**
     * Parse a int option
     * @params:
     *    - opt: the argument option to parse
     *    - rest: the command line arguments
     * @returns:
     *    - .0: the configuration
     *    - .1: the argument that are not consumed
     * */
    prv fn parseIntOption (self, opt : Argument, rest : [[c8]])-> (&Config, [[c8]])
        throws CommandLineError
    {
        if rest.len == 0 {
            throw copy MalformedArgument (
                key-> opt.long,
                (copy CastFailure ((&Int)::__typeinfo__, [c8]::typeinfo))?);
        }

        {
            return (copy Int (std::conv::to!{i64} (rest [0])), rest [1 .. $]);
        } catch {
            err => {
                throw copy MalformedArgument (opt.long, err?);
            }
        }
    }

    /**
     * Parse a float option
     * @params:
     *    - opt: the argument option to parse
     *    - rest: the command line arguments
     * @returns:
     *    - .0: the configuration
     *    - .1: the argument that are not consumed
     * */
    prv fn parseFloatOption (self, opt : Argument, rest : [[c8]])-> (&Config, [[c8]])
        throws CommandLineError
    {
        if rest.len == 0 {
            throw copy MalformedArgument (opt.long,
                (copy CastFailure ((&Float)::__typeinfo__, [c8]::typeinfo))?);
        }

        {
            return (copy Float (std::conv::to!{f64} (rest [0])), rest [1 .. $]);
        } catch {
            err => {
                throw copy MalformedArgument (opt.long, err?);
            }
        }
    }

    /**
     * Parse a string option
     * @params:
     *    - opt: the argument option to parse
     *    - rest: the command line arguments
     * @returns:
     *    - .0: the configuration
     *    - .1: the argument that are not consumed
     * */
    prv fn parseStrOption (self, opt : Argument, rest : [[c8]])-> (&Config, [[c8]])
        throws CommandLineError
    {
        if rest.len == 0 {
            throw copy MalformedArgument (opt.long,
                (copy CastFailure ((&Str)::__typeinfo__, [c8]::typeinfo))?);
        }

        let (_, hyphenated) = self.parseOptionName (rest [0]);
        if (hyphenated) { // --foo --bar, does not mean foo takes the value --bar
            throw copy MalformedArgument (
                opt.long,
                (copy CastFailure ((&Str)::__typeinfo__, [c8]::typeinfo))?);
        }

        return (copy Str (rest [0]), rest [1 .. $]);
    }

    /**
     * Parse a array option
     * @params:
     *    - opt: the argument option to parse
     *    - rest: the command line arguments
     * @returns:
     *    - .0: the configuration
     *    - .1: the argument that are not consumed
     * */
    prv fn parseArrayOption (self, opt : Argument, a : &Array, rest : [[c8]])-> (&Config, [[c8]])
        throws CommandLineError
    {
        if rest.len == 0 {
            throw copy MalformedArgument (
                opt.long,
                (copy CastFailure (a.__typeinfo__, [c8]::typeinfo))?);
        }

        let inner = a [0]?;
        let mut args = rest;
        let dmut result = copy Array ();
        let mut castError : (&core::exception::Exception)? = none;
        loop {
            {
                let (z, rest_) = match inner {
                    Ok (Int ()) => { self.parseIntOption (opt, args) }
                    Ok (Float ()) => { self.parseFloatOption (opt, args) }
                    Ok (Str ()) => { self.parseStrOption (opt, args) }
                    _ => {
                        throw copy InvalidCommandLine ();
                    }
                };

                result:.push (z);
                args = rest_;
            } catch {
                err => {
                    castError = err?;
                    break;
                }
            }
        }

        if result.len == 0 {
            throw copy MalformedArgument (opt.long, castError);
        }

        return (result, args);
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ============================          CHECKING AND FINALIZING          =============================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Check for missing mandatory arguments
     * @params:
     *    - cfg: the generated configuration
     * */
    prv fn checkMandatories (self, nbPositional : usize, cfg : &Dict)
        throws CommandLineError
    {
        if (nbPositional < self._positions.len) {
            throw copy MissingArgument (self._positions [nbPositional].long);
        }

        for o in self._options {
            if o.mandatory && o.long !in cfg {
                throw copy MissingArgument (o.long);
            }
        }

        for o in self._subCommands {
            if o.mandatory && o.long !in cfg {
                throw copy MissingArgument (o.long);
            }
        }
    }

    /**
     * Insert the flags that where not found in cmd line options
     * */
    prv fn insertMissingFlags (self, dmut cfg : &Dict) {
        for f in self._flags {
            if (f.long !in cfg) {
                cfg:[f.long] = copy Bool (false);
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          USAGE          ======================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Export an option into usage
     * */
    prv fn exportUsageOption (self, o : Argument, dmut stream : &StringStream, isFlag : bool = false, isSub : bool = false, isPositional : bool = false) {
        if (isPositional) {
            self.exportUsageType (o, alias stream);
            stream:.write ("(", o.long, ")");
        } else {
            if (!o.mandatory) stream:.write ("[");
            stream:.write ("--", o.long);
            if o.short != "" { stream:.write (",-", o.short); }
            if (!isFlag && !isSub) {
                stream:.write (" ");
                self.exportUsageType (o, alias stream);
            } else if isSub {
                stream:.write ("(...)");
            }
            if (!o.mandatory) stream:.write ("]");
        }
    }

    /**
     * Export the type of the argument to the stream
     * */
    prv fn exportUsageType (self, f : Argument, dmut stream : &StringStream) {
        match f.type {
            Ok (Int()) => stream:.write ("int");
            Ok (Float()) => stream:.write ("float");
            Ok (Str()) => stream:.write ("str");
            Ok (a : &Array) => {
                match a [0]? {
                    Ok (Int()) => stream:.write ("[int...]");
                    Ok (Float()) => stream:.write ("[float...]");
                    Ok (Str()) => stream:.write ("[str...]");
                }
            }
        }
    }
}
