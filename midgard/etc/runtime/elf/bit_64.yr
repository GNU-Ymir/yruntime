in bit_64;

use etc::c::{process, env, memory};
use etc::runtime::{elf, exception};

use std::{io, fs::_};
use std::algorithm::{sorting, searching};

def EI_MAG0 = 0
def EI_MAG1 = 1
def EI_MAG2 = 2
def EI_MAG3 = 3
def EI_CLASS = 4
def EI_NIDENT = 16

record Elf64_Ehdr {
    pub let e_ident : [c8 ; EI_NIDENT] = ['\u{0}' ; EI_NIDENT];
    pub let e_type : u16 = 0;
    pub let e_machine : u16 = 0;
    pub let e_version : u32 = 0;
    pub let e_entry : usize = 0;
    pub let e_phoff : usize = 0;
    pub let e_shoff : usize = 0;
    pub let e_flags : u32 = 0;
    pub let e_ehsize : u16 = 0;
    pub let e_phentsize : u16 = 0;
    pub let e_phnum : u16 = 0;
    pub let e_shentsize : u16 = 0;
    pub let e_shnum : u16 = 0;
    pub let e_shstrndx : u16 = 0;

    pub self () {}
}

record Elf64_Shdr {
    pub let sh_name : u32 = 0;
    pub let sh_type : u32 = 0;
    pub let sh_flags : u32 = 0;
    pub let sh_addr : usize = 0;
    pub let sh_offset : usize = 0;
    pub let sh_size : u64 = 0;
    pub let sh_link : u32 = 0;
    pub let sh_info : u32 = 0;
    pub let sh_addralign : u64 = 0;
    pub let sh_entsize : u64 = 0;
    pub self () {}
}

record Elf64_Sym {
    pub let st_name : u32 = 0;
    pub let st_info : u8 = 0;
    pub let st_other : u8 = 0;
    pub let st_shndx : u16 = 0;
    pub let st_value : u64 = 0;
    pub let st_size : u64 = 0;
    pub self () {}
}

enum
| SHT_NULL = 0u32
| SHT_PROGBITS = 1u32
| SHT_SYMTAB = 2u32
| SHT_STRTAB = 3u32
| SHT_RELA = 4u32
| SHT_HASH = 5u32
| SHT_DYNAMIC = 6u32
| SHT_NOTE = 7u32
| SHT_NOBITS = 8u32
| SHT_REL = 9u32
| SHT_SHLIB = 10u32
| SHT_DYNSYM = 11u32
| SHT_LOPROC = 1879048192u32
| SHT_HIPROC = 2147483647u32
| SHT_LOUSER = 2147483648u32
| SHT_HIUSER = 2415919103u32
 -> SectionType;

enum
| STT_NOTYPE = 0u32
| STT_OBJECT = 1u32
| STT_FUNC = 2u32
| STT_SECTION = 3u32
| STT_FILE = 4u32
| STT_LOPROC = 13u32
| STT_HIPROC = 15u32
| STB_LOCAL = 0u32
| STB_GLOBAL = 1u32
| STB_WEAK = 2u32
| STB_LOPROC = 13u32
| STB_HIPROC = 15u32
 -> SymbolInfo;


@final
pub class ELF64Loader over ELFLoader {

    // The list of elf files that are already loaded
    let mut _readElf : [[c8] => mut ()] = copy [];

    // The page mapping of the program
    let mut _pageMapping : [[c8] => mut ()] = copy [];

    // The list of found symbols
    let mut _functions : [[c8] => mut ReflectSymbol] = copy [];

    // The list of coverage symbols 
    let mut _coverages : [[c8] => mut ReflectSymbol] = copy [];

    // The list of vtables symbols 
    let mut _vtables : [[c8] => mut ReflectSymbol] = copy [];

    // The list of vtables symbols 
    let mut _globals : [[c8] => mut ReflectSymbol] = copy [];

    // The list of address of function symbols sorted by the ptrs
    let mut _addrFunctions : [mut ReflectSymbol] = [];

    // The list of address of vtable symbols sorted by the ptrs
    let mut _addrVtables : [mut ReflectSymbol] = [];

    // The list of address of coverage symbols sorted by the ptrs
    let mut _addrCoverages : [mut ReflectSymbol] = [];

    // The list of address of globals symbols sorted by the ptrs
    let mut _addrGlobals : [mut ReflectSymbol] = [];

    pub self () {}

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          UPDATING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Update the elf loading and register the reflect symbols
     * */
    pub over update (mut self) {
        self:.listMapFiles ();
        let mut updated = false;
        for k in self._pageMapping if k !in self._readElf {
            self:.readElf (k);
            self._readElf [k] = ();
            updated = true;
        }
    }

    /**
     * Update the elf loader using a specific elf file
     * */
    pub over update (mut self, name : [c8]) {        
        if name !in self._readElf {
            self:.readElf (name);
            self._readElf [name] = ();
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ===================================          DISPOSING          ====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over clear (mut self) {        
        self._readElf = copy [];
        self._pageMapping = copy [];
        
        self._functions = copy [];
        self._coverages = copy [];
        self._vtables = copy [];
        self._globals = copy [];
        
        self._addrFunctions = [];
        self._addrCoverages = [];
        self._addrVtables = [];
        self._addrGlobals = [];
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          FINDING          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over find (self, name : [c8])-> ReflectSymbol {        
        if let Ok (r) = self._functions [name] {
            return r;
        }

        if let Ok (r) = self._vtables [name] {
            return r;
        }

        if let Ok (r) = self._globals [name] {
            return r;
        }

        if let Ok (r) = self._coverages [name] {
            return r;
        }

        return ReflectSymbol (ReflectSymbolType::NONE, 0, 0, "");
    }

    pub over find (mut self, addr : usize)-> ReflectSymbol {        
        if let Ok (r) = self.dicSearch (addr, ref self._addrFunctions, self._functions) {            
            return r;
        }
        
        if let Ok (r) = self.dicSearch (addr, ref self._addrVtables, self._vtables) {
            return r;
        }
        
        if let Ok (r) = self.dicSearch (addr, ref self._addrGlobals, self._globals) {
            return r;
        }
        
        if let Ok (r) = self.dicSearch (addr, ref self._addrCoverages, self._coverages) {
            return r;
        }
        
        return ReflectSymbol (ReflectSymbolType::NONE, 0, 0, "");
    }

    pub over findFunction (mut self, addr : usize)-> ReflectSymbol {        
        if let Ok (r) = self.dicSearch (addr, ref self._addrFunctions, self._functions) {            
            return r;
        }

        return ReflectSymbol (ReflectSymbolType::NONE, 0, 0, "");
    }
    
    /**
     * Dichotomic search in the symbol list
     * @returns: the symbol if found
     * */
    fn dicSearch (self, addr : usize, ref dmut lst : [ReflectSymbol], from : [[c8] => ReflectSymbol])-> (ReflectSymbol)? {
        if lst.len != from.len {
            // we sort the address symbols to make search faster
            lst = copy [j for _, j in self._functions];            
            lst = sort (alias lst, |a, b| => { a.ptr < b.ptr });            
        }
        
        let mut l = 0is, mut r = cast!isize (lst.len - 1us);
        while l <= r {
            let m = ((l + r) / 2);

            let curr = lst [m];
            if curr.ptr + curr.size < addr {
                l = m + 1;
            } else if curr.ptr > addr {
                r = m - 1;
            } else {
                return (curr)?;
            }
        }

        none
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ====================================          GETTERS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    pub over getFunctionSymbols (self)-> [[c8] => ReflectSymbol] {
        self._functions
    }

    pub over getVtableSymbols (self)-> [[c8] => ReflectSymbol] {
        self._vtables
    }

    pub over getGlobalSymbols (self)-> [[c8] => ReflectSymbol] {
        self._globals
    }
    
    pub over getCoverageSymbols (self)-> [[c8] => ReflectSymbol] {
        self._coverages
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =================================          LIST MAP FILES          =================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * List the elf files that are loaded by this program
     * */
    @final
    fn listMapFiles (mut self) {
        let pid = getpid ();
        let mapFile = "/proc/" ~ std::conv::to!{[c8]} (pid) ~ "/maps";

        {
            let dmut f = File::open (Path (mapFile), read-> true);
            while let line = f:.readUntil ("\n") && line != "" {
                if let Ok (i) = rfind (line, ' ') {
                    let filename = line [i + 1 .. $ - 1];
                    if filename.len > 1 && filename [0] != '[' {
                        self._pageMapping [filename] = ();
                    }
                }
            }
        } catch {
            err => {
                eprintln (err);
                _yrt_exc_panic_no_trace ();
            }
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * ==================================          ELF READING          ===================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Read an elf file and register the symbols that can be found in it
     * */
    fn readElf (mut self, filename : [c8]) {
        let dmut file = File::open (Path (filename), read-> true);
        let content = file:.readBytesAll ();
        unsafe {
            let hdr = cast!{*Elf64_Ehdr} (cast!{*void} (content.ptr));
            if hdr [0].e_ident [EI_MAG0] != cast!{c8} (127u8) return;
            if hdr [0].e_ident [EI_MAG1] != '\u{0x45}' return;
            if hdr [0].e_ident [EI_MAG2] != '\u{0x4c}' return;
            if hdr [0].e_ident [EI_MAG3] != '\u{0x46}' return;
            if hdr [0].e_ident [EI_CLASS] != '\u{0x2}' return;

            let shdr = cast!{*Elf64_Shdr} (cast!{*void} (content.ptr + hdr [0].e_shoff));
            for i in 0 .. hdr [0].e_shnum {
                let section = shdr [i];
                if section.sh_type == SectionType::SHT_DYNSYM || section.sh_type == SectionType::SHT_SYMTAB {
                    let size = cast!usize (section.sh_size) / Elf64_Sym::size;
                    let syms = cast!{*Elf64_Sym} (cast!{*void} (content.ptr + section.sh_offset));
                    let link = shdr [section.sh_link];
                    let names = cast!{*c8} (cast!{*void} (content.ptr + link.sh_offset));

                    self:.appendSymbols (syms, size, names);
                }
            }
        }
    } catch {
        FsError () => {}
    }

    /**
     * Append the symbols from an elf section
     * */
    @unsafe
    fn appendSymbols (mut self, syms : *Elf64_Sym, nb : usize, names : *c8) {
        let coveH = "__COI___Y";
        let ymirH = "_Y";
        let vtblT = "VT";
        
        for i in 0 .. nb {            
            let sym = syms [i];
            let name = &names [sym.st_name];
            if (sym.st_info & SymbolInfo::STT_FUNC != 0) {
                let len = strlen (name);                
                if len > ymirH.len && strncmp (name, ymirH.ptr, ymirH.len) == 0 {
                    let realName = std::conv::fromStringZ (name);
                    let refl = ReflectSymbol (ReflectSymbolType::FUNCTION,
                                              ptr-> cast!usize (sym.st_value),
                                              size-> cast!usize (sym.st_size),
                                              name-> realName);

                    self._functions [realName] = refl;
                }
            }

            else if (sym.st_info & SymbolInfo::STT_OBJECT != 0) {
                let len = strlen (name);
                if len > ymirH.len && strncmp (name, ymirH.ptr, ymirH.len) == 0 {
                    let realName = std::conv::fromStringZ (name);
                    let isVt = (strncmp (name + cast!usize (len - 2), vtblT.ptr, vtblT.len) == 0); // already len > 2 
                    
                    let refl = ReflectSymbol (if isVt { ReflectSymbolType::VTABLE }
                                              else { ReflectSymbolType::OBJECT },
                                              ptr-> cast!usize (sym.st_value),
                                              size-> cast!usize (sym.st_size),
                                              name-> realName);

                    if isVt {
                        self._vtables [realName] = refl;
                    } else {
                        self._globals [realName] = refl;
                    }
                }
                
                else if len > coveH.len && strncmp (name, coveH.ptr, coveH.len) == 0 {                    
                    let realName = std::conv::fromStringZ (name);
                    let refl = ReflectSymbol (ReflectSymbolType::COVERAGE,
                                              ptr-> cast!usize (sym.st_value),
                                              size-> cast!usize (sym.st_size),
                                              name-> realName);

                    self._coverages [realName] = refl;                        
                }
            }            
        }
    }
}
