in ipipe;

use etc::c::{files, socket};
use core::exception;

/**
 * A reading pipe
 * */
pub record IPipe {

    // The managed pipe
    let mut _pipe : i32 = -1;

    // True if the pipe failed to read
    let mut _error : bool = false;

    /**
     * @params:
     *    - the reading pipe
     * */
    pub self (pipe : i32 = -1)
        with _pipe = pipe
        , _error = false
    {}

    /**
     * ================================================================================
     * ================================================================================
     * =============================        SETTERS        ============================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Set the pipe to non block mode
     * */
    pub fn setNonBlocking (mut self) {
        if (self.isOpen ()) {
            let old = fcntl (self._pipe, FileFlags::F_GETFL, 0);
            fcntl (self._pipe, FileFlags::F_SETFL, old | SocketFlag::O_NONBLOCK);
        }
    }

    /**
     * Set the pipe to blocking mode
     * */
    pub fn setBlocking (mut self) {
        if (self.isOpen ()) {
            let old = fcntl (self._pipe, FileFlags::F_GETFL, 0);
            fcntl (self._pipe, FileFlags::F_SETFL, old | !SocketFlag::O_NONBLOCK);
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * =============================        GETTERS        ============================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true if the pipe is open
     * */
    pub fn isOpen (self)-> bool {
        self._pipe >= 0 && !self._error
    }

    /**
     * ================================================================================
     * ================================================================================
     * ==============================        RECV        ==============================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Read a string from the pipe
     * @params:
     *    - len: the len of the string to read
     * */
    pub fn read {T of [U], U of c8} (mut self, len : usize)-> [c8]
        throws IOError
    {
        if (self.isOpen ()) {
            let dmut res = copy std::stream::StringStream ();
            let bufSize = 1024;
            let dmut chr = ['\u{0}' ; bufSize];
            let mut lenToRecv = len;

            while (lenToRecv > 0) {
                let currentRecv = if (lenToRecv > bufSize) { bufSize } else { lenToRecv };
                let valread = socket::read (self._pipe, chr.ptr, currentRecv);
                if (valread <= 0) {
                    self._error = true;
                    throw copy IOError ();
                }

                for i in 0 .. valread {
                    res:.write (buffer [i]);
                }

                lenToRecv -= valread;
            }

            return res[];
        }

        throw copy IOError ();
    }

    /**
     * Read a char from the pipe
     * @returns: the char read
     * @throws:
     *    - IOError, if the read fails
     * */
    pub fn if (std::traits::isChar!{C} ()) read {C} (mut self)-> C
        throws IOError
    {
        let mut res : C = '\u{0}';
        let dmut pv = cast!{dmut *void} (&res);
        let dmut pu = cast!{dmut *u8} (alias pv);

        self:.inner_ReadRaw (alias pu, C::size);

        res
    }

    /**
     * Read a int from the pipe
     * @returns: the int read
     * @throws:
     *    - IOError, if the read fails
     * */
    pub fn if (std::traits::isIntegral!{T} ()) read {T} (mut self)-> T
        throws IOError
    {
        let mut res : T = 0;
        let dmut pv = cast!{dmut *void} (&res);
        let dmut pu = cast!{dmut *u8} (alias pv);

        self:.inner_ReadRaw (alias pu, T::size);

        res
    }


    /**
     * Read a float from the pipe
     * @returns: the float read
     * @throws:
     *    - IOError, if the read fails
     * */
    pub fn if (std::traits::isFloating!{F} ()) read {F} (mut self)-> F
        throws IOError
    {
        let mut res : F = 0.f;
        let dmut pv = cast!{dmut *void} (&res);
        let dmut pu = cast!{dmut *u8} (alias pv);

        self:.inner_ReadRaw (alias pu, F::size);

        res
    }

    /**
     * Read raw value from the pipe
     * */
    prv fn inner_ReadRaw (mut self, dmut buffer : *u8, len : u32)
        throws core::exception::IOError
    {
        if (self.isOpen ()) {
            let dmut curr = alias buffer;
            let mut lenToRecv = len;

            while (lenToRecv > 0) {
                let valread = socket::read (self._pipe, cast!{*void} (curr), cast!usize (lenToRecv));
                if (valread <= 0) {
                    self._error = true;
                    throw copy core::exception::IOError ();
                }

                curr = alias (curr + cast!usize (valread));
                lenToRecv = lenToRecv - cast!u32 (valread);
            }
        } else {
            throw copy IOError ();
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * ==============================        CLOSE        =============================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Close the pipe
     * */
    pub fn dispose (mut self) {
        if (self.isOpen () && self._pipe >= 3) { // stderr = 2, out = 1, in = 0
            socket::close (self._pipe);
        }

        self._pipe = -1;
        self._error = false;
    }


}
