mod array;


pub fn outOfArray () {}


pub fn opCmp {T of [U], U} (a : T, b : T)-> i32 {
    let mi = if (b.len > a.len) { a.len } else { b.len };
    for i in 0us .. mi {
        if (a [i] < b [i]) return -1;
        else if (a [i] > b [i]) return 1;
    }

    if (a.len > b.len) return 1;
    else if (a.len < b.len) return -1;
    else return 0;
}



pub fn opCmp {T of [U ; N], J of [U], U, N : usize} (a : T, b : J)-> i32 {
    let mi = if (N > b.len) { b.len } else { N };
    for i in 0us .. mi {
        if (a [i] < b [i]) return -1;
        else if (a [i] > b [i]) return 1;
    }

    if (b.len > N) return -1;
    else if (b.len < N) return 1;
    else return 0;
}



pub fn opCmp {T of [U], J of [U ; N], U, N : usize} (a : T, b : J)-> i32 {
    let mi = if (N > a.len) { a.len } else { N };
    for i in 0us .. mi {
        if (a [i] < b [i]) return -1;
        else if (a [i] > b [i]) return 1;
    }

    if (a.len > N) return 1;
    else if (a.len < N) return -1;
    else return 0;
}

pub fn opCmp {T of [U ; N], U, N : usize} (a : T, b : T)-> i32 {
    for i in 0us .. N {
        if (a [i] < b [i]) return -1;
        else if (a [i] > b [i]) return 1;
    }

    0
}
