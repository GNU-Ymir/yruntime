in types;

pub trait Hashable {

    /**
     * Transform an object into a u64.
     * By default, it hashes all the fields of the class. If the class has an ancestor, and that ancestor is hashable, it is also hashed. If the ancestor class is not hashable it is simply ignored.
     * @warning: all the fields of the class must be hashable for this function to compile.
     * @complexity: O (n), with n = recursive number of field of the class
     */
    pub fn toHash (self)-> u64 {
        let mut res = cte if (__pragma!compile (self.super.toHash)) {
            self.super.toHash ()
        } else { 0x345678u64 };

        let mut mult = 31u64;
        mult;
        for i in (expand self,) {
            res = (res ^ core::hash::implem::__hash (i)) * mult;
            mult += (82520u64 + cast!u64 (typeof ((expand self,))::arity * 2us));
        }

        res
    }
}

pub trait Iterable {
    pub fn next (mut self);
}

pub trait Copiable {
    pub fn deepCopy (self)-> dmut (typeof self);
}

pub mod map;
pub mod array;
pub mod hash;
pub mod range;
pub mod info;
