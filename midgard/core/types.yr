in types;

pub trait Hashable {

    /**
     * Transform an object into a u64.
     * By default, it hashes all the fields of the class. If the class has an ancestor, and that ancestor is hashable, it is also hashed. If the ancestor class is not hashable it is simply ignored.
     * @warning: all the fields of the class must be hashable for this function to compile.
     * @complexity: O (n), with n = recursive number of field of the class
     */
    pub fn toHash (self)-> u64 {
        let mut res = cte if (__pragma!compile (self.super.toHash)) {
            self.super.toHash ()
        } else { 0x345678u64 };

        let mut mult = 31u64;
        mult;
        for i in (expand self,) {
            res = (res ^ core::types::hash::__hash (i)) * mult;
            mult += (82520u64 + cast!u64 (typeof ((expand self,))::arity * 2us));
        }

        res
    }
}

pub trait Iterable {
    pub fn next (mut self);
}

pub trait Copiable {
    pub fn deepCopy (self)-> dmut (typeof self);
}

pub mod map;
pub mod array;
pub mod hash;
pub mod range;
pub mod info;

/**
 * Macro used to write a utf8 literal on multiple lines.
 * @example:
 * ===
 * let a : [c8] = str#{
 *     This string contains
 *     Multiple lines
 *     But that is not a problem
 * };
 * ===
 */
pub macro str {
    self (content=(__char)*) {
        "#(content)"s8
    }
}

/**
 * Macro used to write a utf16 literal on multiple lines.
 * @example:
 * ===
 * let a : [c16] = str16#{
 *     This string contains
 *     Multiple lines
 *     But that is not a problem
 * };
 * ===
 */
pub macro str16 {
    self (content=(__char)*) {
        "#(content)"s16
    }
}

/**
 * Macro used to write a utf32 literal on multiple lines.
 * @example:
 * ===
 * let a : [c32] = str32#{
 *     This string contains
 *     Multiple lines
 *     But that is not a problem
 * };
 * ===
 */
pub macro str32 {
    self (content=(__char)*) {
        "#(content)"s32
    }
}
