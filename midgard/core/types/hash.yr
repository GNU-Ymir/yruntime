in hash;

mod Runtime {T} {
    pub extern (C) fn _yrt_ptr_to_u64 (a : T)-> u64;
}

/*!
 * ====================================================================================================
 * ====================================================================================================
 * ====================================          SCALARS          =====================================
 * ====================================================================================================
 * ====================================================================================================
 */

/**
 * Transform a char into a u64
 * @complexity: O(1)
 */
pub fn __hash (c : c8) -> u64 {
    cast!u64 (cast!u8 (c))
}

/**
 * Transform a char into a u64
 * @complexity: O(1)
 */
pub fn __hash (c : c32) -> u64 {
    cast!u64 (cast!u32 (c))
}

/**
 * Transform a isize into a u64
 * @complexity: O (1)
 */
pub fn __hash (i : isize) -> u64 {
    cast!u64 (i)
}

/**
 * Transform a usize into a u64
 * @complexity: O (1)
 */
pub fn __hash (i : usize) -> u64 {
    cast!u64 (i)
}

/**
 * Transform a i64 into a u64
 * @complexity: O (1)
 */
pub fn __hash (i : i64) -> u64 {
    cast!u64 (i)
}

/**
 * Transform a u64 into a u64
 * @complexity: O (1)
 */
pub fn __hash (i : u64) -> u64 {
    i
}

/**
 * Transform a i32 into a u64
 * @complexity: O (1)
 */
pub fn __hash (i : i32) -> u64 {
    cast!u64 (i)
}

/**
 * Transform a u32 into a u64
 * @complexity: O (1)
 */
pub fn __hash (i : u32) -> u64 {
    cast!u64 (i)
}

/**
 * Transform a i16 into a u64
 * @complexity: O (1)
 */
pub fn __hash (i : i16) -> u64 {
    cast!u64 (i)
}

/**
 * Transform a u16 into a u64
 * @complexity: O (1)
 */
pub fn __hash (i : u16) -> u64 {
    cast!u64 (i)
}

/**
 * Transform a i8 into a u64
 * @complexity: O (1)
 */
pub fn __hash (i : i8) -> u64 {
    cast!u64 (i)
}

/**
 * Transform a u8 into a u64
 * @complexity: O (1)
 */
pub fn __hash (i : u8) -> u64 {
    cast!u64 (i)
}

/**
 * Transform a bool into a u64
 * @complexity: O (1)
 */
pub fn __hash (b : bool) -> u64 {
    if (b) 0u64
    else 1u64
}

/**
 * Transform a f32 into a hashed u64.
 * @complexity: O(1)
 */
pub fn __hash (f : f32)-> u64 {
    let p : u32 = unsafe {
        *cast!{*u32} (&f)
    };

    cast!u64 (p)
}

/**
 * Transform a f64 into a hashed u64.
 * @complexity: O(1)
 */
pub fn __hash (f : f64)-> u64 {
    let p : u64 = unsafe {
        *cast!{*u64} (&f)
    };

    p
}

/*!
 * ====================================================================================================
 * ====================================================================================================
 * ===================================          COMPOUNDS          ====================================
 * ====================================================================================================
 * ====================================================================================================
 */

/**
 * Transform a slice into a u64.
 * If the slice contains class instances, they must implement the trait Hashable for the function to compile.
 * @complexity: O (n), with n = a.len
 * @templates:
 *    - U: a hashable type
 */
pub fn __hash {T of [U], U} (a : T) -> u64 {
    let p = 31u64;
    let m = 1_000_000_009u64;
    let mut res = 0u64;
    let mut p_pow = 1u64;
    for c in a {
        res = (res + (__hash (c) + 1u64) * p_pow) % m;
        p_pow = (p_pow * p) % m;
    }
    res
}

/**
 * Transform an array into a u64.
 * If the array contains class instances, they must implement the trait Hashable for the function to compile.
 * @complexity: O (n), with n = a.len
 * @templates:
 *    - U: a hashable type
 */
pub fn __hash {T of [U ; N], U, N : usize} (a : T)-> u64 {
    let p = 31u64;
    let m = 1_000_000_009u64;
    let mut res = 0u64;
    let mut p_pow = 1u64;

    for c in a {
        res = (res + (__hash (c) + 1u64) * p_pow) % m;
        p_pow = (p_pow * p) % m;
    }

    res
}

/**
 * Transform an array into a u64.
 * If the array contains class instances, they must implement the trait Hashable for the function to compile.
 * @complexity: O (n), with n = a.len
 * @templates:
 *    - U: a hashable type
 */
pub fn __hash {T of [U ; N], U, N : usize} (ref a : T)-> u64 {
    let p = 31u64;
    let m = 1_000_000_009u64;
    let mut res = 0u64;
    let mut p_pow = 1u64;

    for c in a {
        res = (res + (__hash (c) + 1u64) * p_pow) % m;
        p_pow = (p_pow * p) % m;
    }

    res
}

/**
 * Transform an option into a u64
 * @complexity: O (1)
 * */
pub fn __hash {T} (a : (T)?)-> u64 {
    if let Ok (x) = a {
        __hash (x)
    } else {
        0
    }
}

/**
 * Transform a tuple into a u64.
 * This transformation hash all the fields of the tuple. If the tuple contains objects, they must implement the trait Hashable for this function to compile.
 * @complexity: O (n), where n is the number of fields of the tuple.
 */
pub fn __hash {T...} (a : (T,))-> u64 {
    let mut res = 0x345678u64;
    let mut mult = 31u64;
    mult;

    for i in a {
        res = (res ^ __hash (i)) * mult;
        mult += (82520u64 + cast!u64 (typeof (a)::arity * 2us));
    }
    res
}

/*!
 * ====================================================================================================
 * ====================================================================================================
 * ====================================          POINTERS          ====================================
 * ====================================================================================================
 * ====================================================================================================
 */

/**
 * Transform a pointer into a u64.
 * @complexity: O (1)
 */
pub fn __hash {T} (x : *T) -> u64 {
    Runtime!{*T}::_yrt_ptr_to_u64 (x)
}

/**
 * Transform a function pointer into a u64.
 * @complexity: O (1)
 */
pub fn __hash {Z, T...} (x : fn (T)-> Z) -> u64 {
    Runtime!{fn(T)-> Z}::_yrt_ptr_to_u64 (x)
}

/**
 * Transform a function pointer into a u64.
 * @complexity: O (1)
 */
pub fn __hash {Z} (x : fn ()-> Z) -> u64 {
    Runtime!{fn()-> Z}::_yrt_ptr_to_u64 (x)
}

/**
 * Transform a function pointer into a u64.
 * @complexity: O (1)
 */
pub fn __hash {Z, T...} (x : dg (T)-> Z) -> u64 {
    0u64
}

/**
 * Transform a function pointer into a u64.
 * @complexity: O (1)
 */
pub fn __hash {Z} (x : dg ()-> Z) -> u64 {
    0u64
}


/*!
 * ====================================================================================================
 * ====================================================================================================
 * ==================================          CUSTOM TYPES          ==================================
 * ====================================================================================================
 * ====================================================================================================
 */

/**
 * Transform a class that implement the trait Hashable into a u64
 * @complexity: O (1), the real complexity depends on the method `hash` of the class
 */
pub fn __hash {T of C && of I, class C, I impl core::types::Hashable} (a : T)-> u64 {
    a.toHash ()
}

/**
 * Transform a struct into a u64.
 * This transformation hash all the fields of the struct. If the struct contains objects, they must implement the trait Hashable for this function to compile.
 * @complexity: O (n), where n is the number of fields of the struct.
 */
pub fn __hash {T of R && of I, record R, I impl core::types::Hashable} (a : T)-> u64 {
    a.toHash ()
}

/**
 * Transform a struct into a u64.
 * This transformation hash all the fields of the struct. If the struct contains objects, they must implement the trait Hashable for this function to compile.
 * @complexity: O (n), where n is the number of fields of the struct.
 */
pub fn __hash {T of R && of I, record R, I impl core::types::Hashable} (ref a : T)-> u64 {
    a.toHash ()
}

/**
 * Transform a struct into a u64.
 * This transformation hash all the fields of the struct. If the struct contains objects, they must implement the trait Hashable for this function to compile.
 * @complexity: O (n), where n is the number of fields of the struct.
 */
pub fn __hash {T of E && of I, entity E, I impl core::types::Hashable} (ref a : T)-> u64 {
    a.toHash ()
}
