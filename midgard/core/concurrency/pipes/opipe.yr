in opipe;

use etc::c::{files, socket};
use core::exception::io;

/**
 * A reading pipe
 * */
@final
pub class OPipe {

    // The managed pipe
    let mut _pipe : i32 = -1;

    // True if the pipe failed to read
    let mut _error : bool = false;

    /**
     * @params:
     *    - the reading pipe
     * */
    pub self (pipe : i32 = -1)
        with _pipe = pipe
        , _error = false
    {}

    /**
     * ================================================================================
     * ================================================================================
     * =============================        SETTERS        ============================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Set the pipe to non block mode
     * */
    pub fn setNonBlocking (mut self) {
        if (self.isOpen ()) {
            let old = fcntl (self._pipe, FileFlags::F_GETFL, 0);
            fcntl (self._pipe, FileFlags::F_SETFL, old | SocketFlag::O_NONBLOCK);
        }
    }

    /**
     * Set the pipe to blocking mode
     * */
    pub fn setBlocking (mut self) {
        if (self.isOpen ()) {
            let old = fcntl (self._pipe, FileFlags::F_GETFL, 0);
            fcntl (self._pipe, FileFlags::F_SETFL, old | !SocketFlag::O_NONBLOCK);
        }
    }

    /**
     * Set this pipe as the stdout of the current process
     * */
    pub fn setAsStdout (mut self) {
        etc::c::files::dup2 (self._pipe, etc::c::files::StdFileNumbers::STDOUT);
    }

    /**
     * Set this pipe as the stderr of the current process
     * */
    pub fn setAsStderr (mut self) {
        etc::c::files::dup2 (self._pipe, etc::c::files::StdFileNumbers::STDERR);
    }


    /**
     * ================================================================================
     * ================================================================================
     * =============================        GETTERS        ============================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true if the pipe is open
     * */
    pub fn isOpen (self)-> bool {
        self._pipe >= 0 && !self._error
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          ARRAYS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Write a slice on the pipe
     * @params:
     *    - sl : the slice to write
     * */
    pub fn if (std::traits::isScalar!{C} ()) write {T of [C], C} (mut self, sl : T)
        throws IOError
    {
        if (!self.isOpen ()) throw copy IOError ();

        {
            let pv = cast!{*void} (sl.ptr);
            let pu = cast!{*u8} (pv);
            self:.inner_WriteRaw (pu, sl.len * C::size);
        }
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          SCALAR          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Write a char on the pipe
     * @throws:
     *    - IOError, if the write fails
     * */
    pub fn if (std::traits::isScalar!{C} ()) write {C} (mut self, c : C)
        throws IOError
    {
        if (!self.isOpen ()) throw copy IOError ();
        let pv = cast!{*void} (&c);
        let pu = cast!{*u8} (pv);

        self:.inner_WriteRaw (pu, C::size);
    }

    /**
     * Write raw value on the pipe
     * */
    pub fn writeRaw (mut self, buffer : *u8, len : usize)
        throws IOError
    {
        if (!self.isOpen ()) throw copy IOError ();
        self:.inner_WriteRaw (buffer, len)
    }


    /**
     * Write raw value on the pipe
     * @warning: does not check wether the pipe is open or not
     * */
    prv fn inner_WriteRaw (mut self, buffer : *u8, len : usize)
        throws IOError
    {
        let mut curr = buffer;
        let mut lenToSend = len;

        while (lenToSend > 0) {
            let valsent = socket::write (self._pipe, cast!{*void} (curr), cast!usize (lenToSend));
            if (valsent <= 0) {
                self._error = true;
                throw copy core::exception::io::IOError ();
            }

            curr = (curr + cast!usize (valsent));
            lenToSend = lenToSend - cast!usize (valsent);
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * ==============================        CLOSE        =============================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Close the pipe
     * */
    pub fn dispose (mut self) {
        if (self.isOpen () && self._pipe >= 3) { // stderr = 2, out = 1, in = 0
            socket::close (self._pipe);
        }

        self._pipe = -1;
        self._error = false;
    }


    __dtor (mut self) {
        self:.dispose ();
    }

}
