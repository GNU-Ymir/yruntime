in ipipe;

use etc::c::{files, socket};
use core::exception::io;

/**
 * A reading pipe
 * */
@final
pub class IPipe {

    // The managed pipe
    let mut _pipe : i32 = -1;

    // True if the pipe failed to read
    let mut _error : bool = false;

    /**
     * @params:
     *    - the reading pipe
     * */
    pub self (pipe : i32 = -1)
        with _pipe = pipe
        , _error = false
    {}

    /**
     * ================================================================================
     * ================================================================================
     * =============================        SETTERS        ============================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Set the pipe to non block mode
     * */
    pub fn setNonBlocking (mut self) {
        if (self.isOpen ()) {
            let old = fcntl (self._pipe, FileFlags::F_GETFL, 0);
            fcntl (self._pipe, FileFlags::F_SETFL, old | SocketFlag::O_NONBLOCK);
        }
    }

    /**
     * Set the pipe to blocking mode
     * */
    pub fn setBlocking (mut self) {
        if (self.isOpen ()) {
            let old = fcntl (self._pipe, FileFlags::F_GETFL, 0);
            fcntl (self._pipe, FileFlags::F_SETFL, old | !SocketFlag::O_NONBLOCK);
        }
    }

    /**
     * Set this pipe as the stdin of the current process
     * */
    pub fn setAsStdin (mut self) {
        etc::c::files::dup2 (self._pipe, etc::c::files::StdFileNumbers::STDIN);
    }

    /**
     * ================================================================================
     * ================================================================================
     * =============================        GETTERS        ============================
     * ================================================================================
     * ================================================================================
     */

    /**
     * @returns: true if the pipe is open
     * */
    pub fn isOpen (self)-> bool {
        self._pipe >= 0 && !self._error
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          ARRAYS          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Read a slice from the pipe
     * @params:
     *    - len: the len of the slice to read
     * */
    pub fn if (std::traits::isScalar!{C} ()) read {T of [C], C} (mut self, len : usize)-> [C]
        throws IOError
    {
        if (!self.isOpen ()) throw copy IOError ();

        let dmut res = core::types::array::allocArray!{C} (len);
        let bufSize = 1024us;
        let dmut chr = [cast!{C} ('\u{0}') ; bufSize];
        let mut lenToRecv = len;
        let mut currIndex = 0us;

        while (lenToRecv > 0) {
            let currentRecv = if (lenToRecv > bufSize) { bufSize } else { lenToRecv };
            let valread = socket::read (self._pipe, cast!{dmut *void} (alias chr.ptr), currentRecv * C::size);
            if (valread <= 0) {
                self._error = true;
                throw copy IOError ();
            }

            for i in 0 .. valread {
                res [currIndex] = chr [i];
                currIndex += 1us;
            }

            lenToRecv -= cast!usize (valread);
        }

        res
    }

    /*!
     * ====================================================================================================
     * ====================================================================================================
     * =====================================          SCALAR          =====================================
     * ====================================================================================================
     * ====================================================================================================
     */

    /**
     * Read data from the pipe
     * @returns: the char read
     * @throws:
     *    - IOError, if the read fails
     * */
    pub fn if (std::traits::isScalar!{C} ()) read {C} (mut self)-> C
        throws IOError
    {
        let mut res : C = C::init;
        let dmut pv = cast!{dmut *void} (&res);
        let dmut pu = cast!{dmut *u8} (alias pv);

        self:.readRaw (alias pu, C::size);

        res
    }

    /**
     * Read raw value from the pipe
     * */
    pub fn readRaw (mut self, dmut buffer : *u8, len : usize)
        throws IOError
    {
        if (!self.isOpen ()) throw copy IOError ();
        self:.inner_ReadRaw (alias buffer, len)
    }

    /**
     * Inner read raw
     * @warning: does not check wether the pipe is open or not
     * */
    prv fn inner_ReadRaw (mut self, dmut buffer : *u8, len : usize)
        throws IOError
    {
        let dmut curr = alias buffer;
        let mut lenToRecv = len;

        while (lenToRecv > 0) {
            let valread = socket::read (self._pipe, cast!{*void} (curr), cast!usize (lenToRecv));
            if (valread <= 0) {
                self._error = true;
                throw copy IOError ();
            }

            curr = alias (curr + cast!usize (valread));
            lenToRecv = lenToRecv - cast!usize (valread);
        }
    }

    /**
     * ================================================================================
     * ================================================================================
     * ==============================        CLOSE        =============================
     * ================================================================================
     * ================================================================================
     */

    /**
     * Close the pipe
     * */
    pub fn dispose (mut self) {
        if (self.isOpen () && self._pipe >= 3) { // stderr = 2, out = 1, in = 0
            socket::close (self._pipe);
        }

        self._pipe = -1;
        self._error = false;
    }

    __dtor (mut self) {
        self:.dispose ();
    }

}
