/**
 * This module defines utility function for range types.
 * @Authors: Emile Cadorel
 * @License: GPLv3
 */

mod range;

/**
 * Create a range with a different step
 * @example:
 * ===
 * for i in (0 .. 10).stepBy (2) {
 *     println (i); // 0 2 4 8
 * }
 * ===
 */
pub fn stepBy {T, U} (x : ..T, s : U)-> ..T {
    // cte assert (is!{typeof (x.step)}{J of U});
    //
    let mut z = x;
    let step : (typeof x.step) = cast!{typeof x.step} (s);
    let zero : (typeof x.step) = cast!{typeof x.step} (0);
    if ((z.fst > z.scd && step > zero) || (z.fst < z.scd && step < zero)) {
        z.step = -step;
    } else {
        z.step = step;
    }

    return z;
}

/**
 * Count the number of elements in the range
 * */
pub fn countNbIterations {T, U} (fst : T, scd : T, step : U, contains : bool)-> usize {
    let (stepU, fstU, scdU, mut subU) = if (step < 0) {
        let fstU = cast!usize (scd);
        let scdU = cast!usize (fst);
        (cast!usize (-step), fstU, scdU, scdU - fstU)
    } else {
        let fstU = cast!usize (fst);
        let scdU = cast!usize (scd);
        (cast!usize (step), fstU, scdU, scdU - fstU)
    };

    let nbAll = subU / stepU;

    // Overflow
    if (nbAll == usize::max) return nbAll;
    if (contains) return nbAll + 1us;

    // recompute, because is it not necessarily == scd since the division might trunc the value
    let last = (nbAll * stepU) + fstU;
    if (last != scdU) return nbAll + 1us;

    nbAll
}

/**
 * Create a reversed range
 * @example:
 * ===
 * for i in (0 .. 3).reverse () {
 *     println (i); // 3 2 1
 * }
 * ===
 * */
pub fn reverse {T} (x : ..T)-> ..T {
    let mut z = x;
    let mut fst : (typeof z.fst) = z.fst;
    z.fst = z.scd;
    z.scd = fst;
    z.step = -z.step;

    z
}

/**
 * Check if a value is within the range
 * @example:
 * ===
 * assert (8 in 0 .. 10);
 * assert (3 in 10 .. 4);
 * assert (10 !in 0 .. 10);
 * assert ('a' in 'a' ... 'z');
 * ===
 */
pub fn opContains {T} (range : ..T, x : T) -> bool {
    if (range.contain) {
        if range.fst < range.scd {
            x >= range.fst && x <= range.scd
        } else {
            x >= range.scd && x <= range.fst
        }
    } else {
        if range.fst < range.scd {
            x >= range.fst && x < range.scd
        } else {
            x >= range.scd && x < range.fst
        }
    }
}
