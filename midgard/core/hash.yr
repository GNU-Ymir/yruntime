in hash;

mod Runtime {T} {
    pub extern (C) fn _yrt_ptr_to_u64 (a : T)-> u64;
}

pub trait Hashable {

    /**
     * Transform an object into a u64.
     * By default, it hashes all the fields of the class. If the class has an ancestor, and that ancestor is hashable, it is also hashed. If the ancestor class is not hashable it is simply ignored.
     * @warning: all the fields of the class must be hashable for this function to compile.
     * @complexity: O (n), with n = recursive number of field of the class
     */
    pub fn hash (self)-> u64 {
        let mut res = cte if (__pragma!compile (self.super.hash)) {
            self.super.hash ()
        } else { 0x345678u64 };

        let mut mult = 31u64;
        mult;
        for i in (expand self,) {
            res = (res ^ hash (i)) * mult;
            mult += (82520u64 + cast!u64 (typeof ((expand self,))::arity * 2us));
        }

        res
    }
}

/**
 * Transform a string into a u64
 * @complexity: O(n), with n = str.len
 */
pub fn hash (str : [c32]) -> u64 {
    let p = 31u64;
    let m = 1_000_000_009u64;
    let mut res = 0u64;
    let mut p_pow = 1u64;

    for c in str {
        res = (res + (cast!u64 (cast!u32 (c)) + 1u64) * p_pow) % m;
        p_pow = (p_pow * p) % m;
    }

    res
}


/**
 * Transform a string into a u64
 * @complexity: O(n), with n = str.len
 */
pub fn hash (str : [c8]) -> u64 {
    let p = 31u64;
    let m = 1_000_000_009u64;
    let mut res = 0u64;
    let mut p_pow = 1u64;
    for c in str {
        res = (res + (cast!u64 (cast!u8 (c)) + 1u64) * p_pow) % m;
        p_pow = (p_pow * p) % m;
    }
    res
}

/**
 * Transform a char into a u64
 * @complexity: O(1)
 */
pub fn hash (c : c8) -> u64 {
    cast!u64 (cast!u8 (c))
}

/**
 * Transform a char into a u64
 * @complexity: O(1)
 */
pub fn hash (c : c32) -> u64 {
    cast!u64 (cast!u32 (c))
}

/**
 * Transform a isize into a u64
 * @complexity: O (1)
 */
pub fn hash (i : isize) -> u64 {
    cast!u64 (i)
}

/**
 * Transform a usize into a u64
 * @complexity: O (1)
 */
pub fn hash (i : usize) -> u64 {
    cast!u64 (i)
}

/**
 * Transform a i64 into a u64
 * @complexity: O (1)
 */
pub fn hash (i : i64) -> u64 {
    cast!u64 (i)
}

/**
 * Transform a u64 into a u64
 * @complexity: O (1)
 */
pub fn hash (i : u64) -> u64 {
    i
}

/**
 * Transform a i32 into a u64
 * @complexity: O (1)
 */
pub fn hash (i : i32) -> u64 {
    cast!u64 (i)
}

/**
 * Transform a u32 into a u64
 * @complexity: O (1)
 */
pub fn hash (i : u32) -> u64 {
    cast!u64 (i)
}

/**
 * Transform a i16 into a u64
 * @complexity: O (1)
 */
pub fn hash (i : i16) -> u64 {
    cast!u64 (i)
}

/**
 * Transform a u16 into a u64
 * @complexity: O (1)
 */
pub fn hash (i : u16) -> u64 {
    cast!u64 (i)
}

/**
 * Transform a i8 into a u64
 * @complexity: O (1)
 */
pub fn hash (i : i8) -> u64 {
    cast!u64 (i)
}

/**
 * Transform a u8 into a u64
 * @complexity: O (1)
 */
pub fn hash (i : u8) -> u64 {
    cast!u64 (i)
}

/**
 * Transform a bool into a u64
 * @complexity: O (1)
 */
pub fn hash (b : bool) -> u64 {
    if (b) 0u64
    else 1u64
}

/**
 * Transform a f32 into a hashed u64.
 * @complexity: O(1)
 */
pub fn hash (f : f32)-> u64 {
    let p : u32 = unsafe {
        *cast!{*u32} (&f)
    };

    cast!u64 (p)
}

/**
 * Transform a f64 into a hashed u64.
 * @complexity: O(1)
 */
pub fn hash (f : f64)-> u64 {
    let p : u64 = unsafe {
        *cast!{*u64} (&f)
    };

    p
}

/**
 * Transform a slice into a u64.
 * If the slice contains class instances, they must implement the trait Hashable for the function to compile.
 * @complexity: O (n), with n = a.len
 * @templates:
 *    - U: a hashable type
 */
pub fn hash {T of [U], U} (a : T) -> u64 {
    let p = 31u64;
    let m = 1_000_000_009u64;
    let mut res = 0u64;
    let mut p_pow = 1u64;
    for c in a {
        res = (res + (hash (c) + 1u64) * p_pow) % m;
        p_pow = (p_pow * p) % m;
    }
    res
}

/**
 * Transform an array into a u64.
 * If the array contains class instances, they must implement the trait Hashable for the function to compile.
 * @complexity: O (n), with n = a.len
 * @templates:
 *    - U: a hashable type
 */
pub fn hash {T of [U ; N], U, N : usize} (a : T)-> u64 {
    let p = 31u64;
    let m = 1_000_000_009u64;
    let mut res = 0u64;
    let mut p_pow = 1u64;

    for c in a {
        res = (res + (hash (c) + 1u64) * p_pow) % m;
        p_pow = (p_pow * p) % m;
    }

    res
}

/**
 * Transform a pointer into a u64.
 * @complexity: O (1)
 */
pub fn hash {T} (x : *T) -> u64 {
    Runtime!{*T}::_yrt_ptr_to_u64 (x)
}

/**
 * Transform a pointer into a u64.
 * @complexity: O (1)
 */
pub fn hash {Z, T...} (x : fn (T)-> Z) -> u64 {
    Runtime!{fn(T)-> Z}::_yrt_ptr_to_u64 (x)
}

/**
 * Transform a pointer into a u64.
 * @complexity: O (1)
 */
pub fn hash {Z} (x : fn ()-> Z) -> u64 {
    Runtime!{fn()-> Z}::_yrt_ptr_to_u64 (x)
}

/**
 * Transform an option into a u64
 * @complexity: O (1)
 * */
pub fn hash {T} (a : (T)?)-> u64 {
    if let Ok (x) = a {
        hash (x)
    } else {
        0
    }
}


/**
 * Transform a class that implement the trait Hashable into a u64
 * @complexity: O (1), the real complexity depends on the method `hash` of the class
 */
pub fn hash {class T} (a : T) -> u64 {
    cte if (is!{T}{X impl std::hash::Hashable}) {
        a.hash ()
    } else {
        let mut res = 0x345678u64;
        let mut mult = 31u64;
        mult;

        for i in (expand a,) {
            res = (res ^ hash (i)) * mult;
            mult += (82520u64 + cast!u64 (typeof ((expand a,))::arity * 2us));
        }

        res
    }
}

/**
 * Transform a struct into a u64.
 * This transformation hash all the fields of the struct. If the struct contains objects, they must implement the trait Hashable for this function to compile.
 * @complexity: O (n), where n is the number of fields of the struct.
 */
pub fn hash {record T} (a : T)-> u64 {
    cte if (is!{T}{X impl std::hash::Hashable}) {
        a.hash ()
    } else {
        let mut res = 0x345678u64;
        let mut mult = 31u64;
        mult;

        for i in (expand a,) {
            res = (res ^ hash (i)) * mult;
            mult += (82520u64 + cast!u64 (typeof ((expand a,))::arity * 2us));
        }

        res
    }
}

/**
 * Transform a struct into a u64.
 * This transformation hash all the fields of the struct. If the struct contains objects, they must implement the trait Hashable for this function to compile.
 * @complexity: O (n), where n is the number of fields of the struct.
 */
pub fn hash {record T} (ref a : T)-> u64 {
    cte if (is!{T}{X impl std::hash::Hashable}) {
        a.hash ()
    } else {
        let mut res = 0x345678u64;
        let mut mult = 31u64;
        mult;

        for i in (expand a,) {
            res = (res ^ hash (i)) * mult;
            mult += (82520u64 + cast!u64 (typeof ((expand a,))::arity * 2us));
        }

        res
    }
}


/**
 * Transform a struct into a u64.
 * This transformation hash all the fields of the struct. If the struct contains objects, they must implement the trait Hashable for this function to compile.
 * @complexity: O (n), where n is the number of fields of the struct.
 */
pub fn hash {entity T} (ref a : T)-> u64 {
    cte if (is!{T}{X impl std::hash::Hashable}) {
        a.hash ()
    } else {
        let mut res = 0x345678u64;
        let mut mult = 31u64;
        mult;

        for i in (expand a,) {
            res = (res ^ hash (i)) * mult;
            mult += (82520u64 + cast!u64 (typeof ((expand a,))::arity * 2us));
        }

        res
    }
}

/**
 * Transform a tuple into a u64.
 * This transformation hash all the fields of the tuple. If the tuple contains objects, they must implement the trait Hashable for this function to compile.
 * @complexity: O (n), where n is the number of fields of the tuple.
 */
pub fn hash {T...} (a : (T,))-> u64 {
    let mut res = 0x345678u64;
    let mut mult = 31u64;
    mult;

    for i in a {
        res = (res ^ hash (i)) * mult;
        mult += (82520u64 + cast!u64 (typeof (a)::arity * 2us));
    }
    res
}
