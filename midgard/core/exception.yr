in exception;

extern (C) fn _yrt_exc_get_stack_trace ()-> [*(void)];
extern (C) fn _yrt_exc_resolve_stack_trace (trc : [*void])-> [c8];

/**
 * Ancestor of all exception types.
 */
@abstract
pub class Exception {

    let trace : [*(void)];

    __version DEBUG_LIB {
        self () with trace = _yrt_exc_get_stack_trace () {
        }
    } else {
        self () with trace = [] {
        }
    }

    impl std::stream::Streamable {

        // prot over __stream__streamContent (self, dmut _ : &std::stream::StringStream) -> bool {
        //     false
        // }

        pub over toStream (self, dmut stream : &std::stream::StringStream)-> void {
            stream:.write (self.__typeid__, " (");
            self.__stream__streamContent (alias stream);
            stream:.write (')');
            if (self.trace.len != 0us) {
                stream:.write (":\n"s8);
                stream:.write (self.getStackTrace ());
            }
        }

    }

    prot fn hasTrace (self)-> bool {
        self.trace.len != 0us
    }

    /**
     * @returns: the stacktrace generated when the exception was constructed.
     */
    @final
    pub fn getStackTrace (self) -> [c8] {
        __version DEBUG_LIB {
            _yrt_exc_resolve_stack_trace (self.trace)
        } else {
            []
        }
    }

}

/**
 * Exception thrown by the `assert` construction.
 */
@final
pub class AssertError over Exception {
    pub let msg : [c8];

    /**
     * @params:
     *     - msg: the messages passed to the assertion
     */
    pub self (msg : [c8]) with msg = msg {}

    impl std::stream::Streamable {
        pub over toStream (self, dmut stream : &std::stream::StringStream) {
            stream:.write (self.__typeid__, " (");
            self.__stream__streamContent (alias stream);
            stream:.write (')');
            if (self.trace.len != 0us) {
                stream:.write (":\n"s8);
                stream:.write (self.getStackTrace ());
            }
        }
    }
}

@abstract
pub class OptionException over Exception {
    pub self () {}
}

/**
 * Exception thrown when an option with no value is unwrapped
 * */
@final
pub class EmptyValOption over OptionException {
    pub self () {}
}

/**
 * Exception thrown when trying to access error field of an option with no error
 * */
@final
pub class EmptyErrOption over OptionException {
    pub self () {}
}

/**
 * Exception thrown when an collection type value is accessed outside of its memory bounds
 * */
@final
pub class OutOfArray over Exception {
    pub self () {}
}
