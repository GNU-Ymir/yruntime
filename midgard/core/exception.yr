mod core::exception;
import core::typeinfo;
import std::io;

extern (C) def _yrt_exc_rethrow ();
extern (C) def _yrt_exc_get_stack_trace ()-> [&(void)];
extern (C) def _yrt_exc_resolve_stack_trace (trc : [&void])-> [c8];

pub alias _yrt_jmp_buf_type = [u8 ; 200];


pub class @abstract Exception {

    let trace : [&(void)];

    self () with trace = _yrt_exc_get_stack_trace () {}

    impl std::io::Printable {
        
        prot over __stdio__printContent (self) -> bool {
            false            
        }

        pub over print (self)-> void {
            print (self::typeinfo.name, ' ', '(');
            self.__stdio__printContent ();
            print (')');
            if (self.trace.len != 0u64) {
                print (':', '\n');
                self.printStackTrace ();
            }
        }
        
    }

    prot def hasTrace (self)-> bool {
        self.trace.len != 0u64
    }
    
    pub def @final getStackTrace (self) -> [c8] {
        _yrt_exc_resolve_stack_trace (self.trace)
    }

    pub def @final printStackTrace (self) {
        if (self.trace.len != 0u64) {
            print (_yrt_exc_resolve_stack_trace (self.trace));
        }        
    }
}

pub class AssertError over Exception {
    pub let msg : [c32];

    pub self (msg : [c32]) with msg = msg {}

    impl std::io::Printable {
        pub over print (self) {
            self::super.print ();
        }
    }
}

pub class RuntimeError over Exception {
    pub let msg : [c8];

    pub self (msg : [c8]) with msg = msg {}

    impl std::io::Printable {
        pub over print (self) {
            self::super.print ();
        }
    }
}

pub class SegFault over Exception {
    pub self () {}

    impl std::io::Printable {
        pub over print (self) {
            self::super.print ();
        }
    }
}

pub def abort (test : bool, msg : [c32])
    throws &AssertError
{
    if (!test)
        throw AssertError::new (msg)
}

pub def abort (test : bool)
    throws &AssertError
{
    if (!test)
        throw AssertError::new ("")
}

pub def rethrow () {
    _yrt_exc_rethrow ();
}

pub extern (C) def _yrt_throw_seg_fault () -> void
    throws &SegFault
{
    throw SegFault::new ()
}

pub extern (C) def _yrt_throw_runtime_abort (c : [c8]) -> void
    throws &RuntimeError
{
    throw RuntimeError::new (c);
}
