in exception;

extern (C) fn _yrt_exc_get_stack_trace ()-> [*(void)];
extern (C) fn _yrt_exc_resolve_stack_trace (trc : [*void])-> [c8];

/**
 * Ancestor of all exception types.
 */
@abstract
pub class Exception {

    let trace : [*(void)];

    __version DEBUG_LIB {
        self () with trace = _yrt_exc_get_stack_trace () {
        }
    } else {
        self () with trace = [] {
        }
    }

    impl std::stream::Streamable {

        pub over toStream (self, dmut stream : &std::stream::StringStream)-> void {
            stream:.write (self.__typeid__, " (");
            self.__stream__streamContent (alias stream);
            stream:.write (')');
            if (self.trace.len != 0us) {
                stream:.write (":\n"s8);
                stream:.write (self.getStackTrace ());
            }
        }

    }

    prot fn hasTrace (self)-> bool {
        self.trace.len != 0us
    }

    /**
     * @returns: the stacktrace generated when the exception was constructed.
     */
    @final
    pub fn getStackTrace (self) -> [c8] {
        __version DEBUG_LIB {
            _yrt_exc_resolve_stack_trace (self.trace)
        } else {
            []
        }
    }

}

pub mod assertion;
pub mod io;
pub mod option;
