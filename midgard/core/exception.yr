mod core::exception;
import core::typeinfo;
import std::io;

extern (C) def _yrt_exc_rethrow ();
extern (C) def _yrt_exc_get_stack_trace ()-> [c8];

pub alias _yrt_jmp_buf_type = [u8 ; 200];


pub class @abstract Exception {

    let trace : [c8];

    self () with trace = _yrt_exc_get_stack_trace () {}

    impl std::io::Printable;

    pub def @final getStackTrace (self) -> [c8] {
        self.trace
    }
}

pub class AssertError over Exception {
    pub let msg : [c32];

    pub self (msg : [c32]) with msg = msg {}

    pub over print (self) {
        print ("AssertError (", self.msg, ")");
    }
}


pub class SegFault over Exception {
    pub self () {}

    pub over print (self) {
        print ("SegFault (\n", self.getStackTrace (), ")");
    }
}

pub def abort (test : bool, msg : [c32])
    throws &AssertError
{
    if (!test)
        throw AssertError::new (msg)
}

pub def abort (test : bool)
    throws &AssertError
{
    if (!test)
        throw AssertError::new ("")
}

pub def rethrow () {
    _yrt_exc_rethrow ();
}

pub extern (C) def _yrt_throw_seg_fault () -> void
    throws &SegFault
{
    throw SegFault::new ()
}
